import { ElementRef, Injectable, NgZone, Optional, Directive, ViewContainerRef, Input, EventEmitter, Component, ViewEncapsulation, Inject, Output, ViewChild, TemplateRef, HostListener, NgModule } from '@angular/core';
import { DOCUMENT, CommonModule } from '@angular/common';
import { OverlayConfig, ConnectionPositionPair, Overlay, OverlayModule } from '@angular/cdk/overlay';
import { FocusTrapFactory, A11yModule } from '@angular/cdk/a11y';
import { Directionality, BidiModule } from '@angular/cdk/bidi';
import { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';
import { trigger, transition, style, animate } from '@angular/animations';
import { ESCAPE } from '@angular/cdk/keycodes';
import { TemplatePortal } from '@angular/cdk/portal';
import { Subject, of } from 'rxjs';
import { take, takeUntil, tap, filter, switchMap, delay } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const transformPopover = trigger('transformPopover', [
    transition(':enter', [
        style({ opacity: 0, transform: 'scale(0.3)' }),
        animate('{{openTransition}}', style({ opacity: 1, transform: 'scale(1)' }))
    ]),
    transition(':leave', [
        animate('{{closeTransition}}', style({ opacity: 0, transform: 'scale(0.5)' }))
    ])
]);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const VALID_SCROLL = [
    'noop',
    'block',
    'reposition',
    'close'
];
/** @type {?} */
const VALID_HORIZ_ALIGN = [
    'before',
    'start',
    'center',
    'end',
    'after'
];
/** @type {?} */
const VALID_VERT_ALIGN = [
    'above',
    'start',
    'center',
    'end',
    'below'
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function getUnanchoredPopoverError() {
    return Error('SatPopover does not have an anchor.');
}
/**
 * @return {?}
 */
function getInvalidPopoverAnchorError() {
    return Error('SatPopover#anchor must be an instance of SatPopoverAnchor, ElementRef, or HTMLElement.');
}
/**
 * @return {?}
 */
function getInvalidPopoverError() {
    return Error('SatPopoverAnchor#satPopoverAnchor must be an instance of SatPopover.');
}
/**
 * @return {?}
 */
function getInvalidSatPopoverAnchorError() {
    return Error(`SatPopoverAnchor must be associated with a ` +
        `SatPopover component. ` +
        `Examples: <sat-popover [anchor]="satPopoverAnchorTemplateRef"> or ` +
        `<button satPopoverAnchor [satPopoverAnchor]="satPopoverTemplateRef">`);
}
/**
 * @param {?} alignment
 * @return {?}
 */
function getInvalidHorizontalAlignError(alignment) {
    return Error(generateGenericError('horizontalAlign/xAlign', alignment, VALID_HORIZ_ALIGN));
}
/**
 * @param {?} alignment
 * @return {?}
 */
function getInvalidVerticalAlignError(alignment) {
    return Error(generateGenericError('verticalAlign/yAlign', alignment, VALID_VERT_ALIGN));
}
/**
 * @param {?} strategy
 * @return {?}
 */
function getInvalidScrollStrategyError(strategy) {
    return Error(generateGenericError('scrollStrategy', strategy, VALID_SCROLL));
}
/**
 * @param {?} apiName
 * @param {?} invalid
 * @param {?} valid
 * @return {?}
 */
function generateGenericError(apiName, invalid, valid) {
    return `Invalid ${apiName}: '${invalid}'. Valid options are ${valid.map((/**
     * @param {?} v
     * @return {?}
     */
    v => `'${v}'`)).join(', ')}.`;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SatPopoverAnchoringService {
    /**
     * @param {?} _overlay
     * @param {?} _ngZone
     * @param {?} _dir
     */
    constructor(_overlay, _ngZone, _dir) {
        this._overlay = _overlay;
        this._ngZone = _ngZone;
        this._dir = _dir;
        /**
         * Emits when the popover is opened.
         */
        this.popoverOpened = new Subject();
        /**
         * Emits when the popover is closed.
         */
        this.popoverClosed = new Subject();
        /**
         * Whether the popover is presently open.
         */
        this._popoverOpen = false;
        /**
         * Emits when the service is destroyed.
         */
        this._onDestroy = new Subject();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // Destroy popover before terminating subscriptions so that any resulting
        // detachments update 'closed state'
        this._destroyPopover();
        // Terminate subscriptions
        if (this._notificationsSubscription) {
            this._notificationsSubscription.unsubscribe();
        }
        if (this._positionChangeSubscription) {
            this._positionChangeSubscription.unsubscribe();
        }
        this._onDestroy.next();
        this._onDestroy.complete();
        this.popoverOpened.complete();
        this.popoverClosed.complete();
    }
    /**
     * Anchor a popover instance to a view and connection element.
     * @param {?} popover
     * @param {?} viewContainerRef
     * @param {?} anchor
     * @return {?}
     */
    anchor(popover, viewContainerRef, anchor) {
        // If we're just changing the anchor element and the overlayRef already exists,
        // simply update the existing _overlayRef's anchor.
        if (this._popover === popover &&
            this._viewContainerRef === viewContainerRef &&
            this._overlayRef) {
            this._anchor = anchor instanceof ElementRef
                ? anchor.nativeElement
                : anchor;
            /** @type {?} */
            const config = this._overlayRef.getConfig();
            /** @type {?} */
            const strategy = (/** @type {?} */ (config.positionStrategy));
            strategy.setOrigin(this._anchor);
            this._overlayRef.updatePosition();
            return;
        }
        // Destroy any previous popovers
        this._destroyPopover();
        // Assign local refs
        this._popover = popover;
        this._viewContainerRef = viewContainerRef;
        this._anchor = anchor instanceof ElementRef
            ? anchor.nativeElement
            : anchor;
    }
    /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    isPopoverOpen() {
        return this._popoverOpen;
    }
    /**
     * Toggles the popover between the open and closed states.
     * @return {?}
     */
    togglePopover() {
        return this._popoverOpen ? this.closePopover() : this.openPopover();
    }
    /**
     * Opens the popover.
     * @param {?=} options
     * @return {?}
     */
    openPopover(options = {}) {
        if (!this._popoverOpen) {
            this._applyOpenOptions(options);
            this._createOverlay();
            this._subscribeToBackdrop();
            this._subscribeToEscape();
            this._subscribeToDetachments();
            this._saveOpenedState();
        }
    }
    /**
     * Closes the popover.
     * @param {?=} value
     * @return {?}
     */
    closePopover(value) {
        if (this._overlayRef) {
            this._saveClosedState(value);
            this._overlayRef.detach();
        }
    }
    /**
     * TODO: implement when the overlay's position can be dynamically changed
     * @return {?}
     */
    repositionPopover() {
        this.updatePopoverConfig();
    }
    /**
     * TODO: when the overlay's position can be dynamically changed, do not destroy
     * @return {?}
     */
    updatePopoverConfig() {
        this._destroyPopoverOnceClosed();
    }
    /**
     * Realign the popover to the anchor.
     * @return {?}
     */
    realignPopoverToAnchor() {
        if (this._overlayRef) {
            /** @type {?} */
            const config = this._overlayRef.getConfig();
            /** @type {?} */
            const strategy = (/** @type {?} */ (config.positionStrategy));
            strategy.reapplyLastPosition();
        }
    }
    /**
     * Get a reference to the anchor element.
     * @return {?}
     */
    getAnchorElement() {
        return this._anchor;
    }
    /**
     * Apply behavior properties on the popover based on the open options.
     * @private
     * @param {?} options
     * @return {?}
     */
    _applyOpenOptions(options) {
        // Only override restoreFocus as `false` if the option is explicitly `false`
        /** @type {?} */
        const restoreFocus = options.restoreFocus !== false;
        this._popover._restoreFocusOverride = restoreFocus;
        // Only override autoFocus as `false` if the option is explicitly `false`
        /** @type {?} */
        const autoFocus = options.autoFocus !== false;
        this._popover._autoFocusOverride = autoFocus;
    }
    /**
     * Create an overlay to be attached to the portal.
     * @private
     * @return {?}
     */
    _createOverlay() {
        // Create overlay if it doesn't yet exist
        if (!this._overlayRef) {
            this._portal = new TemplatePortal(this._popover._templateRef, this._viewContainerRef);
            /** @type {?} */
            const popoverConfig = {
                horizontalAlign: this._popover.horizontalAlign,
                verticalAlign: this._popover.verticalAlign,
                hasBackdrop: this._popover.hasBackdrop,
                backdropClass: this._popover.backdropClass,
                scrollStrategy: this._popover.scrollStrategy,
                forceAlignment: this._popover.forceAlignment,
                lockAlignment: this._popover.lockAlignment,
            };
            /** @type {?} */
            const overlayConfig = this._getOverlayConfig(popoverConfig, this._anchor);
            this._subscribeToPositionChanges((/** @type {?} */ (overlayConfig.positionStrategy)));
            this._overlayRef = this._overlay.create(overlayConfig);
        }
        // Actually open the popover
        this._overlayRef.attach(this._portal);
        return this._overlayRef;
    }
    /**
     * Removes the popover from the DOM. Does NOT update open state.
     * @private
     * @return {?}
     */
    _destroyPopover() {
        if (this._overlayRef) {
            this._overlayRef.dispose();
            this._overlayRef = null;
        }
    }
    /**
     * Destroys the popover immediately if it is closed, or waits until it
     * has been closed to destroy it.
     * @private
     * @return {?}
     */
    _destroyPopoverOnceClosed() {
        if (this.isPopoverOpen() && this._overlayRef) {
            this._overlayRef.detachments().pipe(take(1), takeUntil(this._onDestroy)).subscribe((/**
             * @return {?}
             */
            () => this._destroyPopover()));
        }
        else {
            this._destroyPopover();
        }
    }
    /**
     * Close popover when backdrop is clicked.
     * @private
     * @return {?}
     */
    _subscribeToBackdrop() {
        this._overlayRef
            .backdropClick()
            .pipe(tap((/**
         * @return {?}
         */
        () => this._popover.backdropClicked.emit())), filter((/**
         * @return {?}
         */
        () => this._popover.interactiveClose)), takeUntil(this.popoverClosed), takeUntil(this._onDestroy))
            .subscribe((/**
         * @return {?}
         */
        () => this.closePopover()));
    }
    /**
     * Close popover when escape keydown event occurs.
     * @private
     * @return {?}
     */
    _subscribeToEscape() {
        this._overlayRef
            .keydownEvents()
            .pipe(tap((/**
         * @param {?} event
         * @return {?}
         */
        event => this._popover.overlayKeydown.emit(event))), filter((/**
         * @param {?} event
         * @return {?}
         */
        event => event.keyCode === ESCAPE)), filter((/**
         * @return {?}
         */
        () => this._popover.interactiveClose)), takeUntil(this.popoverClosed), takeUntil(this._onDestroy))
            .subscribe((/**
         * @return {?}
         */
        () => this.closePopover()));
    }
    /**
     * Set state back to closed when detached.
     * @private
     * @return {?}
     */
    _subscribeToDetachments() {
        this._overlayRef
            .detachments()
            .pipe(takeUntil(this._onDestroy))
            .subscribe((/**
         * @return {?}
         */
        () => this._saveClosedState()));
    }
    /**
     * Save the opened state of the popover and emit.
     * @private
     * @return {?}
     */
    _saveOpenedState() {
        if (!this._popoverOpen) {
            this._popover._open = this._popoverOpen = true;
            this.popoverOpened.next();
            this._popover.opened.emit();
        }
    }
    /**
     * Save the closed state of the popover and emit.
     * @private
     * @param {?=} value
     * @return {?}
     */
    _saveClosedState(value) {
        if (this._popoverOpen) {
            this._popover._open = this._popoverOpen = false;
            this.popoverClosed.next(value);
            this._popover.closed.emit(value);
        }
    }
    /**
     * Gets the text direction of the containing app.
     * @private
     * @return {?}
     */
    _getDirection() {
        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
    }
    /**
     * Create and return a config for creating the overlay.
     * @private
     * @param {?} config
     * @param {?} anchor
     * @return {?}
     */
    _getOverlayConfig(config, anchor) {
        return new OverlayConfig({
            positionStrategy: this._getPositionStrategy(config.horizontalAlign, config.verticalAlign, config.forceAlignment, config.lockAlignment, anchor),
            hasBackdrop: config.hasBackdrop,
            backdropClass: config.backdropClass || 'cdk-overlay-transparent-backdrop',
            scrollStrategy: this._getScrollStrategyInstance(config.scrollStrategy),
            direction: this._getDirection(),
        });
    }
    /**
     * Listen to changes in the position of the overlay and set the correct alignment classes,
     * ensuring that the animation origin is correct, even with a fallback position.
     * @private
     * @param {?} position
     * @return {?}
     */
    _subscribeToPositionChanges(position) {
        if (this._positionChangeSubscription) {
            this._positionChangeSubscription.unsubscribe();
        }
        this._positionChangeSubscription = position.positionChanges
            .pipe(takeUntil(this._onDestroy))
            .subscribe((/**
         * @param {?} change
         * @return {?}
         */
        change => {
            // Position changes may occur outside the Angular zone
            this._ngZone.run((/**
             * @return {?}
             */
            () => {
                this._popover._setAlignmentClasses(getHorizontalPopoverAlignment(change.connectionPair.overlayX), getVerticalPopoverAlignment(change.connectionPair.overlayY));
            }));
        }));
    }
    /**
     * Map a scroll strategy string type to an instance of a scroll strategy.
     * @private
     * @param {?} strategy
     * @return {?}
     */
    _getScrollStrategyInstance(strategy) {
        switch (strategy) {
            case 'block':
                return this._overlay.scrollStrategies.block();
            case 'reposition':
                return this._overlay.scrollStrategies.reposition();
            case 'close':
                return this._overlay.scrollStrategies.close();
            case 'noop':
            default:
                return this._overlay.scrollStrategies.noop();
        }
    }
    /**
     * Create and return a position strategy based on config provided to the component instance.
     * @private
     * @param {?} horizontalTarget
     * @param {?} verticalTarget
     * @param {?} forceAlignment
     * @param {?} lockAlignment
     * @param {?} anchor
     * @return {?}
     */
    _getPositionStrategy(horizontalTarget, verticalTarget, forceAlignment, lockAlignment, anchor) {
        // Attach the overlay at the preferred position
        /** @type {?} */
        const targetPosition = getPosition(horizontalTarget, verticalTarget);
        /** @type {?} */
        const positions = [targetPosition];
        /** @type {?} */
        const strategy = this._overlay.position()
            .flexibleConnectedTo(anchor)
            .withFlexibleDimensions(false)
            .withPush(false)
            .withViewportMargin(0)
            .withLockedPosition(lockAlignment);
        // Unless the alignment is forced, add fallbacks based on the preferred positions
        if (!forceAlignment) {
            /** @type {?} */
            const fallbacks = this._getFallbacks(horizontalTarget, verticalTarget);
            positions.push(...fallbacks);
        }
        return strategy.withPositions(positions);
    }
    /**
     * Get fallback positions based around target alignments.
     * @private
     * @param {?} hTarget
     * @param {?} vTarget
     * @return {?}
     */
    _getFallbacks(hTarget, vTarget) {
        // Determine if the target alignments overlap the anchor
        /** @type {?} */
        const horizontalOverlapAllowed = hTarget !== 'before' && hTarget !== 'after';
        /** @type {?} */
        const verticalOverlapAllowed = vTarget !== 'above' && vTarget !== 'below';
        // If a target alignment doesn't cover the anchor, don't let any of the fallback alignments
        // cover the anchor
        /** @type {?} */
        const possibleHorizontalAlignments = horizontalOverlapAllowed ?
            ['before', 'start', 'center', 'end', 'after'] :
            ['before', 'after'];
        /** @type {?} */
        const possibleVerticalAlignments = verticalOverlapAllowed ?
            ['above', 'start', 'center', 'end', 'below'] :
            ['above', 'below'];
        // Create fallbacks for each allowed prioritized fallback alignment combo
        /** @type {?} */
        const fallbacks = [];
        prioritizeAroundTarget(hTarget, possibleHorizontalAlignments).forEach((/**
         * @param {?} h
         * @return {?}
         */
        h => {
            prioritizeAroundTarget(vTarget, possibleVerticalAlignments).forEach((/**
             * @param {?} v
             * @return {?}
             */
            v => {
                fallbacks.push(getPosition(h, v));
            }));
        }));
        // Remove the first item since it will be the target alignment and isn't considered a fallback
        return fallbacks.slice(1, fallbacks.length);
    }
}
SatPopoverAnchoringService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
SatPopoverAnchoringService.ctorParameters = () => [
    { type: Overlay },
    { type: NgZone },
    { type: Directionality, decorators: [{ type: Optional }] }
];
/**
 * Helper function to get a cdk position pair from SatPopover alignments.
 * @param {?} h
 * @param {?} v
 * @return {?}
 */
function getPosition(h, v) {
    const { originX, overlayX } = getHorizontalConnectionPosPair(h);
    const { originY, overlayY } = getVerticalConnectionPosPair(v);
    return new ConnectionPositionPair({ originX, originY }, { overlayX, overlayY });
}
/**
 * Helper function to convert an overlay connection position to equivalent popover alignment.
 * @param {?} h
 * @return {?}
 */
function getHorizontalPopoverAlignment(h) {
    if (h === 'start') {
        return 'after';
    }
    if (h === 'end') {
        return 'before';
    }
    return 'center';
}
/**
 * Helper function to convert an overlay connection position to equivalent popover alignment.
 * @param {?} v
 * @return {?}
 */
function getVerticalPopoverAlignment(v) {
    if (v === 'top') {
        return 'below';
    }
    if (v === 'bottom') {
        return 'above';
    }
    return 'center';
}
/**
 * Helper function to convert alignment to origin/overlay position pair.
 * @param {?} h
 * @return {?}
 */
function getHorizontalConnectionPosPair(h) {
    switch (h) {
        case 'before':
            return { originX: 'start', overlayX: 'end' };
        case 'start':
            return { originX: 'start', overlayX: 'start' };
        case 'end':
            return { originX: 'end', overlayX: 'end' };
        case 'after':
            return { originX: 'end', overlayX: 'start' };
        default:
            return { originX: 'center', overlayX: 'center' };
    }
}
/**
 * Helper function to convert alignment to origin/overlay position pair.
 * @param {?} v
 * @return {?}
 */
function getVerticalConnectionPosPair(v) {
    switch (v) {
        case 'above':
            return { originY: 'top', overlayY: 'bottom' };
        case 'start':
            return { originY: 'top', overlayY: 'top' };
        case 'end':
            return { originY: 'bottom', overlayY: 'bottom' };
        case 'below':
            return { originY: 'bottom', overlayY: 'top' };
        default:
            return { originY: 'center', overlayY: 'center' };
    }
}
/**
 * Helper function that takes an ordered array options and returns a reorderded
 * array around the target item. e.g.:
 *
 * target: 3; options: [1, 2, 3, 4, 5, 6, 7];
 *
 * return: [3, 4, 2, 5, 1, 6, 7]
 * @template T
 * @param {?} target
 * @param {?} options
 * @return {?}
 */
function prioritizeAroundTarget(target, options) {
    /** @type {?} */
    const targetIndex = options.indexOf(target);
    // Set the first item to be the target
    /** @type {?} */
    const reordered = [target];
    // Make left and right stacks where the highest priority item is last
    /** @type {?} */
    const left = options.slice(0, targetIndex);
    /** @type {?} */
    const right = options.slice(targetIndex + 1, options.length).reverse();
    // Alternate between stacks until one is empty
    while (left.length && right.length) {
        reordered.push(right.pop());
        reordered.push(left.pop());
    }
    // Flush out right side
    while (right.length) {
        reordered.push(right.pop());
    }
    // Flush out left side
    while (left.length) {
        reordered.push(left.pop());
    }
    return reordered;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// See http://cubic-bezier.com/#.25,.8,.25,1 for reference.
/** @type {?} */
const DEFAULT_TRANSITION = '200ms cubic-bezier(0.25, 0.8, 0.25, 1)';
class SatPopoverAnchor {
    /**
     * @param {?} elementRef
     * @param {?} viewContainerRef
     */
    constructor(elementRef, viewContainerRef) {
        this.elementRef = elementRef;
        this.viewContainerRef = viewContainerRef;
    }
    /**
     * @return {?}
     */
    get popover() {
        return this._popover;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set popover(val) {
        if (val instanceof SatPopover) {
            val.anchor = this;
        }
        else {
            // when a directive is added with no arguments,
            // angular assigns `''` as the argument
            if (val !== '') {
                throw getInvalidPopoverError();
            }
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (!this.popover) {
            throw getInvalidSatPopoverAnchorError();
        }
    }
}
SatPopoverAnchor.decorators = [
    { type: Directive, args: [{
                selector: '[satPopoverAnchor]',
                exportAs: 'satPopoverAnchor'
            },] }
];
/** @nocollapse */
SatPopoverAnchor.ctorParameters = () => [
    { type: ElementRef },
    { type: ViewContainerRef }
];
SatPopoverAnchor.propDecorators = {
    popover: [{ type: Input, args: ['satPopoverAnchor',] }]
};
class SatPopover {
    /**
     * @param {?} _focusTrapFactory
     * @param {?} _anchoringService
     * @param {?} _viewContainerRef
     * @param {?} _document
     */
    constructor(_focusTrapFactory, _anchoringService, _viewContainerRef, _document) {
        this._focusTrapFactory = _focusTrapFactory;
        this._viewContainerRef = _viewContainerRef;
        this._document = _document;
        this._horizontalAlign = 'center';
        this._verticalAlign = 'center';
        this._forceAlignment = false;
        this._lockAlignment = false;
        this._autoFocus = true;
        this._autoFocusOverride = true;
        this._restoreFocus = true;
        this._restoreFocusOverride = true;
        this._scrollStrategy = 'reposition';
        this._hasBackdrop = false;
        this._interactiveClose = true;
        this._openTransition = DEFAULT_TRANSITION;
        this._closeTransition = DEFAULT_TRANSITION;
        /**
         * Optional backdrop class.
         */
        this.backdropClass = '';
        /**
         * Emits when the popover is opened.
         */
        this.opened = new EventEmitter();
        /**
         * Emits when the popover is closed.
         */
        this.closed = new EventEmitter();
        /**
         * Emits when the popover has finished opening.
         */
        this.afterOpen = new EventEmitter();
        /**
         * Emits when the popover has finished closing.
         */
        this.afterClose = new EventEmitter();
        /**
         * Emits when the backdrop is clicked.
         */
        this.backdropClicked = new EventEmitter();
        /**
         * Emits when a keydown event is targeted to this popover's overlay.
         */
        this.overlayKeydown = new EventEmitter();
        /**
         * Classes to be added to the popover for setting the correct transform origin.
         */
        this._classList = {};
        /**
         * Whether the popover is presently open.
         */
        this._open = false;
        // `@internal` stripping doesn't seem to work if the property is
        // declared inside the constructor
        this._anchoringService = _anchoringService;
    }
    /**
     * Anchor element.
     * @return {?}
     */
    get anchor() {
        return this._anchor;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set anchor(val) {
        if (val instanceof SatPopoverAnchor) {
            val._popover = this;
            this._anchoringService.anchor(this, val.viewContainerRef, val.elementRef);
            this._anchor = val;
        }
        else if (val instanceof ElementRef || val instanceof HTMLElement) {
            this._anchoringService.anchor(this, this._viewContainerRef, val);
            this._anchor = val;
        }
        else if (val) {
            throw getInvalidPopoverAnchorError();
        }
    }
    /**
     * Alignment of the popover on the horizontal axis.
     * @return {?}
     */
    get horizontalAlign() {
        return this._horizontalAlign;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set horizontalAlign(val) {
        this._validateHorizontalAlign(val);
        if (this._horizontalAlign !== val) {
            this._horizontalAlign = val;
            this._anchoringService.repositionPopover();
        }
    }
    /**
     * Alignment of the popover on the x axis. Alias for `horizontalAlign`.
     * @return {?}
     */
    get xAlign() {
        return this.horizontalAlign;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set xAlign(val) {
        this.horizontalAlign = val;
    }
    /**
     * Alignment of the popover on the vertical axis.
     * @return {?}
     */
    get verticalAlign() {
        return this._verticalAlign;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set verticalAlign(val) {
        this._validateVerticalAlign(val);
        if (this._verticalAlign !== val) {
            this._verticalAlign = val;
            this._anchoringService.repositionPopover();
        }
    }
    /**
     * Alignment of the popover on the y axis. Alias for `verticalAlign`.
     * @return {?}
     */
    get yAlign() {
        return this.verticalAlign;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set yAlign(val) {
        this.verticalAlign = val;
    }
    /**
     * Whether the popover always opens with the specified alignment.
     * @return {?}
     */
    get forceAlignment() {
        return this._forceAlignment;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set forceAlignment(val) {
        /** @type {?} */
        const coercedVal = coerceBooleanProperty(val);
        if (this._forceAlignment !== coercedVal) {
            this._forceAlignment = coercedVal;
            this._anchoringService.repositionPopover();
        }
    }
    /**
     * Whether the popover's alignment is locked after opening. This prevents the popover
     * from changing its alignement when scrolling or changing the size of the viewport.
     * @return {?}
     */
    get lockAlignment() {
        return this._lockAlignment;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set lockAlignment(val) {
        /** @type {?} */
        const coercedVal = coerceBooleanProperty(val);
        if (this._lockAlignment !== coercedVal) {
            this._lockAlignment = coerceBooleanProperty(val);
            this._anchoringService.repositionPopover();
        }
    }
    /**
     * Whether the first focusable element should be focused on open.
     * @return {?}
     */
    get autoFocus() {
        return this._autoFocus && this._autoFocusOverride;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set autoFocus(val) {
        this._autoFocus = coerceBooleanProperty(val);
    }
    /**
     * Whether the popover should return focus to the previously focused element after closing.
     * @return {?}
     */
    get restoreFocus() {
        return this._restoreFocus && this._restoreFocusOverride;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set restoreFocus(val) {
        this._restoreFocus = coerceBooleanProperty(val);
    }
    /**
     * How the popover should handle scrolling.
     * @return {?}
     */
    get scrollStrategy() {
        return this._scrollStrategy;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set scrollStrategy(val) {
        this._validateScrollStrategy(val);
        if (this._scrollStrategy !== val) {
            this._scrollStrategy = val;
            this._anchoringService.updatePopoverConfig();
        }
    }
    /**
     * Whether the popover should have a backdrop (includes closing on click).
     * @return {?}
     */
    get hasBackdrop() {
        return this._hasBackdrop;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set hasBackdrop(val) {
        this._hasBackdrop = coerceBooleanProperty(val);
    }
    /**
     * Whether the popover should close when the user clicks the backdrop or presses ESC.
     * @return {?}
     */
    get interactiveClose() {
        return this._interactiveClose;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set interactiveClose(val) {
        this._interactiveClose = coerceBooleanProperty(val);
    }
    /**
     * Custom transition to use while opening.
     * @return {?}
     */
    get openTransition() {
        return this._openTransition;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set openTransition(val) {
        if (val) {
            this._openTransition = val;
        }
    }
    /**
     * Custom transition to use while closing.
     * @return {?}
     */
    get closeTransition() {
        return this._closeTransition;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set closeTransition(val) {
        if (val) {
            this._closeTransition = val;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._setAlignmentClasses();
    }
    /**
     * Open this popover.
     * @param {?=} options
     * @return {?}
     */
    open(options = {}) {
        if (this._anchor) {
            this._anchoringService.openPopover(options);
            return;
        }
        throw getUnanchoredPopoverError();
    }
    /**
     * Close this popover.
     * @param {?=} value
     * @return {?}
     */
    close(value) {
        this._anchoringService.closePopover(value);
    }
    /**
     * Toggle this popover open or closed.
     * @return {?}
     */
    toggle() {
        this._anchoringService.togglePopover();
    }
    /**
     * Realign the popover to the anchor.
     * @return {?}
     */
    realign() {
        this._anchoringService.realignPopoverToAnchor();
    }
    /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    isOpen() {
        return this._open;
    }
    /**
     * Allows programmatically setting a custom anchor.
     * @param {?} viewContainer
     * @param {?} el
     * @return {?}
     */
    setCustomAnchor(viewContainer, el) {
        this._anchor = el;
        this._anchoringService.anchor(this, viewContainer, el);
    }
    /**
     * Gets an animation config with customized (or default) transition values.
     * @return {?}
     */
    _getAnimation() {
        return {
            value: 'visible',
            params: { openTransition: this.openTransition, closeTransition: this.closeTransition }
        };
    }
    /**
     * Callback for when the popover is finished animating in or out.
     * @param {?} event
     * @return {?}
     */
    _onAnimationDone(event) {
        if (event.toState === 'visible') {
            this._trapFocus();
            this.afterOpen.emit();
        }
        else if (event.toState === 'void') {
            this._restoreFocusAndDestroyTrap();
            this.afterClose.emit();
        }
    }
    /**
     * Apply alignment classes based on alignment inputs.
     * @param {?=} horizAlign
     * @param {?=} vertAlign
     * @return {?}
     */
    _setAlignmentClasses(horizAlign = this.horizontalAlign, vertAlign = this.verticalAlign) {
        this._classList['sat-popover-before'] = horizAlign === 'before' || horizAlign === 'end';
        this._classList['sat-popover-after'] = horizAlign === 'after' || horizAlign === 'start';
        this._classList['sat-popover-above'] = vertAlign === 'above' || vertAlign === 'end';
        this._classList['sat-popover-below'] = vertAlign === 'below' || vertAlign === 'start';
        this._classList['sat-popover-center'] = horizAlign === 'center' || vertAlign === 'center';
    }
    /**
     * Move the focus inside the focus trap and remember where to return later.
     * @private
     * @return {?}
     */
    _trapFocus() {
        this._savePreviouslyFocusedElement();
        // There won't be a focus trap element if the close animation starts before open finishes
        if (!this._focusTrapElement) {
            return;
        }
        if (!this._focusTrap && this._focusTrapElement) {
            this._focusTrap = this._focusTrapFactory.create(this._focusTrapElement.nativeElement);
        }
        if (this.autoFocus) {
            this._focusTrap.focusInitialElementWhenReady();
        }
    }
    /**
     * Restore focus to the element focused before the popover opened. Also destroy trap.
     * @private
     * @return {?}
     */
    _restoreFocusAndDestroyTrap() {
        /** @type {?} */
        const toFocus = this._previouslyFocusedElement;
        // Must check active element is focusable for IE sake
        if (toFocus && 'focus' in toFocus && this.restoreFocus) {
            this._previouslyFocusedElement.focus();
        }
        this._previouslyFocusedElement = null;
        if (this._focusTrap) {
            this._focusTrap.destroy();
            this._focusTrap = undefined;
        }
    }
    /**
     * Save a reference to the element focused before the popover was opened.
     * @private
     * @return {?}
     */
    _savePreviouslyFocusedElement() {
        if (this._document) {
            this._previouslyFocusedElement = (/** @type {?} */ (this._document.activeElement));
        }
    }
    /**
     * Throws an error if the alignment is not a valid horizontalAlign.
     * @private
     * @param {?} pos
     * @return {?}
     */
    _validateHorizontalAlign(pos) {
        if (VALID_HORIZ_ALIGN.indexOf(pos) === -1) {
            throw getInvalidHorizontalAlignError(pos);
        }
    }
    /**
     * Throws an error if the alignment is not a valid verticalAlign.
     * @private
     * @param {?} pos
     * @return {?}
     */
    _validateVerticalAlign(pos) {
        if (VALID_VERT_ALIGN.indexOf(pos) === -1) {
            throw getInvalidVerticalAlignError(pos);
        }
    }
    /**
     * Throws an error if the scroll strategy is not a valid strategy.
     * @private
     * @param {?} strategy
     * @return {?}
     */
    _validateScrollStrategy(strategy) {
        if (VALID_SCROLL.indexOf(strategy) === -1) {
            throw getInvalidScrollStrategyError(strategy);
        }
    }
}
SatPopover.decorators = [
    { type: Component, args: [{
                selector: 'sat-popover',
                encapsulation: ViewEncapsulation.None,
                animations: [transformPopover],
                template: "<ng-template>\n  <div class=\"sat-popover-container\"\n      #focusTrapElement\n      [ngClass]=\"_classList\"\n      [@transformPopover]=\"_getAnimation()\"\n      (@transformPopover.done)=\"_onAnimationDone($event)\">\n    <ng-content></ng-content>\n  </div>\n</ng-template>\n",
                providers: [SatPopoverAnchoringService],
                styles: [".cdk-global-overlay-wrapper,.cdk-overlay-container{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}@media screen and (-ms-high-contrast:active){.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop,.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}.sat-popover-container.sat-popover-before.sat-popover-above{-webkit-transform-origin:right bottom;transform-origin:right bottom}[dir=rtl] .sat-popover-container.sat-popover-before.sat-popover-above{-webkit-transform-origin:left bottom;transform-origin:left bottom}.sat-popover-container.sat-popover-before.sat-popover-center{-webkit-transform-origin:right center;transform-origin:right center}[dir=rtl] .sat-popover-container.sat-popover-before.sat-popover-center{-webkit-transform-origin:left center;transform-origin:left center}.sat-popover-container.sat-popover-before.sat-popover-below{-webkit-transform-origin:right top;transform-origin:right top}[dir=rtl] .sat-popover-container.sat-popover-before.sat-popover-below{-webkit-transform-origin:left top;transform-origin:left top}.sat-popover-container.sat-popover-center.sat-popover-above{-webkit-transform-origin:center bottom;transform-origin:center bottom}.sat-popover-container.sat-popover-center.sat-popover-below{-webkit-transform-origin:center top;transform-origin:center top}.sat-popover-container.sat-popover-after.sat-popover-above{-webkit-transform-origin:left bottom;transform-origin:left bottom}[dir=rtl] .sat-popover-container.sat-popover-after.sat-popover-above{-webkit-transform-origin:right bottom;transform-origin:right bottom}.sat-popover-container.sat-popover-after.sat-popover-center{-webkit-transform-origin:left center;transform-origin:left center}[dir=rtl] .sat-popover-container.sat-popover-after.sat-popover-center{-webkit-transform-origin:right center;transform-origin:right center}.sat-popover-container.sat-popover-after.sat-popover-below{-webkit-transform-origin:left top;transform-origin:left top}[dir=rtl] .sat-popover-container.sat-popover-after.sat-popover-below{-webkit-transform-origin:right top;transform-origin:right top}"]
            }] }
];
/** @nocollapse */
SatPopover.ctorParameters = () => [
    { type: FocusTrapFactory },
    { type: SatPopoverAnchoringService },
    { type: ViewContainerRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
];
SatPopover.propDecorators = {
    anchor: [{ type: Input }],
    horizontalAlign: [{ type: Input }],
    xAlign: [{ type: Input }],
    verticalAlign: [{ type: Input }],
    yAlign: [{ type: Input }],
    forceAlignment: [{ type: Input }],
    lockAlignment: [{ type: Input }],
    autoFocus: [{ type: Input }],
    restoreFocus: [{ type: Input }],
    scrollStrategy: [{ type: Input }],
    hasBackdrop: [{ type: Input }],
    interactiveClose: [{ type: Input }],
    openTransition: [{ type: Input }],
    closeTransition: [{ type: Input }],
    backdropClass: [{ type: Input }],
    opened: [{ type: Output }],
    closed: [{ type: Output }],
    afterOpen: [{ type: Output }],
    afterClose: [{ type: Output }],
    backdropClicked: [{ type: Output }],
    overlayKeydown: [{ type: Output }],
    _templateRef: [{ type: ViewChild, args: [TemplateRef, { static: true },] }],
    _focusTrapElement: [{ type: ViewChild, args: ['focusTrapElement', { static: false },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SatPopoverHoverDirective {
    /**
     * @param {?} anchor
     */
    constructor(anchor) {
        this.anchor = anchor;
        this._satPopoverHover = 0;
        /**
         * Emits when the directive is destroyed.
         */
        this._onDestroy = new Subject();
        /**
         * Emits when the user's mouse enters the element.
         */
        this._onMouseEnter = new Subject();
        /**
         * Emits when the user's mouse leaves the element.
         */
        this._onMouseLeave = new Subject();
    }
    /**
     * Amount of time to delay (ms) after hovering starts before
     * the popover opens. Defaults to 0ms.
     * @return {?}
     */
    get satPopoverHover() { return this._satPopoverHover; }
    /**
     * @param {?} val
     * @return {?}
     */
    set satPopoverHover(val) {
        this._satPopoverHover = coerceNumberProperty(val);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // Whenever the user hovers this host element, delay the configured
        // amount of time and open the popover. Terminate if the mouse leaves
        // the host element before the delay is complete.
        this._onMouseEnter
            .pipe(switchMap((/**
         * @return {?}
         */
        () => {
            return of(null).pipe(delay(this._satPopoverHover || 0), takeUntil(this._onMouseLeave));
        })), takeUntil(this._onDestroy))
            .subscribe((/**
         * @return {?}
         */
        () => this.anchor.popover.open()));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._onDestroy.next();
        this._onDestroy.complete();
    }
    /**
     * @return {?}
     */
    showPopover() {
        this._onMouseEnter.next();
    }
    /**
     * @return {?}
     */
    closePopover() {
        this._onMouseLeave.next();
        this.anchor.popover.close();
    }
}
SatPopoverHoverDirective.decorators = [
    { type: Directive, args: [{
                selector: '[satPopoverHover]'
            },] }
];
/** @nocollapse */
SatPopoverHoverDirective.ctorParameters = () => [
    { type: SatPopoverAnchor }
];
SatPopoverHoverDirective.propDecorators = {
    satPopoverHover: [{ type: Input }],
    showPopover: [{ type: HostListener, args: ['mouseenter',] }],
    closePopover: [{ type: HostListener, args: ['mouseleave',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SatPopoverModule {
}
SatPopoverModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    OverlayModule,
                    A11yModule,
                    BidiModule,
                ],
                declarations: [
                    SatPopover,
                    SatPopoverAnchor,
                    SatPopoverHoverDirective,
                ],
                exports: [
                    SatPopover,
                    SatPopoverAnchor,
                    SatPopoverHoverDirective,
                    BidiModule,
                ]
            },] }
];

export { SatPopover, SatPopoverAnchor, SatPopoverAnchoringService, SatPopoverHoverDirective, SatPopoverModule, transformPopover as ɵa };
//# sourceMappingURL=ncstate-sat-popover.js.map
