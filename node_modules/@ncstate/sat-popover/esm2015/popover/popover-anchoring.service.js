/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ElementRef, Injectable, NgZone, Optional } from '@angular/core';
import { ConnectionPositionPair, Overlay, OverlayConfig, } from '@angular/cdk/overlay';
import { Directionality } from '@angular/cdk/bidi';
import { ESCAPE } from '@angular/cdk/keycodes';
import { TemplatePortal } from '@angular/cdk/portal';
import { Subject } from 'rxjs';
import { takeUntil, take, filter, tap } from 'rxjs/operators';
/**
 * Configuration provided by the popover for the anchoring service
 * to build the correct overlay config.
 * @record
 */
function PopoverConfig() { }
if (false) {
    /** @type {?} */
    PopoverConfig.prototype.horizontalAlign;
    /** @type {?} */
    PopoverConfig.prototype.verticalAlign;
    /** @type {?} */
    PopoverConfig.prototype.hasBackdrop;
    /** @type {?} */
    PopoverConfig.prototype.backdropClass;
    /** @type {?} */
    PopoverConfig.prototype.scrollStrategy;
    /** @type {?} */
    PopoverConfig.prototype.forceAlignment;
    /** @type {?} */
    PopoverConfig.prototype.lockAlignment;
}
export class SatPopoverAnchoringService {
    /**
     * @param {?} _overlay
     * @param {?} _ngZone
     * @param {?} _dir
     */
    constructor(_overlay, _ngZone, _dir) {
        this._overlay = _overlay;
        this._ngZone = _ngZone;
        this._dir = _dir;
        /**
         * Emits when the popover is opened.
         */
        this.popoverOpened = new Subject();
        /**
         * Emits when the popover is closed.
         */
        this.popoverClosed = new Subject();
        /**
         * Whether the popover is presently open.
         */
        this._popoverOpen = false;
        /**
         * Emits when the service is destroyed.
         */
        this._onDestroy = new Subject();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // Destroy popover before terminating subscriptions so that any resulting
        // detachments update 'closed state'
        this._destroyPopover();
        // Terminate subscriptions
        if (this._notificationsSubscription) {
            this._notificationsSubscription.unsubscribe();
        }
        if (this._positionChangeSubscription) {
            this._positionChangeSubscription.unsubscribe();
        }
        this._onDestroy.next();
        this._onDestroy.complete();
        this.popoverOpened.complete();
        this.popoverClosed.complete();
    }
    /**
     * Anchor a popover instance to a view and connection element.
     * @param {?} popover
     * @param {?} viewContainerRef
     * @param {?} anchor
     * @return {?}
     */
    anchor(popover, viewContainerRef, anchor) {
        // If we're just changing the anchor element and the overlayRef already exists,
        // simply update the existing _overlayRef's anchor.
        if (this._popover === popover &&
            this._viewContainerRef === viewContainerRef &&
            this._overlayRef) {
            this._anchor = anchor instanceof ElementRef
                ? anchor.nativeElement
                : anchor;
            /** @type {?} */
            const config = this._overlayRef.getConfig();
            /** @type {?} */
            const strategy = (/** @type {?} */ (config.positionStrategy));
            strategy.setOrigin(this._anchor);
            this._overlayRef.updatePosition();
            return;
        }
        // Destroy any previous popovers
        this._destroyPopover();
        // Assign local refs
        this._popover = popover;
        this._viewContainerRef = viewContainerRef;
        this._anchor = anchor instanceof ElementRef
            ? anchor.nativeElement
            : anchor;
    }
    /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    isPopoverOpen() {
        return this._popoverOpen;
    }
    /**
     * Toggles the popover between the open and closed states.
     * @return {?}
     */
    togglePopover() {
        return this._popoverOpen ? this.closePopover() : this.openPopover();
    }
    /**
     * Opens the popover.
     * @param {?=} options
     * @return {?}
     */
    openPopover(options = {}) {
        if (!this._popoverOpen) {
            this._applyOpenOptions(options);
            this._createOverlay();
            this._subscribeToBackdrop();
            this._subscribeToEscape();
            this._subscribeToDetachments();
            this._saveOpenedState();
        }
    }
    /**
     * Closes the popover.
     * @param {?=} value
     * @return {?}
     */
    closePopover(value) {
        if (this._overlayRef) {
            this._saveClosedState(value);
            this._overlayRef.detach();
        }
    }
    /**
     * TODO: implement when the overlay's position can be dynamically changed
     * @return {?}
     */
    repositionPopover() {
        this.updatePopoverConfig();
    }
    /**
     * TODO: when the overlay's position can be dynamically changed, do not destroy
     * @return {?}
     */
    updatePopoverConfig() {
        this._destroyPopoverOnceClosed();
    }
    /**
     * Realign the popover to the anchor.
     * @return {?}
     */
    realignPopoverToAnchor() {
        if (this._overlayRef) {
            /** @type {?} */
            const config = this._overlayRef.getConfig();
            /** @type {?} */
            const strategy = (/** @type {?} */ (config.positionStrategy));
            strategy.reapplyLastPosition();
        }
    }
    /**
     * Get a reference to the anchor element.
     * @return {?}
     */
    getAnchorElement() {
        return this._anchor;
    }
    /**
     * Apply behavior properties on the popover based on the open options.
     * @private
     * @param {?} options
     * @return {?}
     */
    _applyOpenOptions(options) {
        // Only override restoreFocus as `false` if the option is explicitly `false`
        /** @type {?} */
        const restoreFocus = options.restoreFocus !== false;
        this._popover._restoreFocusOverride = restoreFocus;
        // Only override autoFocus as `false` if the option is explicitly `false`
        /** @type {?} */
        const autoFocus = options.autoFocus !== false;
        this._popover._autoFocusOverride = autoFocus;
    }
    /**
     * Create an overlay to be attached to the portal.
     * @private
     * @return {?}
     */
    _createOverlay() {
        // Create overlay if it doesn't yet exist
        if (!this._overlayRef) {
            this._portal = new TemplatePortal(this._popover._templateRef, this._viewContainerRef);
            /** @type {?} */
            const popoverConfig = {
                horizontalAlign: this._popover.horizontalAlign,
                verticalAlign: this._popover.verticalAlign,
                hasBackdrop: this._popover.hasBackdrop,
                backdropClass: this._popover.backdropClass,
                scrollStrategy: this._popover.scrollStrategy,
                forceAlignment: this._popover.forceAlignment,
                lockAlignment: this._popover.lockAlignment,
            };
            /** @type {?} */
            const overlayConfig = this._getOverlayConfig(popoverConfig, this._anchor);
            this._subscribeToPositionChanges((/** @type {?} */ (overlayConfig.positionStrategy)));
            this._overlayRef = this._overlay.create(overlayConfig);
        }
        // Actually open the popover
        this._overlayRef.attach(this._portal);
        return this._overlayRef;
    }
    /**
     * Removes the popover from the DOM. Does NOT update open state.
     * @private
     * @return {?}
     */
    _destroyPopover() {
        if (this._overlayRef) {
            this._overlayRef.dispose();
            this._overlayRef = null;
        }
    }
    /**
     * Destroys the popover immediately if it is closed, or waits until it
     * has been closed to destroy it.
     * @private
     * @return {?}
     */
    _destroyPopoverOnceClosed() {
        if (this.isPopoverOpen() && this._overlayRef) {
            this._overlayRef.detachments().pipe(take(1), takeUntil(this._onDestroy)).subscribe((/**
             * @return {?}
             */
            () => this._destroyPopover()));
        }
        else {
            this._destroyPopover();
        }
    }
    /**
     * Close popover when backdrop is clicked.
     * @private
     * @return {?}
     */
    _subscribeToBackdrop() {
        this._overlayRef
            .backdropClick()
            .pipe(tap((/**
         * @return {?}
         */
        () => this._popover.backdropClicked.emit())), filter((/**
         * @return {?}
         */
        () => this._popover.interactiveClose)), takeUntil(this.popoverClosed), takeUntil(this._onDestroy))
            .subscribe((/**
         * @return {?}
         */
        () => this.closePopover()));
    }
    /**
     * Close popover when escape keydown event occurs.
     * @private
     * @return {?}
     */
    _subscribeToEscape() {
        this._overlayRef
            .keydownEvents()
            .pipe(tap((/**
         * @param {?} event
         * @return {?}
         */
        event => this._popover.overlayKeydown.emit(event))), filter((/**
         * @param {?} event
         * @return {?}
         */
        event => event.keyCode === ESCAPE)), filter((/**
         * @return {?}
         */
        () => this._popover.interactiveClose)), takeUntil(this.popoverClosed), takeUntil(this._onDestroy))
            .subscribe((/**
         * @return {?}
         */
        () => this.closePopover()));
    }
    /**
     * Set state back to closed when detached.
     * @private
     * @return {?}
     */
    _subscribeToDetachments() {
        this._overlayRef
            .detachments()
            .pipe(takeUntil(this._onDestroy))
            .subscribe((/**
         * @return {?}
         */
        () => this._saveClosedState()));
    }
    /**
     * Save the opened state of the popover and emit.
     * @private
     * @return {?}
     */
    _saveOpenedState() {
        if (!this._popoverOpen) {
            this._popover._open = this._popoverOpen = true;
            this.popoverOpened.next();
            this._popover.opened.emit();
        }
    }
    /**
     * Save the closed state of the popover and emit.
     * @private
     * @param {?=} value
     * @return {?}
     */
    _saveClosedState(value) {
        if (this._popoverOpen) {
            this._popover._open = this._popoverOpen = false;
            this.popoverClosed.next(value);
            this._popover.closed.emit(value);
        }
    }
    /**
     * Gets the text direction of the containing app.
     * @private
     * @return {?}
     */
    _getDirection() {
        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
    }
    /**
     * Create and return a config for creating the overlay.
     * @private
     * @param {?} config
     * @param {?} anchor
     * @return {?}
     */
    _getOverlayConfig(config, anchor) {
        return new OverlayConfig({
            positionStrategy: this._getPositionStrategy(config.horizontalAlign, config.verticalAlign, config.forceAlignment, config.lockAlignment, anchor),
            hasBackdrop: config.hasBackdrop,
            backdropClass: config.backdropClass || 'cdk-overlay-transparent-backdrop',
            scrollStrategy: this._getScrollStrategyInstance(config.scrollStrategy),
            direction: this._getDirection(),
        });
    }
    /**
     * Listen to changes in the position of the overlay and set the correct alignment classes,
     * ensuring that the animation origin is correct, even with a fallback position.
     * @private
     * @param {?} position
     * @return {?}
     */
    _subscribeToPositionChanges(position) {
        if (this._positionChangeSubscription) {
            this._positionChangeSubscription.unsubscribe();
        }
        this._positionChangeSubscription = position.positionChanges
            .pipe(takeUntil(this._onDestroy))
            .subscribe((/**
         * @param {?} change
         * @return {?}
         */
        change => {
            // Position changes may occur outside the Angular zone
            this._ngZone.run((/**
             * @return {?}
             */
            () => {
                this._popover._setAlignmentClasses(getHorizontalPopoverAlignment(change.connectionPair.overlayX), getVerticalPopoverAlignment(change.connectionPair.overlayY));
            }));
        }));
    }
    /**
     * Map a scroll strategy string type to an instance of a scroll strategy.
     * @private
     * @param {?} strategy
     * @return {?}
     */
    _getScrollStrategyInstance(strategy) {
        switch (strategy) {
            case 'block':
                return this._overlay.scrollStrategies.block();
            case 'reposition':
                return this._overlay.scrollStrategies.reposition();
            case 'close':
                return this._overlay.scrollStrategies.close();
            case 'noop':
            default:
                return this._overlay.scrollStrategies.noop();
        }
    }
    /**
     * Create and return a position strategy based on config provided to the component instance.
     * @private
     * @param {?} horizontalTarget
     * @param {?} verticalTarget
     * @param {?} forceAlignment
     * @param {?} lockAlignment
     * @param {?} anchor
     * @return {?}
     */
    _getPositionStrategy(horizontalTarget, verticalTarget, forceAlignment, lockAlignment, anchor) {
        // Attach the overlay at the preferred position
        /** @type {?} */
        const targetPosition = getPosition(horizontalTarget, verticalTarget);
        /** @type {?} */
        const positions = [targetPosition];
        /** @type {?} */
        const strategy = this._overlay.position()
            .flexibleConnectedTo(anchor)
            .withFlexibleDimensions(false)
            .withPush(false)
            .withViewportMargin(0)
            .withLockedPosition(lockAlignment);
        // Unless the alignment is forced, add fallbacks based on the preferred positions
        if (!forceAlignment) {
            /** @type {?} */
            const fallbacks = this._getFallbacks(horizontalTarget, verticalTarget);
            positions.push(...fallbacks);
        }
        return strategy.withPositions(positions);
    }
    /**
     * Get fallback positions based around target alignments.
     * @private
     * @param {?} hTarget
     * @param {?} vTarget
     * @return {?}
     */
    _getFallbacks(hTarget, vTarget) {
        // Determine if the target alignments overlap the anchor
        /** @type {?} */
        const horizontalOverlapAllowed = hTarget !== 'before' && hTarget !== 'after';
        /** @type {?} */
        const verticalOverlapAllowed = vTarget !== 'above' && vTarget !== 'below';
        // If a target alignment doesn't cover the anchor, don't let any of the fallback alignments
        // cover the anchor
        /** @type {?} */
        const possibleHorizontalAlignments = horizontalOverlapAllowed ?
            ['before', 'start', 'center', 'end', 'after'] :
            ['before', 'after'];
        /** @type {?} */
        const possibleVerticalAlignments = verticalOverlapAllowed ?
            ['above', 'start', 'center', 'end', 'below'] :
            ['above', 'below'];
        // Create fallbacks for each allowed prioritized fallback alignment combo
        /** @type {?} */
        const fallbacks = [];
        prioritizeAroundTarget(hTarget, possibleHorizontalAlignments).forEach((/**
         * @param {?} h
         * @return {?}
         */
        h => {
            prioritizeAroundTarget(vTarget, possibleVerticalAlignments).forEach((/**
             * @param {?} v
             * @return {?}
             */
            v => {
                fallbacks.push(getPosition(h, v));
            }));
        }));
        // Remove the first item since it will be the target alignment and isn't considered a fallback
        return fallbacks.slice(1, fallbacks.length);
    }
}
SatPopoverAnchoringService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
SatPopoverAnchoringService.ctorParameters = () => [
    { type: Overlay },
    { type: NgZone },
    { type: Directionality, decorators: [{ type: Optional }] }
];
if (false) {
    /**
     * Emits when the popover is opened.
     * @type {?}
     */
    SatPopoverAnchoringService.prototype.popoverOpened;
    /**
     * Emits when the popover is closed.
     * @type {?}
     */
    SatPopoverAnchoringService.prototype.popoverClosed;
    /**
     * Reference to the overlay containing the popover component.
     * @type {?}
     */
    SatPopoverAnchoringService.prototype._overlayRef;
    /**
     * Reference to the target popover.
     * @type {?}
     * @private
     */
    SatPopoverAnchoringService.prototype._popover;
    /**
     * Reference to the view container for the popover template.
     * @type {?}
     * @private
     */
    SatPopoverAnchoringService.prototype._viewContainerRef;
    /**
     * Reference to the anchor element.
     * @type {?}
     * @private
     */
    SatPopoverAnchoringService.prototype._anchor;
    /**
     * Reference to a template portal where the overlay will be attached.
     * @type {?}
     * @private
     */
    SatPopoverAnchoringService.prototype._portal;
    /**
     * Single subscription to notifications service events.
     * @type {?}
     * @private
     */
    SatPopoverAnchoringService.prototype._notificationsSubscription;
    /**
     * Single subscription to position changes.
     * @type {?}
     * @private
     */
    SatPopoverAnchoringService.prototype._positionChangeSubscription;
    /**
     * Whether the popover is presently open.
     * @type {?}
     * @private
     */
    SatPopoverAnchoringService.prototype._popoverOpen;
    /**
     * Emits when the service is destroyed.
     * @type {?}
     * @private
     */
    SatPopoverAnchoringService.prototype._onDestroy;
    /**
     * @type {?}
     * @private
     */
    SatPopoverAnchoringService.prototype._overlay;
    /**
     * @type {?}
     * @private
     */
    SatPopoverAnchoringService.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    SatPopoverAnchoringService.prototype._dir;
}
/**
 * Helper function to get a cdk position pair from SatPopover alignments.
 * @param {?} h
 * @param {?} v
 * @return {?}
 */
function getPosition(h, v) {
    const { originX, overlayX } = getHorizontalConnectionPosPair(h);
    const { originY, overlayY } = getVerticalConnectionPosPair(v);
    return new ConnectionPositionPair({ originX, originY }, { overlayX, overlayY });
}
/**
 * Helper function to convert an overlay connection position to equivalent popover alignment.
 * @param {?} h
 * @return {?}
 */
function getHorizontalPopoverAlignment(h) {
    if (h === 'start') {
        return 'after';
    }
    if (h === 'end') {
        return 'before';
    }
    return 'center';
}
/**
 * Helper function to convert an overlay connection position to equivalent popover alignment.
 * @param {?} v
 * @return {?}
 */
function getVerticalPopoverAlignment(v) {
    if (v === 'top') {
        return 'below';
    }
    if (v === 'bottom') {
        return 'above';
    }
    return 'center';
}
/**
 * Helper function to convert alignment to origin/overlay position pair.
 * @param {?} h
 * @return {?}
 */
function getHorizontalConnectionPosPair(h) {
    switch (h) {
        case 'before':
            return { originX: 'start', overlayX: 'end' };
        case 'start':
            return { originX: 'start', overlayX: 'start' };
        case 'end':
            return { originX: 'end', overlayX: 'end' };
        case 'after':
            return { originX: 'end', overlayX: 'start' };
        default:
            return { originX: 'center', overlayX: 'center' };
    }
}
/**
 * Helper function to convert alignment to origin/overlay position pair.
 * @param {?} v
 * @return {?}
 */
function getVerticalConnectionPosPair(v) {
    switch (v) {
        case 'above':
            return { originY: 'top', overlayY: 'bottom' };
        case 'start':
            return { originY: 'top', overlayY: 'top' };
        case 'end':
            return { originY: 'bottom', overlayY: 'bottom' };
        case 'below':
            return { originY: 'bottom', overlayY: 'top' };
        default:
            return { originY: 'center', overlayY: 'center' };
    }
}
/**
 * Helper function that takes an ordered array options and returns a reorderded
 * array around the target item. e.g.:
 *
 * target: 3; options: [1, 2, 3, 4, 5, 6, 7];
 *
 * return: [3, 4, 2, 5, 1, 6, 7]
 * @template T
 * @param {?} target
 * @param {?} options
 * @return {?}
 */
function prioritizeAroundTarget(target, options) {
    /** @type {?} */
    const targetIndex = options.indexOf(target);
    // Set the first item to be the target
    /** @type {?} */
    const reordered = [target];
    // Make left and right stacks where the highest priority item is last
    /** @type {?} */
    const left = options.slice(0, targetIndex);
    /** @type {?} */
    const right = options.slice(targetIndex + 1, options.length).reverse();
    // Alternate between stacks until one is empty
    while (left.length && right.length) {
        reordered.push(right.pop());
        reordered.push(left.pop());
    }
    // Flush out right side
    while (right.length) {
        reordered.push(right.pop());
    }
    // Flush out left side
    while (left.length) {
        reordered.push(left.pop());
    }
    return reordered;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci1hbmNob3Jpbmcuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuY3N0YXRlL3NhdC1wb3BvdmVyLyIsInNvdXJjZXMiOlsicG9wb3Zlci9wb3BvdmVyLWFuY2hvcmluZy5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQ0wsVUFBVSxFQUNWLFVBQVUsRUFDVixNQUFNLEVBRU4sUUFBUSxFQUVULE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFDTCxzQkFBc0IsRUFHdEIsT0FBTyxFQUNQLGFBQWEsR0FJZCxNQUFNLHNCQUFzQixDQUFDO0FBQzlCLE9BQU8sRUFBRSxjQUFjLEVBQVksTUFBTSxtQkFBbUIsQ0FBQztBQUM3RCxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDL0MsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3JELE9BQU8sRUFBZ0IsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzdDLE9BQU8sRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7Ozs7O0FBYzlELDRCQVFDOzs7SUFQQyx3Q0FBMkM7O0lBQzNDLHNDQUF1Qzs7SUFDdkMsb0NBQXFCOztJQUNyQixzQ0FBc0I7O0lBQ3RCLHVDQUF5Qzs7SUFDekMsdUNBQXdCOztJQUN4QixzQ0FBdUI7O0FBSXpCLE1BQU0sT0FBTywwQkFBMEI7Ozs7OztJQW1DckMsWUFDVSxRQUFpQixFQUNqQixPQUFlLEVBQ0gsSUFBb0I7UUFGaEMsYUFBUSxHQUFSLFFBQVEsQ0FBUztRQUNqQixZQUFPLEdBQVAsT0FBTyxDQUFRO1FBQ0gsU0FBSSxHQUFKLElBQUksQ0FBZ0I7Ozs7UUFuQzFDLGtCQUFhLEdBQUcsSUFBSSxPQUFPLEVBQVEsQ0FBQzs7OztRQUdwQyxrQkFBYSxHQUFHLElBQUksT0FBTyxFQUFRLENBQUM7Ozs7UUF3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Q0FBQyxLQUFLLENBQUMsV0FBVyxHQUFHLENBQUMsRUFBRSxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxFQUFFO0lBRXRFLDhDQUE4QztJQUM5QyxPQUFPLElBQUksQ0FBQyxNQUFNLElBQUksS0FBSyxDQUFDLE1BQU0sRUFBRTtRQUNsQyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBQzVCLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7S0FDNUI7SUFFRCx1QkFBdUI7SUFDdkIsT0FBTyxLQUFLLENBQUMsTUFBTSxFQUFFO1FBQ25CLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7S0FDN0I7SUFFRCxzQkFBc0I7SUFDdEIsT0FBTyxJQUFJLENBQUMsTUFBTSxFQUFFO1FBQ2xCLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7S0FDNUI7SUFFRCxPQUFPLFNBQVMsQ0FBQztBQUNuQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgRWxlbWVudFJlZixcbiAgSW5qZWN0YWJsZSxcbiAgTmdab25lLFxuICBPbkRlc3Ryb3ksXG4gIE9wdGlvbmFsLFxuICBWaWV3Q29udGFpbmVyUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgQ29ubmVjdGlvblBvc2l0aW9uUGFpcixcbiAgRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LFxuICBIb3Jpem9udGFsQ29ubmVjdGlvblBvcyxcbiAgT3ZlcmxheSxcbiAgT3ZlcmxheUNvbmZpZyxcbiAgT3ZlcmxheVJlZixcbiAgU2Nyb2xsU3RyYXRlZ3ksXG4gIFZlcnRpY2FsQ29ubmVjdGlvblBvcyxcbn0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHsgRGlyZWN0aW9uYWxpdHksIERpcmVjdGlvbn0gZnJvbSAnQGFuZ3VsYXIvY2RrL2JpZGknO1xuaW1wb3J0IHsgRVNDQVBFIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcbmltcG9ydCB7IFRlbXBsYXRlUG9ydGFsIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BvcnRhbCc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24sIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCwgdGFrZSwgZmlsdGVyLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IFNhdFBvcG92ZXIgfSBmcm9tICcuL3BvcG92ZXIuY29tcG9uZW50JztcbmltcG9ydCB7XG4gIFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ24sXG4gIFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduLFxuICBTYXRQb3BvdmVyU2Nyb2xsU3RyYXRlZ3ksXG4gIFNhdFBvcG92ZXJPcGVuT3B0aW9ucyxcbn0gZnJvbSAnLi90eXBlcyc7XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBwcm92aWRlZCBieSB0aGUgcG9wb3ZlciBmb3IgdGhlIGFuY2hvcmluZyBzZXJ2aWNlXG4gKiB0byBidWlsZCB0aGUgY29ycmVjdCBvdmVybGF5IGNvbmZpZy5cbiAqL1xuaW50ZXJmYWNlIFBvcG92ZXJDb25maWcge1xuICBob3Jpem9udGFsQWxpZ246IFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ247XG4gIHZlcnRpY2FsQWxpZ246IFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduO1xuICBoYXNCYWNrZHJvcDogYm9vbGVhbjtcbiAgYmFja2Ryb3BDbGFzczogc3RyaW5nO1xuICBzY3JvbGxTdHJhdGVneTogU2F0UG9wb3ZlclNjcm9sbFN0cmF0ZWd5O1xuICBmb3JjZUFsaWdubWVudDogYm9vbGVhbjtcbiAgbG9ja0FsaWdubWVudDogYm9vbGVhbjtcbn1cblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNhdFBvcG92ZXJBbmNob3JpbmdTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgcG9wb3ZlciBpcyBvcGVuZWQuICovXG4gIHBvcG92ZXJPcGVuZWQgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSBwb3BvdmVyIGlzIGNsb3NlZC4gKi9cbiAgcG9wb3ZlckNsb3NlZCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgb3ZlcmxheSBjb250YWluaW5nIHRoZSBwb3BvdmVyIGNvbXBvbmVudC4gKi9cbiAgX292ZXJsYXlSZWY6IE92ZXJsYXlSZWY7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgdGFyZ2V0IHBvcG92ZXIuICovXG4gIHByaXZhdGUgX3BvcG92ZXI6IFNhdFBvcG92ZXI7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgdmlldyBjb250YWluZXIgZm9yIHRoZSBwb3BvdmVyIHRlbXBsYXRlLiAqL1xuICBwcml2YXRlIF92aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmO1xuXG4gIC8qKiBSZWZlcmVuY2UgdG8gdGhlIGFuY2hvciBlbGVtZW50LiAqL1xuICBwcml2YXRlIF9hbmNob3I6IEhUTUxFbGVtZW50O1xuXG4gIC8qKiBSZWZlcmVuY2UgdG8gYSB0ZW1wbGF0ZSBwb3J0YWwgd2hlcmUgdGhlIG92ZXJsYXkgd2lsbCBiZSBhdHRhY2hlZC4gKi9cbiAgcHJpdmF0ZSBfcG9ydGFsOiBUZW1wbGF0ZVBvcnRhbDxhbnk+O1xuXG4gIC8qKiBTaW5nbGUgc3Vic2NyaXB0aW9uIHRvIG5vdGlmaWNhdGlvbnMgc2VydmljZSBldmVudHMuICovXG4gIHByaXZhdGUgX25vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAvKiogU2luZ2xlIHN1YnNjcmlwdGlvbiB0byBwb3NpdGlvbiBjaGFuZ2VzLiAqL1xuICBwcml2YXRlIF9wb3NpdGlvbkNoYW5nZVN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIGlzIHByZXNlbnRseSBvcGVuLiAqL1xuICBwcml2YXRlIF9wb3BvdmVyT3BlbiA9IGZhbHNlO1xuXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSBzZXJ2aWNlIGlzIGRlc3Ryb3llZC4gKi9cbiAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9vdmVybGF5OiBPdmVybGF5LFxuICAgIHByaXZhdGUgX25nWm9uZTogTmdab25lLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX2RpcjogRGlyZWN0aW9uYWxpdHlcbiAgKSB7IH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICAvLyBEZXN0cm95IHBvcG92ZXIgYmVmb3JlIHRlcm1pbmF0aW5nIHN1YnNjcmlwdGlvbnMgc28gdGhhdCBhbnkgcmVzdWx0aW5nXG4gICAgLy8gZGV0YWNobWVudHMgdXBkYXRlICdjbG9zZWQgc3RhdGUnXG4gICAgdGhpcy5fZGVzdHJveVBvcG92ZXIoKTtcblxuICAgIC8vIFRlcm1pbmF0ZSBzdWJzY3JpcHRpb25zXG4gICAgaWYgKHRoaXMuX25vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuX25vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3Bvc2l0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLl9wb3NpdGlvbkNoYW5nZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgIHRoaXMuX29uRGVzdHJveS5jb21wbGV0ZSgpO1xuXG4gICAgdGhpcy5wb3BvdmVyT3BlbmVkLmNvbXBsZXRlKCk7XG4gICAgdGhpcy5wb3BvdmVyQ2xvc2VkLmNvbXBsZXRlKCk7XG4gIH1cblxuICAvKiogQW5jaG9yIGEgcG9wb3ZlciBpbnN0YW5jZSB0byBhIHZpZXcgYW5kIGNvbm5lY3Rpb24gZWxlbWVudC4gKi9cbiAgYW5jaG9yKFxuICAgIHBvcG92ZXI6IFNhdFBvcG92ZXIsXG4gICAgdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZixcbiAgICBhbmNob3I6IEVsZW1lbnRSZWYgfCBIVE1MRWxlbWVudFxuICApOiB2b2lkIHtcbiAgICAvLyBJZiB3ZSdyZSBqdXN0IGNoYW5naW5nIHRoZSBhbmNob3IgZWxlbWVudCBhbmQgdGhlIG92ZXJsYXlSZWYgYWxyZWFkeSBleGlzdHMsXG4gICAgLy8gc2ltcGx5IHVwZGF0ZSB0aGUgZXhpc3RpbmcgX292ZXJsYXlSZWYncyBhbmNob3IuXG4gICAgaWYgKFxuICAgICAgdGhpcy5fcG9wb3ZlciA9PT0gcG9wb3ZlciAmJlxuICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZiA9PT0gdmlld0NvbnRhaW5lclJlZiAmJlxuICAgICAgdGhpcy5fb3ZlcmxheVJlZlxuICAgICkge1xuICAgICAgdGhpcy5fYW5jaG9yID0gYW5jaG9yIGluc3RhbmNlb2YgRWxlbWVudFJlZlxuICAgICAgICA/IGFuY2hvci5uYXRpdmVFbGVtZW50XG4gICAgICAgIDogYW5jaG9yO1xuICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5fb3ZlcmxheVJlZi5nZXRDb25maWcoKTtcbiAgICAgIGNvbnN0IHN0cmF0ZWd5ID0gY29uZmlnLnBvc2l0aW9uU3RyYXRlZ3kgYXMgRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5O1xuICAgICAgc3RyYXRlZ3kuc2V0T3JpZ2luKHRoaXMuX2FuY2hvcik7XG4gICAgICB0aGlzLl9vdmVybGF5UmVmLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRGVzdHJveSBhbnkgcHJldmlvdXMgcG9wb3ZlcnNcbiAgICB0aGlzLl9kZXN0cm95UG9wb3ZlcigpO1xuXG4gICAgLy8gQXNzaWduIGxvY2FsIHJlZnNcbiAgICB0aGlzLl9wb3BvdmVyID0gcG9wb3ZlcjtcbiAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmID0gdmlld0NvbnRhaW5lclJlZjtcbiAgICB0aGlzLl9hbmNob3IgPSBhbmNob3IgaW5zdGFuY2VvZiBFbGVtZW50UmVmXG4gICAgICA/IGFuY2hvci5uYXRpdmVFbGVtZW50XG4gICAgICA6IGFuY2hvcjtcbiAgfVxuXG4gIC8qKiBHZXRzIHdoZXRoZXIgdGhlIHBvcG92ZXIgaXMgcHJlc2VudGx5IG9wZW4uICovXG4gIGlzUG9wb3Zlck9wZW4oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3BvcG92ZXJPcGVuO1xuICB9XG5cbiAgLyoqIFRvZ2dsZXMgdGhlIHBvcG92ZXIgYmV0d2VlbiB0aGUgb3BlbiBhbmQgY2xvc2VkIHN0YXRlcy4gKi9cbiAgdG9nZ2xlUG9wb3ZlcigpOiB2b2lkIHtcbiAgICByZXR1cm4gdGhpcy5fcG9wb3Zlck9wZW4gPyB0aGlzLmNsb3NlUG9wb3ZlcigpIDogdGhpcy5vcGVuUG9wb3ZlcigpO1xuICB9XG5cbiAgLyoqIE9wZW5zIHRoZSBwb3BvdmVyLiAqL1xuICBvcGVuUG9wb3ZlcihvcHRpb25zOiBTYXRQb3BvdmVyT3Blbk9wdGlvbnMgPSB7fSk6IHZvaWQge1xuICAgIGlmICghdGhpcy5fcG9wb3Zlck9wZW4pIHtcbiAgICAgIHRoaXMuX2FwcGx5T3Blbk9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB0aGlzLl9jcmVhdGVPdmVybGF5KCk7XG4gICAgICB0aGlzLl9zdWJzY3JpYmVUb0JhY2tkcm9wKCk7XG4gICAgICB0aGlzLl9zdWJzY3JpYmVUb0VzY2FwZSgpO1xuICAgICAgdGhpcy5fc3Vic2NyaWJlVG9EZXRhY2htZW50cygpO1xuICAgICAgdGhpcy5fc2F2ZU9wZW5lZFN0YXRlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIENsb3NlcyB0aGUgcG9wb3Zlci4gKi9cbiAgY2xvc2VQb3BvdmVyKHZhbHVlPzogYW55KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgIHRoaXMuX3NhdmVDbG9zZWRTdGF0ZSh2YWx1ZSk7XG4gICAgICB0aGlzLl9vdmVybGF5UmVmLmRldGFjaCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBUT0RPOiBpbXBsZW1lbnQgd2hlbiB0aGUgb3ZlcmxheSdzIHBvc2l0aW9uIGNhbiBiZSBkeW5hbWljYWxseSBjaGFuZ2VkICovXG4gIHJlcG9zaXRpb25Qb3BvdmVyKCk6IHZvaWQge1xuICAgIHRoaXMudXBkYXRlUG9wb3ZlckNvbmZpZygpO1xuICB9XG5cbiAgLyoqIFRPRE86IHdoZW4gdGhlIG92ZXJsYXkncyBwb3NpdGlvbiBjYW4gYmUgZHluYW1pY2FsbHkgY2hhbmdlZCwgZG8gbm90IGRlc3Ryb3kgKi9cbiAgdXBkYXRlUG9wb3ZlckNvbmZpZygpOiB2b2lkIHtcbiAgICB0aGlzLl9kZXN0cm95UG9wb3Zlck9uY2VDbG9zZWQoKTtcbiAgfVxuXG4gIC8qKiBSZWFsaWduIHRoZSBwb3BvdmVyIHRvIHRoZSBhbmNob3IuICovXG4gIHJlYWxpZ25Qb3BvdmVyVG9BbmNob3IoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuX292ZXJsYXlSZWYuZ2V0Q29uZmlnKCk7XG4gICAgICBjb25zdCBzdHJhdGVneSA9IGNvbmZpZy5wb3NpdGlvblN0cmF0ZWd5IGFzIEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneTtcbiAgICAgIHN0cmF0ZWd5LnJlYXBwbHlMYXN0UG9zaXRpb24oKTtcbiAgICB9XG4gIH1cblxuICAvKiogR2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBhbmNob3IgZWxlbWVudC4gKi9cbiAgZ2V0QW5jaG9yRWxlbWVudCgpOiBIVE1MRWxlbWVudCB7XG4gICAgcmV0dXJuIHRoaXMuX2FuY2hvcjtcbiAgfVxuXG4gIC8qKiBBcHBseSBiZWhhdmlvciBwcm9wZXJ0aWVzIG9uIHRoZSBwb3BvdmVyIGJhc2VkIG9uIHRoZSBvcGVuIG9wdGlvbnMuICovXG4gIHByaXZhdGUgX2FwcGx5T3Blbk9wdGlvbnMob3B0aW9uczogU2F0UG9wb3Zlck9wZW5PcHRpb25zKTogdm9pZCB7XG4gICAgLy8gT25seSBvdmVycmlkZSByZXN0b3JlRm9jdXMgYXMgYGZhbHNlYCBpZiB0aGUgb3B0aW9uIGlzIGV4cGxpY2l0bHkgYGZhbHNlYFxuICAgIGNvbnN0IHJlc3RvcmVGb2N1cyA9IG9wdGlvbnMucmVzdG9yZUZvY3VzICE9PSBmYWxzZTtcbiAgICB0aGlzLl9wb3BvdmVyLl9yZXN0b3JlRm9jdXNPdmVycmlkZSA9IHJlc3RvcmVGb2N1cztcblxuICAgIC8vIE9ubHkgb3ZlcnJpZGUgYXV0b0ZvY3VzIGFzIGBmYWxzZWAgaWYgdGhlIG9wdGlvbiBpcyBleHBsaWNpdGx5IGBmYWxzZWBcbiAgICBjb25zdCBhdXRvRm9jdXMgPSBvcHRpb25zLmF1dG9Gb2N1cyAhPT0gZmFsc2U7XG4gICAgdGhpcy5fcG9wb3Zlci5fYXV0b0ZvY3VzT3ZlcnJpZGUgPSBhdXRvRm9jdXM7XG4gIH1cblxuICAvKiogQ3JlYXRlIGFuIG92ZXJsYXkgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIHBvcnRhbC4gKi9cbiAgcHJpdmF0ZSBfY3JlYXRlT3ZlcmxheSgpOiBPdmVybGF5UmVmIHtcbiAgICAvLyBDcmVhdGUgb3ZlcmxheSBpZiBpdCBkb2Vzbid0IHlldCBleGlzdFxuICAgIGlmICghdGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgdGhpcy5fcG9ydGFsID0gbmV3IFRlbXBsYXRlUG9ydGFsKHRoaXMuX3BvcG92ZXIuX3RlbXBsYXRlUmVmLCB0aGlzLl92aWV3Q29udGFpbmVyUmVmKTtcblxuICAgICAgY29uc3QgcG9wb3ZlckNvbmZpZyA9IHtcbiAgICAgICAgaG9yaXpvbnRhbEFsaWduOiB0aGlzLl9wb3BvdmVyLmhvcml6b250YWxBbGlnbixcbiAgICAgICAgdmVydGljYWxBbGlnbjogdGhpcy5fcG9wb3Zlci52ZXJ0aWNhbEFsaWduLFxuICAgICAgICBoYXNCYWNrZHJvcDogdGhpcy5fcG9wb3Zlci5oYXNCYWNrZHJvcCxcbiAgICAgICAgYmFja2Ryb3BDbGFzczogdGhpcy5fcG9wb3Zlci5iYWNrZHJvcENsYXNzLFxuICAgICAgICBzY3JvbGxTdHJhdGVneTogdGhpcy5fcG9wb3Zlci5zY3JvbGxTdHJhdGVneSxcbiAgICAgICAgZm9yY2VBbGlnbm1lbnQ6IHRoaXMuX3BvcG92ZXIuZm9yY2VBbGlnbm1lbnQsXG4gICAgICAgIGxvY2tBbGlnbm1lbnQ6IHRoaXMuX3BvcG92ZXIubG9ja0FsaWdubWVudCxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG92ZXJsYXlDb25maWcgPSB0aGlzLl9nZXRPdmVybGF5Q29uZmlnKHBvcG92ZXJDb25maWcsIHRoaXMuX2FuY2hvcik7XG5cbiAgICAgIHRoaXMuX3N1YnNjcmliZVRvUG9zaXRpb25DaGFuZ2VzKFxuICAgICAgICBvdmVybGF5Q29uZmlnLnBvc2l0aW9uU3RyYXRlZ3kgYXMgRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5XG4gICAgICApO1xuXG4gICAgICB0aGlzLl9vdmVybGF5UmVmID0gdGhpcy5fb3ZlcmxheS5jcmVhdGUob3ZlcmxheUNvbmZpZyk7XG4gICAgfVxuXG4gICAgLy8gQWN0dWFsbHkgb3BlbiB0aGUgcG9wb3ZlclxuICAgIHRoaXMuX292ZXJsYXlSZWYuYXR0YWNoKHRoaXMuX3BvcnRhbCk7XG4gICAgcmV0dXJuIHRoaXMuX292ZXJsYXlSZWY7XG4gIH1cblxuXG4gIC8qKiBSZW1vdmVzIHRoZSBwb3BvdmVyIGZyb20gdGhlIERPTS4gRG9lcyBOT1QgdXBkYXRlIG9wZW4gc3RhdGUuICovXG4gIHByaXZhdGUgX2Rlc3Ryb3lQb3BvdmVyKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICB0aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgcG9wb3ZlciBpbW1lZGlhdGVseSBpZiBpdCBpcyBjbG9zZWQsIG9yIHdhaXRzIHVudGlsIGl0XG4gICAqIGhhcyBiZWVuIGNsb3NlZCB0byBkZXN0cm95IGl0LlxuICAgKi9cbiAgcHJpdmF0ZSBfZGVzdHJveVBvcG92ZXJPbmNlQ2xvc2VkKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzUG9wb3Zlck9wZW4oKSAmJiB0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICB0aGlzLl9vdmVybGF5UmVmLmRldGFjaG1lbnRzKCkucGlwZShcbiAgICAgICAgdGFrZSgxKSxcbiAgICAgICAgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSlcbiAgICAgICkuc3Vic2NyaWJlKCgpID0+IHRoaXMuX2Rlc3Ryb3lQb3BvdmVyKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kZXN0cm95UG9wb3ZlcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBDbG9zZSBwb3BvdmVyIHdoZW4gYmFja2Ryb3AgaXMgY2xpY2tlZC4gKi9cbiAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9CYWNrZHJvcCgpOiB2b2lkIHtcbiAgICB0aGlzLl9vdmVybGF5UmVmXG4gICAgICAuYmFja2Ryb3BDbGljaygpXG4gICAgICAucGlwZShcbiAgICAgICAgdGFwKCgpID0+IHRoaXMuX3BvcG92ZXIuYmFja2Ryb3BDbGlja2VkLmVtaXQoKSksXG4gICAgICAgIGZpbHRlcigoKSA9PiB0aGlzLl9wb3BvdmVyLmludGVyYWN0aXZlQ2xvc2UpLFxuICAgICAgICB0YWtlVW50aWwodGhpcy5wb3BvdmVyQ2xvc2VkKSxcbiAgICAgICAgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSksXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuY2xvc2VQb3BvdmVyKCkpO1xuICB9XG5cbiAgLyoqIENsb3NlIHBvcG92ZXIgd2hlbiBlc2NhcGUga2V5ZG93biBldmVudCBvY2N1cnMuICovXG4gIHByaXZhdGUgX3N1YnNjcmliZVRvRXNjYXBlKCk6IHZvaWQge1xuICAgIHRoaXMuX292ZXJsYXlSZWZcbiAgICAgIC5rZXlkb3duRXZlbnRzKClcbiAgICAgIC5waXBlKFxuICAgICAgICB0YXAoZXZlbnQgPT4gdGhpcy5fcG9wb3Zlci5vdmVybGF5S2V5ZG93bi5lbWl0KGV2ZW50KSksXG4gICAgICAgIGZpbHRlcihldmVudCA9PiBldmVudC5rZXlDb2RlID09PSBFU0NBUEUpLFxuICAgICAgICBmaWx0ZXIoKCkgPT4gdGhpcy5fcG9wb3Zlci5pbnRlcmFjdGl2ZUNsb3NlKSxcbiAgICAgICAgdGFrZVVudGlsKHRoaXMucG9wb3ZlckNsb3NlZCksXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpLFxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNsb3NlUG9wb3ZlcigpKTtcbiAgfVxuXG4gIC8qKiBTZXQgc3RhdGUgYmFjayB0byBjbG9zZWQgd2hlbiBkZXRhY2hlZC4gKi9cbiAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9EZXRhY2htZW50cygpOiB2b2lkIHtcbiAgICB0aGlzLl9vdmVybGF5UmVmXG4gICAgICAuZGV0YWNobWVudHMoKVxuICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuX3NhdmVDbG9zZWRTdGF0ZSgpKTtcbiAgfVxuXG4gIC8qKiBTYXZlIHRoZSBvcGVuZWQgc3RhdGUgb2YgdGhlIHBvcG92ZXIgYW5kIGVtaXQuICovXG4gIHByaXZhdGUgX3NhdmVPcGVuZWRTdGF0ZSgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuX3BvcG92ZXJPcGVuKSB7XG4gICAgICB0aGlzLl9wb3BvdmVyLl9vcGVuID0gdGhpcy5fcG9wb3Zlck9wZW4gPSB0cnVlO1xuXG4gICAgICB0aGlzLnBvcG92ZXJPcGVuZWQubmV4dCgpO1xuICAgICAgdGhpcy5fcG9wb3Zlci5vcGVuZWQuZW1pdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBTYXZlIHRoZSBjbG9zZWQgc3RhdGUgb2YgdGhlIHBvcG92ZXIgYW5kIGVtaXQuICovXG4gIHByaXZhdGUgX3NhdmVDbG9zZWRTdGF0ZSh2YWx1ZT86IGFueSk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9wb3BvdmVyT3Blbikge1xuICAgICAgdGhpcy5fcG9wb3Zlci5fb3BlbiA9IHRoaXMuX3BvcG92ZXJPcGVuID0gZmFsc2U7XG5cbiAgICAgIHRoaXMucG9wb3ZlckNsb3NlZC5uZXh0KHZhbHVlKTtcbiAgICAgIHRoaXMuX3BvcG92ZXIuY2xvc2VkLmVtaXQodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBHZXRzIHRoZSB0ZXh0IGRpcmVjdGlvbiBvZiB0aGUgY29udGFpbmluZyBhcHAuICovXG4gIHByaXZhdGUgX2dldERpcmVjdGlvbigpOiBEaXJlY3Rpb24ge1xuICAgIHJldHVybiB0aGlzLl9kaXIgJiYgdGhpcy5fZGlyLnZhbHVlID09PSAncnRsJyA/ICdydGwnIDogJ2x0cic7XG4gIH1cblxuICAvKiogQ3JlYXRlIGFuZCByZXR1cm4gYSBjb25maWcgZm9yIGNyZWF0aW5nIHRoZSBvdmVybGF5LiAqL1xuICBwcml2YXRlIF9nZXRPdmVybGF5Q29uZmlnKGNvbmZpZzogUG9wb3ZlckNvbmZpZywgYW5jaG9yOiBIVE1MRWxlbWVudCk6IE92ZXJsYXlDb25maWcge1xuICAgIHJldHVybiBuZXcgT3ZlcmxheUNvbmZpZyh7XG4gICAgICBwb3NpdGlvblN0cmF0ZWd5OiB0aGlzLl9nZXRQb3NpdGlvblN0cmF0ZWd5KFxuICAgICAgICBjb25maWcuaG9yaXpvbnRhbEFsaWduLFxuICAgICAgICBjb25maWcudmVydGljYWxBbGlnbixcbiAgICAgICAgY29uZmlnLmZvcmNlQWxpZ25tZW50LFxuICAgICAgICBjb25maWcubG9ja0FsaWdubWVudCxcbiAgICAgICAgYW5jaG9yLFxuICAgICAgKSxcbiAgICAgIGhhc0JhY2tkcm9wOiBjb25maWcuaGFzQmFja2Ryb3AsXG4gICAgICBiYWNrZHJvcENsYXNzOiBjb25maWcuYmFja2Ryb3BDbGFzcyB8fCAnY2RrLW92ZXJsYXktdHJhbnNwYXJlbnQtYmFja2Ryb3AnLFxuICAgICAgc2Nyb2xsU3RyYXRlZ3k6IHRoaXMuX2dldFNjcm9sbFN0cmF0ZWd5SW5zdGFuY2UoY29uZmlnLnNjcm9sbFN0cmF0ZWd5KSxcbiAgICAgIGRpcmVjdGlvbjogdGhpcy5fZ2V0RGlyZWN0aW9uKCksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdGVuIHRvIGNoYW5nZXMgaW4gdGhlIHBvc2l0aW9uIG9mIHRoZSBvdmVybGF5IGFuZCBzZXQgdGhlIGNvcnJlY3QgYWxpZ25tZW50IGNsYXNzZXMsXG4gICAqIGVuc3VyaW5nIHRoYXQgdGhlIGFuaW1hdGlvbiBvcmlnaW4gaXMgY29ycmVjdCwgZXZlbiB3aXRoIGEgZmFsbGJhY2sgcG9zaXRpb24uXG4gICAqL1xuICBwcml2YXRlIF9zdWJzY3JpYmVUb1Bvc2l0aW9uQ2hhbmdlcyhwb3NpdGlvbjogRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX3Bvc2l0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLl9wb3NpdGlvbkNoYW5nZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3Bvc2l0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uID0gcG9zaXRpb24ucG9zaXRpb25DaGFuZ2VzXG4gICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSlcbiAgICAgIC5zdWJzY3JpYmUoY2hhbmdlID0+IHtcbiAgICAgICAgLy8gUG9zaXRpb24gY2hhbmdlcyBtYXkgb2NjdXIgb3V0c2lkZSB0aGUgQW5ndWxhciB6b25lXG4gICAgICAgIHRoaXMuX25nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX3BvcG92ZXIuX3NldEFsaWdubWVudENsYXNzZXMoXG4gICAgICAgICAgICBnZXRIb3Jpem9udGFsUG9wb3ZlckFsaWdubWVudChjaGFuZ2UuY29ubmVjdGlvblBhaXIub3ZlcmxheVgpLFxuICAgICAgICAgICAgZ2V0VmVydGljYWxQb3BvdmVyQWxpZ25tZW50KGNoYW5nZS5jb25uZWN0aW9uUGFpci5vdmVybGF5WSksXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKiBNYXAgYSBzY3JvbGwgc3RyYXRlZ3kgc3RyaW5nIHR5cGUgdG8gYW4gaW5zdGFuY2Ugb2YgYSBzY3JvbGwgc3RyYXRlZ3kuICovXG4gIHByaXZhdGUgX2dldFNjcm9sbFN0cmF0ZWd5SW5zdGFuY2Uoc3RyYXRlZ3k6IFNhdFBvcG92ZXJTY3JvbGxTdHJhdGVneSk6IFNjcm9sbFN0cmF0ZWd5IHtcbiAgICBzd2l0Y2ggKHN0cmF0ZWd5KSB7XG4gICAgICBjYXNlICdibG9jayc6XG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMuYmxvY2soKTtcbiAgICAgIGNhc2UgJ3JlcG9zaXRpb24nOlxuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLnJlcG9zaXRpb24oKTtcbiAgICAgIGNhc2UgJ2Nsb3NlJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5jbG9zZSgpO1xuICAgICAgY2FzZSAnbm9vcCc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLm5vb3AoKTtcbiAgICB9XG4gIH1cblxuICAvKiogQ3JlYXRlIGFuZCByZXR1cm4gYSBwb3NpdGlvbiBzdHJhdGVneSBiYXNlZCBvbiBjb25maWcgcHJvdmlkZWQgdG8gdGhlIGNvbXBvbmVudCBpbnN0YW5jZS4gKi9cbiAgcHJpdmF0ZSBfZ2V0UG9zaXRpb25TdHJhdGVneShcbiAgICBob3Jpem9udGFsVGFyZ2V0OiBTYXRQb3BvdmVySG9yaXpvbnRhbEFsaWduLFxuICAgIHZlcnRpY2FsVGFyZ2V0OiBTYXRQb3BvdmVyVmVydGljYWxBbGlnbixcbiAgICBmb3JjZUFsaWdubWVudDogYm9vbGVhbixcbiAgICBsb2NrQWxpZ25tZW50OiBib29sZWFuLFxuICAgIGFuY2hvcjogSFRNTEVsZW1lbnQsXG4gICk6IEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSB7XG4gICAgLy8gQXR0YWNoIHRoZSBvdmVybGF5IGF0IHRoZSBwcmVmZXJyZWQgcG9zaXRpb25cbiAgICBjb25zdCB0YXJnZXRQb3NpdGlvbiA9IGdldFBvc2l0aW9uKGhvcml6b250YWxUYXJnZXQsIHZlcnRpY2FsVGFyZ2V0KTtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBbdGFyZ2V0UG9zaXRpb25dO1xuXG4gICAgY29uc3Qgc3RyYXRlZ3kgPSB0aGlzLl9vdmVybGF5LnBvc2l0aW9uKClcbiAgICAgIC5mbGV4aWJsZUNvbm5lY3RlZFRvKGFuY2hvcilcbiAgICAgIC53aXRoRmxleGlibGVEaW1lbnNpb25zKGZhbHNlKVxuICAgICAgLndpdGhQdXNoKGZhbHNlKVxuICAgICAgLndpdGhWaWV3cG9ydE1hcmdpbigwKVxuICAgICAgLndpdGhMb2NrZWRQb3NpdGlvbihsb2NrQWxpZ25tZW50KTtcblxuICAgIC8vIFVubGVzcyB0aGUgYWxpZ25tZW50IGlzIGZvcmNlZCwgYWRkIGZhbGxiYWNrcyBiYXNlZCBvbiB0aGUgcHJlZmVycmVkIHBvc2l0aW9uc1xuICAgIGlmICghZm9yY2VBbGlnbm1lbnQpIHtcbiAgICAgIGNvbnN0IGZhbGxiYWNrcyA9IHRoaXMuX2dldEZhbGxiYWNrcyhob3Jpem9udGFsVGFyZ2V0LCB2ZXJ0aWNhbFRhcmdldCk7XG4gICAgICBwb3NpdGlvbnMucHVzaCguLi5mYWxsYmFja3MpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJhdGVneS53aXRoUG9zaXRpb25zKHBvc2l0aW9ucyk7XG4gIH1cblxuICAvKiogR2V0IGZhbGxiYWNrIHBvc2l0aW9ucyBiYXNlZCBhcm91bmQgdGFyZ2V0IGFsaWdubWVudHMuICovXG4gIHByaXZhdGUgX2dldEZhbGxiYWNrcyhcbiAgICBoVGFyZ2V0OiBTYXRQb3BvdmVySG9yaXpvbnRhbEFsaWduLFxuICAgIHZUYXJnZXQ6IFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduXG4gICk6IENvbm5lY3Rpb25Qb3NpdGlvblBhaXJbXSB7XG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSB0YXJnZXQgYWxpZ25tZW50cyBvdmVybGFwIHRoZSBhbmNob3JcbiAgICBjb25zdCBob3Jpem9udGFsT3ZlcmxhcEFsbG93ZWQgPSBoVGFyZ2V0ICE9PSAnYmVmb3JlJyAmJiBoVGFyZ2V0ICE9PSAnYWZ0ZXInO1xuICAgIGNvbnN0IHZlcnRpY2FsT3ZlcmxhcEFsbG93ZWQgPSB2VGFyZ2V0ICE9PSAnYWJvdmUnICYmIHZUYXJnZXQgIT09ICdiZWxvdyc7XG5cbiAgICAvLyBJZiBhIHRhcmdldCBhbGlnbm1lbnQgZG9lc24ndCBjb3ZlciB0aGUgYW5jaG9yLCBkb24ndCBsZXQgYW55IG9mIHRoZSBmYWxsYmFjayBhbGlnbm1lbnRzXG4gICAgLy8gY292ZXIgdGhlIGFuY2hvclxuICAgIGNvbnN0IHBvc3NpYmxlSG9yaXpvbnRhbEFsaWdubWVudHM6IFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ25bXSA9XG4gICAgICBob3Jpem9udGFsT3ZlcmxhcEFsbG93ZWQgP1xuICAgICAgICBbJ2JlZm9yZScsICdzdGFydCcsICdjZW50ZXInLCAnZW5kJywgJ2FmdGVyJ10gOlxuICAgICAgICBbJ2JlZm9yZScsICdhZnRlciddO1xuICAgIGNvbnN0IHBvc3NpYmxlVmVydGljYWxBbGlnbm1lbnRzOiBTYXRQb3BvdmVyVmVydGljYWxBbGlnbltdID1cbiAgICAgIHZlcnRpY2FsT3ZlcmxhcEFsbG93ZWQgP1xuICAgICAgICBbJ2Fib3ZlJywgJ3N0YXJ0JywgJ2NlbnRlcicsICdlbmQnLCAnYmVsb3cnXSA6XG4gICAgICAgIFsnYWJvdmUnLCAnYmVsb3cnXTtcblxuICAgIC8vIENyZWF0ZSBmYWxsYmFja3MgZm9yIGVhY2ggYWxsb3dlZCBwcmlvcml0aXplZCBmYWxsYmFjayBhbGlnbm1lbnQgY29tYm9cbiAgICBjb25zdCBmYWxsYmFja3M6IENvbm5lY3Rpb25Qb3NpdGlvblBhaXJbXSA9IFtdO1xuICAgIHByaW9yaXRpemVBcm91bmRUYXJnZXQoaFRhcmdldCwgcG9zc2libGVIb3Jpem9udGFsQWxpZ25tZW50cykuZm9yRWFjaChoID0+IHtcbiAgICAgIHByaW9yaXRpemVBcm91bmRUYXJnZXQodlRhcmdldCwgcG9zc2libGVWZXJ0aWNhbEFsaWdubWVudHMpLmZvckVhY2godiA9PiB7XG4gICAgICAgIGZhbGxiYWNrcy5wdXNoKGdldFBvc2l0aW9uKGgsIHYpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBpdGVtIHNpbmNlIGl0IHdpbGwgYmUgdGhlIHRhcmdldCBhbGlnbm1lbnQgYW5kIGlzbid0IGNvbnNpZGVyZWQgYSBmYWxsYmFja1xuICAgIHJldHVybiBmYWxsYmFja3Muc2xpY2UoMSwgZmFsbGJhY2tzLmxlbmd0aCk7XG4gIH1cblxufVxuXG4vKiogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBhIGNkayBwb3NpdGlvbiBwYWlyIGZyb20gU2F0UG9wb3ZlciBhbGlnbm1lbnRzLiAqL1xuZnVuY3Rpb24gZ2V0UG9zaXRpb24oXG4gIGg6IFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ24sXG4gIHY6IFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduLFxuKTogQ29ubmVjdGlvblBvc2l0aW9uUGFpciB7XG4gIGNvbnN0IHtvcmlnaW5YLCBvdmVybGF5WH0gPSBnZXRIb3Jpem9udGFsQ29ubmVjdGlvblBvc1BhaXIoaCk7XG4gIGNvbnN0IHtvcmlnaW5ZLCBvdmVybGF5WX0gPSBnZXRWZXJ0aWNhbENvbm5lY3Rpb25Qb3NQYWlyKHYpO1xuICByZXR1cm4gbmV3IENvbm5lY3Rpb25Qb3NpdGlvblBhaXIoe29yaWdpblgsIG9yaWdpbll9LCB7b3ZlcmxheVgsIG92ZXJsYXlZfSk7XG59XG5cbi8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBhbiBvdmVybGF5IGNvbm5lY3Rpb24gcG9zaXRpb24gdG8gZXF1aXZhbGVudCBwb3BvdmVyIGFsaWdubWVudC4gKi9cbmZ1bmN0aW9uIGdldEhvcml6b250YWxQb3BvdmVyQWxpZ25tZW50KGg6IEhvcml6b250YWxDb25uZWN0aW9uUG9zKTogU2F0UG9wb3Zlckhvcml6b250YWxBbGlnbiB7XG4gIGlmIChoID09PSAnc3RhcnQnKSB7XG4gICAgcmV0dXJuICdhZnRlcic7XG4gIH1cblxuICBpZiAoaCA9PT0gJ2VuZCcpIHtcbiAgICByZXR1cm4gJ2JlZm9yZSc7XG4gIH1cblxuICByZXR1cm4gJ2NlbnRlcic7XG59XG5cbi8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBhbiBvdmVybGF5IGNvbm5lY3Rpb24gcG9zaXRpb24gdG8gZXF1aXZhbGVudCBwb3BvdmVyIGFsaWdubWVudC4gKi9cbmZ1bmN0aW9uIGdldFZlcnRpY2FsUG9wb3ZlckFsaWdubWVudCh2OiBWZXJ0aWNhbENvbm5lY3Rpb25Qb3MpOiBTYXRQb3BvdmVyVmVydGljYWxBbGlnbiB7XG4gIGlmICh2ID09PSAndG9wJykge1xuICAgIHJldHVybiAnYmVsb3cnO1xuICB9XG5cbiAgaWYgKHYgPT09ICdib3R0b20nKSB7XG4gICAgcmV0dXJuICdhYm92ZSc7XG4gIH1cblxuICByZXR1cm4gJ2NlbnRlcic7XG59XG5cbi8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBhbGlnbm1lbnQgdG8gb3JpZ2luL292ZXJsYXkgcG9zaXRpb24gcGFpci4gKi9cbmZ1bmN0aW9uIGdldEhvcml6b250YWxDb25uZWN0aW9uUG9zUGFpcihoOiBTYXRQb3BvdmVySG9yaXpvbnRhbEFsaWduKTpcbiAgICB7b3JpZ2luWDogSG9yaXpvbnRhbENvbm5lY3Rpb25Qb3MsIG92ZXJsYXlYOiBIb3Jpem9udGFsQ29ubmVjdGlvblBvc30ge1xuICBzd2l0Y2ggKGgpIHtcbiAgICBjYXNlICdiZWZvcmUnOlxuICAgICAgcmV0dXJuIHtvcmlnaW5YOiAnc3RhcnQnLCBvdmVybGF5WDogJ2VuZCd9O1xuICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgIHJldHVybiB7b3JpZ2luWDogJ3N0YXJ0Jywgb3ZlcmxheVg6ICdzdGFydCd9O1xuICAgIGNhc2UgJ2VuZCc6XG4gICAgICByZXR1cm4ge29yaWdpblg6ICdlbmQnLCBvdmVybGF5WDogJ2VuZCd9O1xuICAgIGNhc2UgJ2FmdGVyJzpcbiAgICAgIHJldHVybiB7b3JpZ2luWDogJ2VuZCcsIG92ZXJsYXlYOiAnc3RhcnQnfTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHtvcmlnaW5YOiAnY2VudGVyJywgb3ZlcmxheVg6ICdjZW50ZXInfTtcbiAgfVxufVxuXG4vKiogSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYWxpZ25tZW50IHRvIG9yaWdpbi9vdmVybGF5IHBvc2l0aW9uIHBhaXIuICovXG5mdW5jdGlvbiBnZXRWZXJ0aWNhbENvbm5lY3Rpb25Qb3NQYWlyKHY6IFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduKTpcbiAgICB7b3JpZ2luWTogVmVydGljYWxDb25uZWN0aW9uUG9zLCBvdmVybGF5WTogVmVydGljYWxDb25uZWN0aW9uUG9zfSB7XG4gIHN3aXRjaCAodikge1xuICAgIGNhc2UgJ2Fib3ZlJzpcbiAgICAgIHJldHVybiB7b3JpZ2luWTogJ3RvcCcsIG92ZXJsYXlZOiAnYm90dG9tJ307XG4gICAgY2FzZSAnc3RhcnQnOlxuICAgICAgcmV0dXJuIHtvcmlnaW5ZOiAndG9wJywgb3ZlcmxheVk6ICd0b3AnfTtcbiAgICBjYXNlICdlbmQnOlxuICAgICAgcmV0dXJuIHtvcmlnaW5ZOiAnYm90dG9tJywgb3ZlcmxheVk6ICdib3R0b20nfTtcbiAgICBjYXNlICdiZWxvdyc6XG4gICAgICByZXR1cm4ge29yaWdpblk6ICdib3R0b20nLCBvdmVybGF5WTogJ3RvcCd9O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4ge29yaWdpblk6ICdjZW50ZXInLCBvdmVybGF5WTogJ2NlbnRlcid9O1xuICB9XG59XG5cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBvcmRlcmVkIGFycmF5IG9wdGlvbnMgYW5kIHJldHVybnMgYSByZW9yZGVyZGVkXG4gKiBhcnJheSBhcm91bmQgdGhlIHRhcmdldCBpdGVtLiBlLmcuOlxuICpcbiAqIHRhcmdldDogMzsgb3B0aW9uczogWzEsIDIsIDMsIDQsIDUsIDYsIDddO1xuICpcbiAqIHJldHVybjogWzMsIDQsIDIsIDUsIDEsIDYsIDddXG4gKi9cbmZ1bmN0aW9uIHByaW9yaXRpemVBcm91bmRUYXJnZXQ8VD4odGFyZ2V0OiBULCBvcHRpb25zOiBUW10pOiBUW10ge1xuICBjb25zdCB0YXJnZXRJbmRleCA9IG9wdGlvbnMuaW5kZXhPZih0YXJnZXQpO1xuXG4gIC8vIFNldCB0aGUgZmlyc3QgaXRlbSB0byBiZSB0aGUgdGFyZ2V0XG4gIGNvbnN0IHJlb3JkZXJlZCA9IFt0YXJnZXRdO1xuXG4gIC8vIE1ha2UgbGVmdCBhbmQgcmlnaHQgc3RhY2tzIHdoZXJlIHRoZSBoaWdoZXN0IHByaW9yaXR5IGl0ZW0gaXMgbGFzdFxuICBjb25zdCBsZWZ0ID0gb3B0aW9ucy5zbGljZSgwLCB0YXJnZXRJbmRleCk7XG4gIGNvbnN0IHJpZ2h0ID0gb3B0aW9ucy5zbGljZSh0YXJnZXRJbmRleCArIDEsIG9wdGlvbnMubGVuZ3RoKS5yZXZlcnNlKCk7XG5cbiAgLy8gQWx0ZXJuYXRlIGJldHdlZW4gc3RhY2tzIHVudGlsIG9uZSBpcyBlbXB0eVxuICB3aGlsZSAobGVmdC5sZW5ndGggJiYgcmlnaHQubGVuZ3RoKSB7XG4gICAgcmVvcmRlcmVkLnB1c2gocmlnaHQucG9wKCkpO1xuICAgIHJlb3JkZXJlZC5wdXNoKGxlZnQucG9wKCkpO1xuICB9XG5cbiAgLy8gRmx1c2ggb3V0IHJpZ2h0IHNpZGVcbiAgd2hpbGUgKHJpZ2h0Lmxlbmd0aCkge1xuICAgIHJlb3JkZXJlZC5wdXNoKHJpZ2h0LnBvcCgpKTtcbiAgfVxuXG4gIC8vIEZsdXNoIG91dCBsZWZ0IHNpZGVcbiAgd2hpbGUgKGxlZnQubGVuZ3RoKSB7XG4gICAgcmVvcmRlcmVkLnB1c2gobGVmdC5wb3AoKSk7XG4gIH1cblxuICByZXR1cm4gcmVvcmRlcmVkO1xufVxuIl19