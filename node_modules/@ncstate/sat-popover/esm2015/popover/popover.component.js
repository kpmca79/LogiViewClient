/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ElementRef, EventEmitter, Inject, Input, ViewChild, ViewEncapsulation, TemplateRef, Optional, Output, Directive, ViewContainerRef } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { FocusTrapFactory } from '@angular/cdk/a11y';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { transformPopover } from './popover.animations';
import { getUnanchoredPopoverError, getInvalidHorizontalAlignError, getInvalidVerticalAlignError, getInvalidScrollStrategyError, getInvalidPopoverAnchorError, getInvalidSatPopoverAnchorError, getInvalidPopoverError } from './popover.errors';
import { VALID_SCROLL, VALID_HORIZ_ALIGN, VALID_VERT_ALIGN } from './types';
import { SatPopoverAnchoringService } from './popover-anchoring.service';
// See http://cubic-bezier.com/#.25,.8,.25,1 for reference.
/** @type {?} */
const DEFAULT_TRANSITION = '200ms cubic-bezier(0.25, 0.8, 0.25, 1)';
export class SatPopoverAnchor {
    /**
     * @param {?} elementRef
     * @param {?} viewContainerRef
     */
    constructor(elementRef, viewContainerRef) {
        this.elementRef = elementRef;
        this.viewContainerRef = viewContainerRef;
    }
    /**
     * @return {?}
     */
    get popover() {
        return this._popover;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set popover(val) {
        if (val instanceof SatPopover) {
            val.anchor = this;
        }
        else {
            // when a directive is added with no arguments,
            // angular assigns `''` as the argument
            if (val !== '') {
                throw getInvalidPopoverError();
            }
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (!this.popover) {
            throw getInvalidSatPopoverAnchorError();
        }
    }
}
SatPopoverAnchor.decorators = [
    { type: Directive, args: [{
                selector: '[satPopoverAnchor]',
                exportAs: 'satPopoverAnchor'
            },] }
];
/** @nocollapse */
SatPopoverAnchor.ctorParameters = () => [
    { type: ElementRef },
    { type: ViewContainerRef }
];
SatPopoverAnchor.propDecorators = {
    popover: [{ type: Input, args: ['satPopoverAnchor',] }]
};
if (false) {
    /**
     * \@internal
     * @type {?}
     */
    SatPopoverAnchor.prototype._popover;
    /** @type {?} */
    SatPopoverAnchor.prototype.elementRef;
    /** @type {?} */
    SatPopoverAnchor.prototype.viewContainerRef;
}
export class SatPopover {
    /**
     * @param {?} _focusTrapFactory
     * @param {?} _anchoringService
     * @param {?} _viewContainerRef
     * @param {?} _document
     */
    constructor(_focusTrapFactory, _anchoringService, _viewContainerRef, _document) {
        this._focusTrapFactory = _focusTrapFactory;
        this._viewContainerRef = _viewContainerRef;
        this._document = _document;
        this._horizontalAlign = 'center';
        this._verticalAlign = 'center';
        this._forceAlignment = false;
        this._lockAlignment = false;
        this._autoFocus = true;
        this._autoFocusOverride = true;
        this._restoreFocus = true;
        this._restoreFocusOverride = true;
        this._scrollStrategy = 'reposition';
        this._hasBackdrop = false;
        this._interactiveClose = true;
        this._openTransition = DEFAULT_TRANSITION;
        this._closeTransition = DEFAULT_TRANSITION;
        /**
         * Optional backdrop class.
         */
        this.backdropClass = '';
        /**
         * Emits when the popover is opened.
         */
        this.opened = new EventEmitter();
        /**
         * Emits when the popover is closed.
         */
        this.closed = new EventEmitter();
        /**
         * Emits when the popover has finished opening.
         */
        this.afterOpen = new EventEmitter();
        /**
         * Emits when the popover has finished closing.
         */
        this.afterClose = new EventEmitter();
        /**
         * Emits when the backdrop is clicked.
         */
        this.backdropClicked = new EventEmitter();
        /**
         * Emits when a keydown event is targeted to this popover's overlay.
         */
        this.overlayKeydown = new EventEmitter();
        /**
         * Classes to be added to the popover for setting the correct transform origin.
         */
        this._classList = {};
        /**
         * Whether the popover is presently open.
         */
        this._open = false;
        // `@internal` stripping doesn't seem to work if the property is
        // declared inside the constructor
        this._anchoringService = _anchoringService;
    }
    /**
     * Anchor element.
     * @return {?}
     */
    get anchor() {
        return this._anchor;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set anchor(val) {
        if (val instanceof SatPopoverAnchor) {
            val._popover = this;
            this._anchoringService.anchor(this, val.viewContainerRef, val.elementRef);
            this._anchor = val;
        }
        else if (val instanceof ElementRef || val instanceof HTMLElement) {
            this._anchoringService.anchor(this, this._viewContainerRef, val);
            this._anchor = val;
        }
        else if (val) {
            throw getInvalidPopoverAnchorError();
        }
    }
    /**
     * Alignment of the popover on the horizontal axis.
     * @return {?}
     */
    get horizontalAlign() {
        return this._horizontalAlign;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set horizontalAlign(val) {
        this._validateHorizontalAlign(val);
        if (this._horizontalAlign !== val) {
            this._horizontalAlign = val;
            this._anchoringService.repositionPopover();
        }
    }
    /**
     * Alignment of the popover on the x axis. Alias for `horizontalAlign`.
     * @return {?}
     */
    get xAlign() {
        return this.horizontalAlign;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set xAlign(val) {
        this.horizontalAlign = val;
    }
    /**
     * Alignment of the popover on the vertical axis.
     * @return {?}
     */
    get verticalAlign() {
        return this._verticalAlign;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set verticalAlign(val) {
        this._validateVerticalAlign(val);
        if (this._verticalAlign !== val) {
            this._verticalAlign = val;
            this._anchoringService.repositionPopover();
        }
    }
    /**
     * Alignment of the popover on the y axis. Alias for `verticalAlign`.
     * @return {?}
     */
    get yAlign() {
        return this.verticalAlign;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set yAlign(val) {
        this.verticalAlign = val;
    }
    /**
     * Whether the popover always opens with the specified alignment.
     * @return {?}
     */
    get forceAlignment() {
        return this._forceAlignment;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set forceAlignment(val) {
        /** @type {?} */
        const coercedVal = coerceBooleanProperty(val);
        if (this._forceAlignment !== coercedVal) {
            this._forceAlignment = coercedVal;
            this._anchoringService.repositionPopover();
        }
    }
    /**
     * Whether the popover's alignment is locked after opening. This prevents the popover
     * from changing its alignement when scrolling or changing the size of the viewport.
     * @return {?}
     */
    get lockAlignment() {
        return this._lockAlignment;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set lockAlignment(val) {
        /** @type {?} */
        const coercedVal = coerceBooleanProperty(val);
        if (this._lockAlignment !== coercedVal) {
            this._lockAlignment = coerceBooleanProperty(val);
            this._anchoringService.repositionPopover();
        }
    }
    /**
     * Whether the first focusable element should be focused on open.
     * @return {?}
     */
    get autoFocus() {
        return this._autoFocus && this._autoFocusOverride;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set autoFocus(val) {
        this._autoFocus = coerceBooleanProperty(val);
    }
    /**
     * Whether the popover should return focus to the previously focused element after closing.
     * @return {?}
     */
    get restoreFocus() {
        return this._restoreFocus && this._restoreFocusOverride;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set restoreFocus(val) {
        this._restoreFocus = coerceBooleanProperty(val);
    }
    /**
     * How the popover should handle scrolling.
     * @return {?}
     */
    get scrollStrategy() {
        return this._scrollStrategy;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set scrollStrategy(val) {
        this._validateScrollStrategy(val);
        if (this._scrollStrategy !== val) {
            this._scrollStrategy = val;
            this._anchoringService.updatePopoverConfig();
        }
    }
    /**
     * Whether the popover should have a backdrop (includes closing on click).
     * @return {?}
     */
    get hasBackdrop() {
        return this._hasBackdrop;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set hasBackdrop(val) {
        this._hasBackdrop = coerceBooleanProperty(val);
    }
    /**
     * Whether the popover should close when the user clicks the backdrop or presses ESC.
     * @return {?}
     */
    get interactiveClose() {
        return this._interactiveClose;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set interactiveClose(val) {
        this._interactiveClose = coerceBooleanProperty(val);
    }
    /**
     * Custom transition to use while opening.
     * @return {?}
     */
    get openTransition() {
        return this._openTransition;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set openTransition(val) {
        if (val) {
            this._openTransition = val;
        }
    }
    /**
     * Custom transition to use while closing.
     * @return {?}
     */
    get closeTransition() {
        return this._closeTransition;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set closeTransition(val) {
        if (val) {
            this._closeTransition = val;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._setAlignmentClasses();
    }
    /**
     * Open this popover.
     * @param {?=} options
     * @return {?}
     */
    open(options = {}) {
        if (this._anchor) {
            this._anchoringService.openPopover(options);
            return;
        }
        throw getUnanchoredPopoverError();
    }
    /**
     * Close this popover.
     * @param {?=} value
     * @return {?}
     */
    close(value) {
        this._anchoringService.closePopover(value);
    }
    /**
     * Toggle this popover open or closed.
     * @return {?}
     */
    toggle() {
        this._anchoringService.togglePopover();
    }
    /**
     * Realign the popover to the anchor.
     * @return {?}
     */
    realign() {
        this._anchoringService.realignPopoverToAnchor();
    }
    /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    isOpen() {
        return this._open;
    }
    /**
     * Allows programmatically setting a custom anchor.
     * @param {?} viewContainer
     * @param {?} el
     * @return {?}
     */
    setCustomAnchor(viewContainer, el) {
        this._anchor = el;
        this._anchoringService.anchor(this, viewContainer, el);
    }
    /**
     * Gets an animation config with customized (or default) transition values.
     * @return {?}
     */
    _getAnimation() {
        return {
            value: 'visible',
            params: { openTransition: this.openTransition, closeTransition: this.closeTransition }
        };
    }
    /**
     * Callback for when the popover is finished animating in or out.
     * @param {?} event
     * @return {?}
     */
    _onAnimationDone(event) {
        if (event.toState === 'visible') {
            this._trapFocus();
            this.afterOpen.emit();
        }
        else if (event.toState === 'void') {
            this._restoreFocusAndDestroyTrap();
            this.afterClose.emit();
        }
    }
    /**
     * Apply alignment classes based on alignment inputs.
     * @param {?=} horizAlign
     * @param {?=} vertAlign
     * @return {?}
     */
    _setAlignmentClasses(horizAlign = this.horizontalAlign, vertAlign = this.verticalAlign) {
        this._classList['sat-popover-before'] = horizAlign === 'before' || horizAlign === 'end';
        this._classList['sat-popover-after'] = horizAlign === 'after' || horizAlign === 'start';
        this._classList['sat-popover-above'] = vertAlign === 'above' || vertAlign === 'end';
        this._classList['sat-popover-below'] = vertAlign === 'below' || vertAlign === 'start';
        this._classList['sat-popover-center'] = horizAlign === 'center' || vertAlign === 'center';
    }
    /**
     * Move the focus inside the focus trap and remember where to return later.
     * @private
     * @return {?}
     */
    _trapFocus() {
        this._savePreviouslyFocusedElement();
        // There won't be a focus trap element if the close animation starts before open finishes
        if (!this._focusTrapElement) {
            return;
        }
        if (!this._focusTrap && this._focusTrapElement) {
            this._focusTrap = this._focusTrapFactory.create(this._focusTrapElement.nativeElement);
        }
        if (this.autoFocus) {
            this._focusTrap.focusInitialElementWhenReady();
        }
    }
    /**
     * Restore focus to the element focused before the popover opened. Also destroy trap.
     * @private
     * @return {?}
     */
    _restoreFocusAndDestroyTrap() {
        /** @type {?} */
        const toFocus = this._previouslyFocusedElement;
        // Must check active element is focusable for IE sake
        if (toFocus && 'focus' in toFocus && this.restoreFocus) {
            this._previouslyFocusedElement.focus();
        }
        this._previouslyFocusedElement = null;
        if (this._focusTrap) {
            this._focusTrap.destroy();
            this._focusTrap = undefined;
        }
    }
    /**
     * Save a reference to the element focused before the popover was opened.
     * @private
     * @return {?}
     */
    _savePreviouslyFocusedElement() {
        if (this._document) {
            this._previouslyFocusedElement = (/** @type {?} */ (this._document.activeElement));
        }
    }
    /**
     * Throws an error if the alignment is not a valid horizontalAlign.
     * @private
     * @param {?} pos
     * @return {?}
     */
    _validateHorizontalAlign(pos) {
        if (VALID_HORIZ_ALIGN.indexOf(pos) === -1) {
            throw getInvalidHorizontalAlignError(pos);
        }
    }
    /**
     * Throws an error if the alignment is not a valid verticalAlign.
     * @private
     * @param {?} pos
     * @return {?}
     */
    _validateVerticalAlign(pos) {
        if (VALID_VERT_ALIGN.indexOf(pos) === -1) {
            throw getInvalidVerticalAlignError(pos);
        }
    }
    /**
     * Throws an error if the scroll strategy is not a valid strategy.
     * @private
     * @param {?} strategy
     * @return {?}
     */
    _validateScrollStrategy(strategy) {
        if (VALID_SCROLL.indexOf(strategy) === -1) {
            throw getInvalidScrollStrategyError(strategy);
        }
    }
}
SatPopover.decorators = [
    { type: Component, args: [{
                selector: 'sat-popover',
                encapsulation: ViewEncapsulation.None,
                animations: [transformPopover],
                template: "<ng-template>\n  <div class=\"sat-popover-container\"\n      #focusTrapElement\n      [ngClass]=\"_classList\"\n      [@transformPopover]=\"_getAnimation()\"\n      (@transformPopover.done)=\"_onAnimationDone($event)\">\n    <ng-content></ng-content>\n  </div>\n</ng-template>\n",
                providers: [SatPopoverAnchoringService],
                styles: [".cdk-global-overlay-wrapper,.cdk-overlay-container{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}@media screen and (-ms-high-contrast:active){.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop,.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}.sat-popover-container.sat-popover-before.sat-popover-above{-webkit-transform-origin:right bottom;transform-origin:right bottom}[dir=rtl] .sat-popover-container.sat-popover-before.sat-popover-above{-webkit-transform-origin:left bottom;transform-origin:left bottom}.sat-popover-container.sat-popover-before.sat-popover-center{-webkit-transform-origin:right center;transform-origin:right center}[dir=rtl] .sat-popover-container.sat-popover-before.sat-popover-center{-webkit-transform-origin:left center;transform-origin:left center}.sat-popover-container.sat-popover-before.sat-popover-below{-webkit-transform-origin:right top;transform-origin:right top}[dir=rtl] .sat-popover-container.sat-popover-before.sat-popover-below{-webkit-transform-origin:left top;transform-origin:left top}.sat-popover-container.sat-popover-center.sat-popover-above{-webkit-transform-origin:center bottom;transform-origin:center bottom}.sat-popover-container.sat-popover-center.sat-popover-below{-webkit-transform-origin:center top;transform-origin:center top}.sat-popover-container.sat-popover-after.sat-popover-above{-webkit-transform-origin:left bottom;transform-origin:left bottom}[dir=rtl] .sat-popover-container.sat-popover-after.sat-popover-above{-webkit-transform-origin:right bottom;transform-origin:right bottom}.sat-popover-container.sat-popover-after.sat-popover-center{-webkit-transform-origin:left center;transform-origin:left center}[dir=rtl] .sat-popover-container.sat-popover-after.sat-popover-center{-webkit-transform-origin:right center;transform-origin:right center}.sat-popover-container.sat-popover-after.sat-popover-below{-webkit-transform-origin:left top;transform-origin:left top}[dir=rtl] .sat-popover-container.sat-popover-after.sat-popover-below{-webkit-transform-origin:right top;transform-origin:right top}"]
            }] }
];
/** @nocollapse */
SatPopover.ctorParameters = () => [
    { type: FocusTrapFactory },
    { type: SatPopoverAnchoringService },
    { type: ViewContainerRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
];
SatPopover.propDecorators = {
    anchor: [{ type: Input }],
    horizontalAlign: [{ type: Input }],
    xAlign: [{ type: Input }],
    verticalAlign: [{ type: Input }],
    yAlign: [{ type: Input }],
    forceAlignment: [{ type: Input }],
    lockAlignment: [{ type: Input }],
    autoFocus: [{ type: Input }],
    restoreFocus: [{ type: Input }],
    scrollStrategy: [{ type: Input }],
    hasBackdrop: [{ type: Input }],
    interactiveClose: [{ type: Input }],
    openTransition: [{ type: Input }],
    closeTransition: [{ type: Input }],
    backdropClass: [{ type: Input }],
    opened: [{ type: Output }],
    closed: [{ type: Output }],
    afterOpen: [{ type: Output }],
    afterClose: [{ type: Output }],
    backdropClicked: [{ type: Output }],
    overlayKeydown: [{ type: Output }],
    _templateRef: [{ type: ViewChild, args: [TemplateRef, { static: true },] }],
    _focusTrapElement: [{ type: ViewChild, args: ['focusTrapElement', { static: false },] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    SatPopover.prototype._anchor;
    /**
     * @type {?}
     * @private
     */
    SatPopover.prototype._horizontalAlign;
    /**
     * @type {?}
     * @private
     */
    SatPopover.prototype._verticalAlign;
    /**
     * @type {?}
     * @private
     */
    SatPopover.prototype._forceAlignment;
    /**
     * @type {?}
     * @private
     */
    SatPopover.prototype._lockAlignment;
    /**
     * @type {?}
     * @private
     */
    SatPopover.prototype._autoFocus;
    /** @type {?} */
    SatPopover.prototype._autoFocusOverride;
    /**
     * @type {?}
     * @private
     */
    SatPopover.prototype._restoreFocus;
    /** @type {?} */
    SatPopover.prototype._restoreFocusOverride;
    /**
     * @type {?}
     * @private
     */
    SatPopover.prototype._scrollStrategy;
    /**
     * @type {?}
     * @private
     */
    SatPopover.prototype._hasBackdrop;
    /**
     * @type {?}
     * @private
     */
    SatPopover.prototype._interactiveClose;
    /**
     * @type {?}
     * @private
     */
    SatPopover.prototype._openTransition;
    /**
     * @type {?}
     * @private
     */
    SatPopover.prototype._closeTransition;
    /**
     * Optional backdrop class.
     * @type {?}
     */
    SatPopover.prototype.backdropClass;
    /**
     * Emits when the popover is opened.
     * @type {?}
     */
    SatPopover.prototype.opened;
    /**
     * Emits when the popover is closed.
     * @type {?}
     */
    SatPopover.prototype.closed;
    /**
     * Emits when the popover has finished opening.
     * @type {?}
     */
    SatPopover.prototype.afterOpen;
    /**
     * Emits when the popover has finished closing.
     * @type {?}
     */
    SatPopover.prototype.afterClose;
    /**
     * Emits when the backdrop is clicked.
     * @type {?}
     */
    SatPopover.prototype.backdropClicked;
    /**
     * Emits when a keydown event is targeted to this popover's overlay.
     * @type {?}
     */
    SatPopover.prototype.overlayKeydown;
    /**
     * Reference to template so it can be placed within a portal.
     * @type {?}
     */
    SatPopover.prototype._templateRef;
    /**
     * Classes to be added to the popover for setting the correct transform origin.
     * @type {?}
     */
    SatPopover.prototype._classList;
    /**
     * Whether the popover is presently open.
     * @type {?}
     */
    SatPopover.prototype._open;
    /**
     * \@internal
     * @type {?}
     */
    SatPopover.prototype._anchoringService;
    /**
     * Reference to the element to build a focus trap around.
     * @type {?}
     * @private
     */
    SatPopover.prototype._focusTrapElement;
    /**
     * Reference to the element that was focused before opening.
     * @type {?}
     * @private
     */
    SatPopover.prototype._previouslyFocusedElement;
    /**
     * Reference to a focus trap around the popover.
     * @type {?}
     * @private
     */
    SatPopover.prototype._focusTrap;
    /**
     * @type {?}
     * @private
     */
    SatPopover.prototype._focusTrapFactory;
    /**
     * @type {?}
     * @private
     */
    SatPopover.prototype._viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    SatPopover.prototype._document;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AbmNzdGF0ZS9zYXQtcG9wb3Zlci8iLCJzb3VyY2VzIjpbInBvcG92ZXIvcG9wb3Zlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQ1QsVUFBVSxFQUNWLFlBQVksRUFDWixNQUFNLEVBQ04sS0FBSyxFQUNMLFNBQVMsRUFDVCxpQkFBaUIsRUFDakIsV0FBVyxFQUVYLFFBQVEsRUFDUixNQUFNLEVBQ04sU0FBUyxFQUNULGdCQUFnQixFQUVqQixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUFhLGdCQUFnQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDaEUsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFFOUQsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDeEQsT0FBTyxFQUNMLHlCQUF5QixFQUN6Qiw4QkFBOEIsRUFDOUIsNEJBQTRCLEVBQzVCLDZCQUE2QixFQUM3Qiw0QkFBNEIsRUFDNUIsK0JBQStCLEVBQy9CLHNCQUFzQixFQUN2QixNQUFNLGtCQUFrQixDQUFDO0FBQzFCLE9BQU8sRUFJTCxZQUFZLEVBQ1osaUJBQWlCLEVBQ2pCLGdCQUFnQixFQUVqQixNQUFNLFNBQVMsQ0FBQztBQUNqQixPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQzs7O01BR25FLGtCQUFrQixHQUFHLHdDQUF3QztBQU1uRSxNQUFNLE9BQU8sZ0JBQWdCOzs7OztJQW9CM0IsWUFBbUIsVUFBc0IsRUFBUyxnQkFBa0M7UUFBakUsZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQUFTLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBa0I7SUFBRyxDQUFDOzs7O0lBbkJ4RixJQUNJLE9BQU87UUFD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RDs7Ozs7SUF1Qi9ELG9DQUEyRDs7Ozs7SUF1QjNELHFDQUFnQzs7Ozs7SUFpQmhDLG9DQUErQjs7Ozs7SUFVL0IsZ0NBQTBCOztJQUMxQix3Q0FBMEI7Ozs7O0lBVTFCLG1DQUE2Qjs7SUFDN0IsMkNBQTZCOzs7OztJQWM3QixxQ0FBaUU7Ozs7O0lBVWpFLGtDQUE2Qjs7Ozs7SUFVN0IsdUNBQWlDOzs7OztJQVlqQyxxQ0FBNkM7Ozs7O0lBWTdDLHNDQUE4Qzs7Ozs7SUFHOUMsbUNBQTRCOzs7OztJQUc1Qiw0QkFBNEM7Ozs7O0lBRzVDLDRCQUEyQzs7Ozs7SUFHM0MsK0JBQStDOzs7OztJQUcvQyxnQ0FBZ0Q7Ozs7O0lBR2hELHFDQUFxRDs7Ozs7SUFHckQsb0NBQTZEOzs7OztJQUc3RCxrQ0FBeUU7Ozs7O0lBR3pFLGdDQUFxQjs7Ozs7SUFHckIsMkJBQWM7Ozs7O0lBR2QsdUNBQThDOzs7Ozs7SUFHOUMsdUNBQ3NDOzs7Ozs7SUFHdEMsK0NBQStDOzs7Ozs7SUFHL0MsZ0NBQThCOzs7OztJQUc1Qix1Q0FBMkM7Ozs7O0lBRTNDLHVDQUEyQzs7Ozs7SUFDM0MsK0JBQW9EIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIEluamVjdCxcbiAgSW5wdXQsXG4gIFZpZXdDaGlsZCxcbiAgVmlld0VuY2Fwc3VsYXRpb24sXG4gIFRlbXBsYXRlUmVmLFxuICBPbkluaXQsXG4gIE9wdGlvbmFsLFxuICBPdXRwdXQsXG4gIERpcmVjdGl2ZSxcbiAgVmlld0NvbnRhaW5lclJlZixcbiAgQWZ0ZXJWaWV3SW5pdFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFuaW1hdGlvbkV2ZW50IH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBGb2N1c1RyYXAsIEZvY3VzVHJhcEZhY3RvcnkgfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XG5pbXBvcnQgeyBjb2VyY2VCb29sZWFuUHJvcGVydHkgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuXG5pbXBvcnQgeyB0cmFuc2Zvcm1Qb3BvdmVyIH0gZnJvbSAnLi9wb3BvdmVyLmFuaW1hdGlvbnMnO1xuaW1wb3J0IHtcbiAgZ2V0VW5hbmNob3JlZFBvcG92ZXJFcnJvcixcbiAgZ2V0SW52YWxpZEhvcml6b250YWxBbGlnbkVycm9yLFxuICBnZXRJbnZhbGlkVmVydGljYWxBbGlnbkVycm9yLFxuICBnZXRJbnZhbGlkU2Nyb2xsU3RyYXRlZ3lFcnJvcixcbiAgZ2V0SW52YWxpZFBvcG92ZXJBbmNob3JFcnJvcixcbiAgZ2V0SW52YWxpZFNhdFBvcG92ZXJBbmNob3JFcnJvcixcbiAgZ2V0SW52YWxpZFBvcG92ZXJFcnJvclxufSBmcm9tICcuL3BvcG92ZXIuZXJyb3JzJztcbmltcG9ydCB7XG4gIFNhdFBvcG92ZXJTY3JvbGxTdHJhdGVneSxcbiAgU2F0UG9wb3Zlckhvcml6b250YWxBbGlnbixcbiAgU2F0UG9wb3ZlclZlcnRpY2FsQWxpZ24sXG4gIFZBTElEX1NDUk9MTCxcbiAgVkFMSURfSE9SSVpfQUxJR04sXG4gIFZBTElEX1ZFUlRfQUxJR04sXG4gIFNhdFBvcG92ZXJPcGVuT3B0aW9uc1xufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IFNhdFBvcG92ZXJBbmNob3JpbmdTZXJ2aWNlIH0gZnJvbSAnLi9wb3BvdmVyLWFuY2hvcmluZy5zZXJ2aWNlJztcblxuLy8gU2VlIGh0dHA6Ly9jdWJpYy1iZXppZXIuY29tLyMuMjUsLjgsLjI1LDEgZm9yIHJlZmVyZW5jZS5cbmNvbnN0IERFRkFVTFRfVFJBTlNJVElPTiA9ICcyMDBtcyBjdWJpYy1iZXppZXIoMC4yNSwgMC44LCAwLjI1LCAxKSc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tzYXRQb3BvdmVyQW5jaG9yXScsXG4gIGV4cG9ydEFzOiAnc2F0UG9wb3ZlckFuY2hvcidcbn0pXG5leHBvcnQgY2xhc3MgU2F0UG9wb3ZlckFuY2hvciBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQge1xuICBASW5wdXQoJ3NhdFBvcG92ZXJBbmNob3InKVxuICBnZXQgcG9wb3ZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9wb3ZlcjtcbiAgfVxuICBzZXQgcG9wb3Zlcih2YWw6IFNhdFBvcG92ZXIpIHtcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgU2F0UG9wb3Zlcikge1xuICAgICAgdmFsLmFuY2hvciA9IHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdoZW4gYSBkaXJlY3RpdmUgaXMgYWRkZWQgd2l0aCBubyBhcmd1bWVudHMsXG4gICAgICAvLyBhbmd1bGFyIGFzc2lnbnMgYCcnYCBhcyB0aGUgYXJndW1lbnRcbiAgICAgIGlmICh2YWwgIT09ICcnKSB7XG4gICAgICAgIHRocm93IGdldEludmFsaWRQb3BvdmVyRXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9wb3BvdmVyOiBTYXRQb3BvdmVyO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBwdWJsaWMgdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZikge31cblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgaWYgKCF0aGlzLnBvcG92ZXIpIHtcbiAgICAgIHRocm93IGdldEludmFsaWRTYXRQb3BvdmVyQW5jaG9yRXJyb3IoKTtcbiAgICB9XG4gIH1cbn1cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnc2F0LXBvcG92ZXInLFxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICBhbmltYXRpb25zOiBbdHJhbnNmb3JtUG9wb3Zlcl0sXG4gIHN0eWxlVXJsczogWycuL3BvcG92ZXIuY29tcG9uZW50LnNjc3MnXSxcbiAgdGVtcGxhdGVVcmw6ICcuL3BvcG92ZXIuY29tcG9uZW50Lmh0bWwnLFxuICBwcm92aWRlcnM6IFtTYXRQb3BvdmVyQW5jaG9yaW5nU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgU2F0UG9wb3ZlciBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIC8qKiBBbmNob3IgZWxlbWVudC4gKi9cbiAgQElucHV0KClcbiAgZ2V0IGFuY2hvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fYW5jaG9yO1xuICB9XG4gIHNldCBhbmNob3IodmFsOiBTYXRQb3BvdmVyQW5jaG9yIHwgRWxlbWVudFJlZjxIVE1MRWxlbWVudD4gfCBIVE1MRWxlbWVudCkge1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBTYXRQb3BvdmVyQW5jaG9yKSB7XG4gICAgICB2YWwuX3BvcG92ZXIgPSB0aGlzO1xuICAgICAgdGhpcy5fYW5jaG9yaW5nU2VydmljZS5hbmNob3IodGhpcywgdmFsLnZpZXdDb250YWluZXJSZWYsIHZhbC5lbGVtZW50UmVmKTtcbiAgICAgIHRoaXMuX2FuY2hvciA9IHZhbDtcbiAgICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIEVsZW1lbnRSZWYgfHwgdmFsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX2FuY2hvcmluZ1NlcnZpY2UuYW5jaG9yKHRoaXMsIHRoaXMuX3ZpZXdDb250YWluZXJSZWYsIHZhbCk7XG4gICAgICB0aGlzLl9hbmNob3IgPSB2YWw7XG4gICAgfSBlbHNlIGlmICh2YWwpIHtcbiAgICAgIHRocm93IGdldEludmFsaWRQb3BvdmVyQW5jaG9yRXJyb3IoKTtcbiAgICB9XG4gIH1cbiAgcHJpdmF0ZSBfYW5jaG9yOiBTYXRQb3BvdmVyQW5jaG9yIHwgRWxlbWVudFJlZjxIVE1MRWxlbWVudD4gfCBIVE1MRWxlbWVudDtcblxuICAvKiogQWxpZ25tZW50IG9mIHRoZSBwb3BvdmVyIG9uIHRoZSBob3Jpem9udGFsIGF4aXMuICovXG4gIEBJbnB1dCgpXG4gIGdldCBob3Jpem9udGFsQWxpZ24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hvcml6b250YWxBbGlnbjtcbiAgfVxuICBzZXQgaG9yaXpvbnRhbEFsaWduKHZhbDogU2F0UG9wb3Zlckhvcml6b250YWxBbGlnbikge1xuICAgIHRoaXMuX3ZhbGlkYXRlSG9yaXpvbnRhbEFsaWduKHZhbCk7XG4gICAgaWYgKHRoaXMuX2hvcml6b250YWxBbGlnbiAhPT0gdmFsKSB7XG4gICAgICB0aGlzLl9ob3Jpem9udGFsQWxpZ24gPSB2YWw7XG4gICAgICB0aGlzLl9hbmNob3JpbmdTZXJ2aWNlLnJlcG9zaXRpb25Qb3BvdmVyKCk7XG4gICAgfVxuICB9XG4gIHByaXZhdGUgX2hvcml6b250YWxBbGlnbjogU2F0UG9wb3Zlckhvcml6b250YWxBbGlnbiA9ICdjZW50ZXInO1xuXG4gIC8qKiBBbGlnbm1lbnQgb2YgdGhlIHBvcG92ZXIgb24gdGhlIHggYXhpcy4gQWxpYXMgZm9yIGBob3Jpem9udGFsQWxpZ25gLiAqL1xuICBASW5wdXQoKVxuICBnZXQgeEFsaWduKCkge1xuICAgIHJldHVybiB0aGlzLmhvcml6b250YWxBbGlnbjtcbiAgfVxuICBzZXQgeEFsaWduKHZhbDogU2F0UG9wb3Zlckhvcml6b250YWxBbGlnbikge1xuICAgIHRoaXMuaG9yaXpvbnRhbEFsaWduID0gdmFsO1xuICB9XG5cbiAgLyoqIEFsaWdubWVudCBvZiB0aGUgcG9wb3ZlciBvbiB0aGUgdmVydGljYWwgYXhpcy4gKi9cbiAgQElucHV0KClcbiAgZ2V0IHZlcnRpY2FsQWxpZ24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZlcnRpY2FsQWxpZ247XG4gIH1cbiAgc2V0IHZlcnRpY2FsQWxpZ24odmFsOiBTYXRQb3BvdmVyVmVydGljYWxBbGlnbikge1xuICAgIHRoaXMuX3ZhbGlkYXRlVmVydGljYWxBbGlnbih2YWwpO1xuICAgIGlmICh0aGlzLl92ZXJ0aWNhbEFsaWduICE9PSB2YWwpIHtcbiAgICAgIHRoaXMuX3ZlcnRpY2FsQWxpZ24gPSB2YWw7XG4gICAgICB0aGlzLl9hbmNob3JpbmdTZXJ2aWNlLnJlcG9zaXRpb25Qb3BvdmVyKCk7XG4gICAgfVxuICB9XG4gIHByaXZhdGUgX3ZlcnRpY2FsQWxpZ246IFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduID0gJ2NlbnRlcic7XG5cbiAgLyoqIEFsaWdubWVudCBvZiB0aGUgcG9wb3ZlciBvbiB0aGUgeSBheGlzLiBBbGlhcyBmb3IgYHZlcnRpY2FsQWxpZ25gLiAqL1xuICBASW5wdXQoKVxuICBnZXQgeUFsaWduKCkge1xuICAgIHJldHVybiB0aGlzLnZlcnRpY2FsQWxpZ247XG4gIH1cbiAgc2V0IHlBbGlnbih2YWw6IFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduKSB7XG4gICAgdGhpcy52ZXJ0aWNhbEFsaWduID0gdmFsO1xuICB9XG5cbiAgLyoqIFdoZXRoZXIgdGhlIHBvcG92ZXIgYWx3YXlzIG9wZW5zIHdpdGggdGhlIHNwZWNpZmllZCBhbGlnbm1lbnQuICovXG4gIEBJbnB1dCgpXG4gIGdldCBmb3JjZUFsaWdubWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9yY2VBbGlnbm1lbnQ7XG4gIH1cbiAgc2V0IGZvcmNlQWxpZ25tZW50KHZhbDogYm9vbGVhbikge1xuICAgIGNvbnN0IGNvZXJjZWRWYWwgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsKTtcbiAgICBpZiAodGhpcy5fZm9yY2VBbGlnbm1lbnQgIT09IGNvZXJjZWRWYWwpIHtcbiAgICAgIHRoaXMuX2ZvcmNlQWxpZ25tZW50ID0gY29lcmNlZFZhbDtcbiAgICAgIHRoaXMuX2FuY2hvcmluZ1NlcnZpY2UucmVwb3NpdGlvblBvcG92ZXIoKTtcbiAgICB9XG4gIH1cbiAgcHJpdmF0ZSBfZm9yY2VBbGlnbm1lbnQgPSBmYWxzZTtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgcG9wb3ZlcidzIGFsaWdubWVudCBpcyBsb2NrZWQgYWZ0ZXIgb3BlbmluZy4gVGhpcyBwcmV2ZW50cyB0aGUgcG9wb3ZlclxuICAgKiBmcm9tIGNoYW5naW5nIGl0cyBhbGlnbmVtZW50IHdoZW4gc2Nyb2xsaW5nIG9yIGNoYW5naW5nIHRoZSBzaXplIG9mIHRoZSB2aWV3cG9ydC5cbiAgICovXG4gIEBJbnB1dCgpXG4gIGdldCBsb2NrQWxpZ25tZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9sb2NrQWxpZ25tZW50O1xuICB9XG4gIHNldCBsb2NrQWxpZ25tZW50KHZhbDogYm9vbGVhbikge1xuICAgIGNvbnN0IGNvZXJjZWRWYWwgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsKTtcbiAgICBpZiAodGhpcy5fbG9ja0FsaWdubWVudCAhPT0gY29lcmNlZFZhbCkge1xuICAgICAgdGhpcy5fbG9ja0FsaWdubWVudCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWwpO1xuICAgICAgdGhpcy5fYW5jaG9yaW5nU2VydmljZS5yZXBvc2l0aW9uUG9wb3ZlcigpO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIF9sb2NrQWxpZ25tZW50ID0gZmFsc2U7XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGZpcnN0IGZvY3VzYWJsZSBlbGVtZW50IHNob3VsZCBiZSBmb2N1c2VkIG9uIG9wZW4uICovXG4gIEBJbnB1dCgpXG4gIGdldCBhdXRvRm9jdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1dG9Gb2N1cyAmJiB0aGlzLl9hdXRvRm9jdXNPdmVycmlkZTtcbiAgfVxuICBzZXQgYXV0b0ZvY3VzKHZhbDogYm9vbGVhbikge1xuICAgIHRoaXMuX2F1dG9Gb2N1cyA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWwpO1xuICB9XG4gIHByaXZhdGUgX2F1dG9Gb2N1cyA9IHRydWU7XG4gIF9hdXRvRm9jdXNPdmVycmlkZSA9IHRydWU7XG5cbiAgLyoqIFdoZXRoZXIgdGhlIHBvcG92ZXIgc2hvdWxkIHJldHVybiBmb2N1cyB0byB0aGUgcHJldmlvdXNseSBmb2N1c2VkIGVsZW1lbnQgYWZ0ZXIgY2xvc2luZy4gKi9cbiAgQElucHV0KClcbiAgZ2V0IHJlc3RvcmVGb2N1cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzdG9yZUZvY3VzICYmIHRoaXMuX3Jlc3RvcmVGb2N1c092ZXJyaWRlO1xuICB9XG4gIHNldCByZXN0b3JlRm9jdXModmFsOiBib29sZWFuKSB7XG4gICAgdGhpcy5fcmVzdG9yZUZvY3VzID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbCk7XG4gIH1cbiAgcHJpdmF0ZSBfcmVzdG9yZUZvY3VzID0gdHJ1ZTtcbiAgX3Jlc3RvcmVGb2N1c092ZXJyaWRlID0gdHJ1ZTtcblxuICAvKiogSG93IHRoZSBwb3BvdmVyIHNob3VsZCBoYW5kbGUgc2Nyb2xsaW5nLiAqL1xuICBASW5wdXQoKVxuICBnZXQgc2Nyb2xsU3RyYXRlZ3koKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Njcm9sbFN0cmF0ZWd5O1xuICB9XG4gIHNldCBzY3JvbGxTdHJhdGVneSh2YWw6IFNhdFBvcG92ZXJTY3JvbGxTdHJhdGVneSkge1xuICAgIHRoaXMuX3ZhbGlkYXRlU2Nyb2xsU3RyYXRlZ3kodmFsKTtcbiAgICBpZiAodGhpcy5fc2Nyb2xsU3RyYXRlZ3kgIT09IHZhbCkge1xuICAgICAgdGhpcy5fc2Nyb2xsU3RyYXRlZ3kgPSB2YWw7XG4gICAgICB0aGlzLl9hbmNob3JpbmdTZXJ2aWNlLnVwZGF0ZVBvcG92ZXJDb25maWcoKTtcbiAgICB9XG4gIH1cbiAgcHJpdmF0ZSBfc2Nyb2xsU3RyYXRlZ3k6IFNhdFBvcG92ZXJTY3JvbGxTdHJhdGVneSA9ICdyZXBvc2l0aW9uJztcblxuICAvKiogV2hldGhlciB0aGUgcG9wb3ZlciBzaG91bGQgaGF2ZSBhIGJhY2tkcm9wIChpbmNsdWRlcyBjbG9zaW5nIG9uIGNsaWNrKS4gKi9cbiAgQElucHV0KClcbiAgZ2V0IGhhc0JhY2tkcm9wKCkge1xuICAgIHJldHVybiB0aGlzLl9oYXNCYWNrZHJvcDtcbiAgfVxuICBzZXQgaGFzQmFja2Ryb3AodmFsOiBib29sZWFuKSB7XG4gICAgdGhpcy5faGFzQmFja2Ryb3AgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsKTtcbiAgfVxuICBwcml2YXRlIF9oYXNCYWNrZHJvcCA9IGZhbHNlO1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIHNob3VsZCBjbG9zZSB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgYmFja2Ryb3Agb3IgcHJlc3NlcyBFU0MuICovXG4gIEBJbnB1dCgpXG4gIGdldCBpbnRlcmFjdGl2ZUNsb3NlKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnRlcmFjdGl2ZUNsb3NlO1xuICB9XG4gIHNldCBpbnRlcmFjdGl2ZUNsb3NlKHZhbDogYm9vbGVhbikge1xuICAgIHRoaXMuX2ludGVyYWN0aXZlQ2xvc2UgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsKTtcbiAgfVxuICBwcml2YXRlIF9pbnRlcmFjdGl2ZUNsb3NlID0gdHJ1ZTtcblxuICAvKiogQ3VzdG9tIHRyYW5zaXRpb24gdG8gdXNlIHdoaWxlIG9wZW5pbmcuICovXG4gIEBJbnB1dCgpXG4gIGdldCBvcGVuVHJhbnNpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fb3BlblRyYW5zaXRpb247XG4gIH1cbiAgc2V0IG9wZW5UcmFuc2l0aW9uKHZhbDogc3RyaW5nKSB7XG4gICAgaWYgKHZhbCkge1xuICAgICAgdGhpcy5fb3BlblRyYW5zaXRpb24gPSB2YWw7XG4gICAgfVxuICB9XG4gIHByaXZhdGUgX29wZW5UcmFuc2l0aW9uID0gREVGQVVMVF9UUkFOU0lUSU9OO1xuXG4gIC8qKiBDdXN0b20gdHJhbnNpdGlvbiB0byB1c2Ugd2hpbGUgY2xvc2luZy4gKi9cbiAgQElucHV0KClcbiAgZ2V0IGNsb3NlVHJhbnNpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xvc2VUcmFuc2l0aW9uO1xuICB9XG4gIHNldCBjbG9zZVRyYW5zaXRpb24odmFsOiBzdHJpbmcpIHtcbiAgICBpZiAodmFsKSB7XG4gICAgICB0aGlzLl9jbG9zZVRyYW5zaXRpb24gPSB2YWw7XG4gICAgfVxuICB9XG4gIHByaXZhdGUgX2Nsb3NlVHJhbnNpdGlvbiA9IERFRkFVTFRfVFJBTlNJVElPTjtcblxuICAvKiogT3B0aW9uYWwgYmFja2Ryb3AgY2xhc3MuICovXG4gIEBJbnB1dCgpIGJhY2tkcm9wQ2xhc3MgPSAnJztcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgcG9wb3ZlciBpcyBvcGVuZWQuICovXG4gIEBPdXRwdXQoKSBvcGVuZWQgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgLyoqIEVtaXRzIHdoZW4gdGhlIHBvcG92ZXIgaXMgY2xvc2VkLiAqL1xuICBAT3V0cHV0KCkgY2xvc2VkID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqIEVtaXRzIHdoZW4gdGhlIHBvcG92ZXIgaGFzIGZpbmlzaGVkIG9wZW5pbmcuICovXG4gIEBPdXRwdXQoKSBhZnRlck9wZW4gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgLyoqIEVtaXRzIHdoZW4gdGhlIHBvcG92ZXIgaGFzIGZpbmlzaGVkIGNsb3NpbmcuICovXG4gIEBPdXRwdXQoKSBhZnRlckNsb3NlID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSBiYWNrZHJvcCBpcyBjbGlja2VkLiAqL1xuICBAT3V0cHV0KCkgYmFja2Ryb3BDbGlja2VkID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gIC8qKiBFbWl0cyB3aGVuIGEga2V5ZG93biBldmVudCBpcyB0YXJnZXRlZCB0byB0aGlzIHBvcG92ZXIncyBvdmVybGF5LiAqL1xuICBAT3V0cHV0KCkgb3ZlcmxheUtleWRvd24gPSBuZXcgRXZlbnRFbWl0dGVyPEtleWJvYXJkRXZlbnQ+KCk7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0ZW1wbGF0ZSBzbyBpdCBjYW4gYmUgcGxhY2VkIHdpdGhpbiBhIHBvcnRhbC4gKi9cbiAgQFZpZXdDaGlsZChUZW1wbGF0ZVJlZiwgeyBzdGF0aWM6IHRydWUgfSkgX3RlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gIC8qKiBDbGFzc2VzIHRvIGJlIGFkZGVkIHRvIHRoZSBwb3BvdmVyIGZvciBzZXR0aW5nIHRoZSBjb3JyZWN0IHRyYW5zZm9ybSBvcmlnaW4uICovXG4gIF9jbGFzc0xpc3Q6IGFueSA9IHt9O1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIGlzIHByZXNlbnRseSBvcGVuLiAqL1xuICBfb3BlbiA9IGZhbHNlO1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FuY2hvcmluZ1NlcnZpY2U6IFNhdFBvcG92ZXJBbmNob3JpbmdTZXJ2aWNlO1xuXG4gIC8qKiBSZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgdG8gYnVpbGQgYSBmb2N1cyB0cmFwIGFyb3VuZC4gKi9cbiAgQFZpZXdDaGlsZCgnZm9jdXNUcmFwRWxlbWVudCcsIHsgc3RhdGljOiBmYWxzZSB9KVxuICBwcml2YXRlIF9mb2N1c1RyYXBFbGVtZW50OiBFbGVtZW50UmVmO1xuXG4gIC8qKiBSZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgdGhhdCB3YXMgZm9jdXNlZCBiZWZvcmUgb3BlbmluZy4gKi9cbiAgcHJpdmF0ZSBfcHJldmlvdXNseUZvY3VzZWRFbGVtZW50OiBIVE1MRWxlbWVudDtcblxuICAvKiogUmVmZXJlbmNlIHRvIGEgZm9jdXMgdHJhcCBhcm91bmQgdGhlIHBvcG92ZXIuICovXG4gIHByaXZhdGUgX2ZvY3VzVHJhcDogRm9jdXNUcmFwO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgX2ZvY3VzVHJhcEZhY3Rvcnk6IEZvY3VzVHJhcEZhY3RvcnksXG4gICAgX2FuY2hvcmluZ1NlcnZpY2U6IFNhdFBvcG92ZXJBbmNob3JpbmdTZXJ2aWNlLFxuICAgIHByaXZhdGUgX3ZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChET0NVTUVOVCkgcHJpdmF0ZSBfZG9jdW1lbnQ6IGFueVxuICApIHtcbiAgICAvLyBgQGludGVybmFsYCBzdHJpcHBpbmcgZG9lc24ndCBzZWVtIHRvIHdvcmsgaWYgdGhlIHByb3BlcnR5IGlzXG4gICAgLy8gZGVjbGFyZWQgaW5zaWRlIHRoZSBjb25zdHJ1Y3RvclxuICAgIHRoaXMuX2FuY2hvcmluZ1NlcnZpY2UgPSBfYW5jaG9yaW5nU2VydmljZTtcbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuX3NldEFsaWdubWVudENsYXNzZXMoKTtcbiAgfVxuXG4gIC8qKiBPcGVuIHRoaXMgcG9wb3Zlci4gKi9cbiAgb3BlbihvcHRpb25zOiBTYXRQb3BvdmVyT3Blbk9wdGlvbnMgPSB7fSk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9hbmNob3IpIHtcbiAgICAgIHRoaXMuX2FuY2hvcmluZ1NlcnZpY2Uub3BlblBvcG92ZXIob3B0aW9ucyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhyb3cgZ2V0VW5hbmNob3JlZFBvcG92ZXJFcnJvcigpO1xuICB9XG5cbiAgLyoqIENsb3NlIHRoaXMgcG9wb3Zlci4gKi9cbiAgY2xvc2UodmFsdWU/OiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLl9hbmNob3JpbmdTZXJ2aWNlLmNsb3NlUG9wb3Zlcih2YWx1ZSk7XG4gIH1cblxuICAvKiogVG9nZ2xlIHRoaXMgcG9wb3ZlciBvcGVuIG9yIGNsb3NlZC4gKi9cbiAgdG9nZ2xlKCk6IHZvaWQge1xuICAgIHRoaXMuX2FuY2hvcmluZ1NlcnZpY2UudG9nZ2xlUG9wb3ZlcigpO1xuICB9XG5cbiAgLyoqIFJlYWxpZ24gdGhlIHBvcG92ZXIgdG8gdGhlIGFuY2hvci4gKi9cbiAgcmVhbGlnbigpOiB2b2lkIHtcbiAgICB0aGlzLl9hbmNob3JpbmdTZXJ2aWNlLnJlYWxpZ25Qb3BvdmVyVG9BbmNob3IoKTtcbiAgfVxuXG4gIC8qKiBHZXRzIHdoZXRoZXIgdGhlIHBvcG92ZXIgaXMgcHJlc2VudGx5IG9wZW4uICovXG4gIGlzT3BlbigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fb3BlbjtcbiAgfVxuXG4gIC8qKiBBbGxvd3MgcHJvZ3JhbW1hdGljYWxseSBzZXR0aW5nIGEgY3VzdG9tIGFuY2hvci4gKi9cbiAgc2V0Q3VzdG9tQW5jaG9yKHZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWYsIGVsOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PiB8IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgdGhpcy5fYW5jaG9yID0gZWw7XG4gICAgdGhpcy5fYW5jaG9yaW5nU2VydmljZS5hbmNob3IodGhpcywgdmlld0NvbnRhaW5lciwgZWwpO1xuICB9XG5cbiAgLyoqIEdldHMgYW4gYW5pbWF0aW9uIGNvbmZpZyB3aXRoIGN1c3RvbWl6ZWQgKG9yIGRlZmF1bHQpIHRyYW5zaXRpb24gdmFsdWVzLiAqL1xuICBfZ2V0QW5pbWF0aW9uKCk6IHsgdmFsdWU6IGFueTsgcGFyYW1zOiBhbnkgfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiAndmlzaWJsZScsXG4gICAgICBwYXJhbXM6IHsgb3BlblRyYW5zaXRpb246IHRoaXMub3BlblRyYW5zaXRpb24sIGNsb3NlVHJhbnNpdGlvbjogdGhpcy5jbG9zZVRyYW5zaXRpb24gfVxuICAgIH07XG4gIH1cblxuICAvKiogQ2FsbGJhY2sgZm9yIHdoZW4gdGhlIHBvcG92ZXIgaXMgZmluaXNoZWQgYW5pbWF0aW5nIGluIG9yIG91dC4gKi9cbiAgX29uQW5pbWF0aW9uRG9uZShldmVudDogQW5pbWF0aW9uRXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudG9TdGF0ZSA9PT0gJ3Zpc2libGUnKSB7XG4gICAgICB0aGlzLl90cmFwRm9jdXMoKTtcbiAgICAgIHRoaXMuYWZ0ZXJPcGVuLmVtaXQoKTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LnRvU3RhdGUgPT09ICd2b2lkJykge1xuICAgICAgdGhpcy5fcmVzdG9yZUZvY3VzQW5kRGVzdHJveVRyYXAoKTtcbiAgICAgIHRoaXMuYWZ0ZXJDbG9zZS5lbWl0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEFwcGx5IGFsaWdubWVudCBjbGFzc2VzIGJhc2VkIG9uIGFsaWdubWVudCBpbnB1dHMuICovXG4gIF9zZXRBbGlnbm1lbnRDbGFzc2VzKGhvcml6QWxpZ24gPSB0aGlzLmhvcml6b250YWxBbGlnbiwgdmVydEFsaWduID0gdGhpcy52ZXJ0aWNhbEFsaWduKSB7XG4gICAgdGhpcy5fY2xhc3NMaXN0WydzYXQtcG9wb3Zlci1iZWZvcmUnXSA9IGhvcml6QWxpZ24gPT09ICdiZWZvcmUnIHx8IGhvcml6QWxpZ24gPT09ICdlbmQnO1xuICAgIHRoaXMuX2NsYXNzTGlzdFsnc2F0LXBvcG92ZXItYWZ0ZXInXSA9IGhvcml6QWxpZ24gPT09ICdhZnRlcicgfHwgaG9yaXpBbGlnbiA9PT0gJ3N0YXJ0JztcblxuICAgIHRoaXMuX2NsYXNzTGlzdFsnc2F0LXBvcG92ZXItYWJvdmUnXSA9IHZlcnRBbGlnbiA9PT0gJ2Fib3ZlJyB8fCB2ZXJ0QWxpZ24gPT09ICdlbmQnO1xuICAgIHRoaXMuX2NsYXNzTGlzdFsnc2F0LXBvcG92ZXItYmVsb3cnXSA9IHZlcnRBbGlnbiA9PT0gJ2JlbG93JyB8fCB2ZXJ0QWxpZ24gPT09ICdzdGFydCc7XG5cbiAgICB0aGlzLl9jbGFzc0xpc3RbJ3NhdC1wb3BvdmVyLWNlbnRlciddID0gaG9yaXpBbGlnbiA9PT0gJ2NlbnRlcicgfHwgdmVydEFsaWduID09PSAnY2VudGVyJztcbiAgfVxuXG4gIC8qKiBNb3ZlIHRoZSBmb2N1cyBpbnNpZGUgdGhlIGZvY3VzIHRyYXAgYW5kIHJlbWVtYmVyIHdoZXJlIHRvIHJldHVybiBsYXRlci4gKi9cbiAgcHJpdmF0ZSBfdHJhcEZvY3VzKCk6IHZvaWQge1xuICAgIHRoaXMuX3NhdmVQcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQoKTtcblxuICAgIC8vIFRoZXJlIHdvbid0IGJlIGEgZm9jdXMgdHJhcCBlbGVtZW50IGlmIHRoZSBjbG9zZSBhbmltYXRpb24gc3RhcnRzIGJlZm9yZSBvcGVuIGZpbmlzaGVzXG4gICAgaWYgKCF0aGlzLl9mb2N1c1RyYXBFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9mb2N1c1RyYXAgJiYgdGhpcy5fZm9jdXNUcmFwRWxlbWVudCkge1xuICAgICAgdGhpcy5fZm9jdXNUcmFwID0gdGhpcy5fZm9jdXNUcmFwRmFjdG9yeS5jcmVhdGUodGhpcy5fZm9jdXNUcmFwRWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hdXRvRm9jdXMpIHtcbiAgICAgIHRoaXMuX2ZvY3VzVHJhcC5mb2N1c0luaXRpYWxFbGVtZW50V2hlblJlYWR5KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFJlc3RvcmUgZm9jdXMgdG8gdGhlIGVsZW1lbnQgZm9jdXNlZCBiZWZvcmUgdGhlIHBvcG92ZXIgb3BlbmVkLiBBbHNvIGRlc3Ryb3kgdHJhcC4gKi9cbiAgcHJpdmF0ZSBfcmVzdG9yZUZvY3VzQW5kRGVzdHJveVRyYXAoKTogdm9pZCB7XG4gICAgY29uc3QgdG9Gb2N1cyA9IHRoaXMuX3ByZXZpb3VzbHlGb2N1c2VkRWxlbWVudDtcblxuICAgIC8vIE11c3QgY2hlY2sgYWN0aXZlIGVsZW1lbnQgaXMgZm9jdXNhYmxlIGZvciBJRSBzYWtlXG4gICAgaWYgKHRvRm9jdXMgJiYgJ2ZvY3VzJyBpbiB0b0ZvY3VzICYmIHRoaXMucmVzdG9yZUZvY3VzKSB7XG4gICAgICB0aGlzLl9wcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQuZm9jdXMoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuX2ZvY3VzVHJhcCkge1xuICAgICAgdGhpcy5fZm9jdXNUcmFwLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX2ZvY3VzVHJhcCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvKiogU2F2ZSBhIHJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCBmb2N1c2VkIGJlZm9yZSB0aGUgcG9wb3ZlciB3YXMgb3BlbmVkLiAqL1xuICBwcml2YXRlIF9zYXZlUHJldmlvdXNseUZvY3VzZWRFbGVtZW50KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9kb2N1bWVudCkge1xuICAgICAgdGhpcy5fcHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID0gdGhpcy5fZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBhcyBIVE1MRWxlbWVudDtcbiAgICB9XG4gIH1cblxuICAvKiogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBhbGlnbm1lbnQgaXMgbm90IGEgdmFsaWQgaG9yaXpvbnRhbEFsaWduLiAqL1xuICBwcml2YXRlIF92YWxpZGF0ZUhvcml6b250YWxBbGlnbihwb3M6IFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ24pOiB2b2lkIHtcbiAgICBpZiAoVkFMSURfSE9SSVpfQUxJR04uaW5kZXhPZihwb3MpID09PSAtMSkge1xuICAgICAgdGhyb3cgZ2V0SW52YWxpZEhvcml6b250YWxBbGlnbkVycm9yKHBvcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgYWxpZ25tZW50IGlzIG5vdCBhIHZhbGlkIHZlcnRpY2FsQWxpZ24uICovXG4gIHByaXZhdGUgX3ZhbGlkYXRlVmVydGljYWxBbGlnbihwb3M6IFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduKTogdm9pZCB7XG4gICAgaWYgKFZBTElEX1ZFUlRfQUxJR04uaW5kZXhPZihwb3MpID09PSAtMSkge1xuICAgICAgdGhyb3cgZ2V0SW52YWxpZFZlcnRpY2FsQWxpZ25FcnJvcihwb3MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHNjcm9sbCBzdHJhdGVneSBpcyBub3QgYSB2YWxpZCBzdHJhdGVneS4gKi9cbiAgcHJpdmF0ZSBfdmFsaWRhdGVTY3JvbGxTdHJhdGVneShzdHJhdGVneTogU2F0UG9wb3ZlclNjcm9sbFN0cmF0ZWd5KTogdm9pZCB7XG4gICAgaWYgKFZBTElEX1NDUk9MTC5pbmRleE9mKHN0cmF0ZWd5KSA9PT0gLTEpIHtcbiAgICAgIHRocm93IGdldEludmFsaWRTY3JvbGxTdHJhdGVneUVycm9yKHN0cmF0ZWd5KTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==