import { ElementRef, EventEmitter, TemplateRef, OnInit, ViewContainerRef, AfterViewInit } from '@angular/core';
import { AnimationEvent } from '@angular/animations';
import { FocusTrapFactory } from '@angular/cdk/a11y';
import { SatPopoverScrollStrategy, SatPopoverHorizontalAlign, SatPopoverVerticalAlign, SatPopoverOpenOptions } from './types';
import { SatPopoverAnchoringService } from './popover-anchoring.service';
import * as ɵngcc0 from '@angular/core';
export declare class SatPopoverAnchor implements AfterViewInit {
    elementRef: ElementRef;
    viewContainerRef: ViewContainerRef;
    popover: SatPopover;
    constructor(elementRef: ElementRef, viewContainerRef: ViewContainerRef);
    ngAfterViewInit(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<SatPopoverAnchor>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<SatPopoverAnchor, "[satPopoverAnchor]", ["satPopoverAnchor"], {
    "popover": "satPopoverAnchor";
}, {}, never>;
}
export declare class SatPopover implements OnInit {
    private _focusTrapFactory;
    private _viewContainerRef;
    private _document;
    /** Anchor element. */
    anchor: SatPopoverAnchor | ElementRef<HTMLElement> | HTMLElement;
    private _anchor;
    /** Alignment of the popover on the horizontal axis. */
    horizontalAlign: SatPopoverHorizontalAlign;
    private _horizontalAlign;
    /** Alignment of the popover on the x axis. Alias for `horizontalAlign`. */
    xAlign: SatPopoverHorizontalAlign;
    /** Alignment of the popover on the vertical axis. */
    verticalAlign: SatPopoverVerticalAlign;
    private _verticalAlign;
    /** Alignment of the popover on the y axis. Alias for `verticalAlign`. */
    yAlign: SatPopoverVerticalAlign;
    /** Whether the popover always opens with the specified alignment. */
    forceAlignment: boolean;
    private _forceAlignment;
    /**
     * Whether the popover's alignment is locked after opening. This prevents the popover
     * from changing its alignement when scrolling or changing the size of the viewport.
     */
    lockAlignment: boolean;
    private _lockAlignment;
    /** Whether the first focusable element should be focused on open. */
    autoFocus: boolean;
    private _autoFocus;
    _autoFocusOverride: boolean;
    /** Whether the popover should return focus to the previously focused element after closing. */
    restoreFocus: boolean;
    private _restoreFocus;
    _restoreFocusOverride: boolean;
    /** How the popover should handle scrolling. */
    scrollStrategy: SatPopoverScrollStrategy;
    private _scrollStrategy;
    /** Whether the popover should have a backdrop (includes closing on click). */
    hasBackdrop: boolean;
    private _hasBackdrop;
    /** Whether the popover should close when the user clicks the backdrop or presses ESC. */
    interactiveClose: boolean;
    private _interactiveClose;
    /** Custom transition to use while opening. */
    openTransition: string;
    private _openTransition;
    /** Custom transition to use while closing. */
    closeTransition: string;
    private _closeTransition;
    /** Optional backdrop class. */
    backdropClass: string;
    /** Emits when the popover is opened. */
    opened: EventEmitter<void>;
    /** Emits when the popover is closed. */
    closed: EventEmitter<any>;
    /** Emits when the popover has finished opening. */
    afterOpen: EventEmitter<void>;
    /** Emits when the popover has finished closing. */
    afterClose: EventEmitter<void>;
    /** Emits when the backdrop is clicked. */
    backdropClicked: EventEmitter<void>;
    /** Emits when a keydown event is targeted to this popover's overlay. */
    overlayKeydown: EventEmitter<KeyboardEvent>;
    /** Reference to template so it can be placed within a portal. */
    _templateRef: TemplateRef<any>;
    /** Classes to be added to the popover for setting the correct transform origin. */
    _classList: any;
    /** Whether the popover is presently open. */
    _open: boolean;
    /** Reference to the element to build a focus trap around. */
    private _focusTrapElement;
    /** Reference to the element that was focused before opening. */
    private _previouslyFocusedElement;
    /** Reference to a focus trap around the popover. */
    private _focusTrap;
    constructor(_focusTrapFactory: FocusTrapFactory, _anchoringService: SatPopoverAnchoringService, _viewContainerRef: ViewContainerRef, _document: any);
    ngOnInit(): void;
    /** Open this popover. */
    open(options?: SatPopoverOpenOptions): void;
    /** Close this popover. */
    close(value?: any): void;
    /** Toggle this popover open or closed. */
    toggle(): void;
    /** Realign the popover to the anchor. */
    realign(): void;
    /** Gets whether the popover is presently open. */
    isOpen(): boolean;
    /** Allows programmatically setting a custom anchor. */
    setCustomAnchor(viewContainer: ViewContainerRef, el: ElementRef<HTMLElement> | HTMLElement): void;
    /** Gets an animation config with customized (or default) transition values. */
    _getAnimation(): {
        value: any;
        params: any;
    };
    /** Callback for when the popover is finished animating in or out. */
    _onAnimationDone(event: AnimationEvent): void;
    /** Apply alignment classes based on alignment inputs. */
    _setAlignmentClasses(horizAlign?: SatPopoverHorizontalAlign, vertAlign?: SatPopoverVerticalAlign): void;
    /** Move the focus inside the focus trap and remember where to return later. */
    private _trapFocus;
    /** Restore focus to the element focused before the popover opened. Also destroy trap. */
    private _restoreFocusAndDestroyTrap;
    /** Save a reference to the element focused before the popover was opened. */
    private _savePreviouslyFocusedElement;
    /** Throws an error if the alignment is not a valid horizontalAlign. */
    private _validateHorizontalAlign;
    /** Throws an error if the alignment is not a valid verticalAlign. */
    private _validateVerticalAlign;
    /** Throws an error if the scroll strategy is not a valid strategy. */
    private _validateScrollStrategy;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<SatPopover>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<SatPopover, "sat-popover", never, {
    "backdropClass": "backdropClass";
    "anchor": "anchor";
    "horizontalAlign": "horizontalAlign";
    "xAlign": "xAlign";
    "verticalAlign": "verticalAlign";
    "yAlign": "yAlign";
    "forceAlignment": "forceAlignment";
    "lockAlignment": "lockAlignment";
    "autoFocus": "autoFocus";
    "restoreFocus": "restoreFocus";
    "scrollStrategy": "scrollStrategy";
    "hasBackdrop": "hasBackdrop";
    "interactiveClose": "interactiveClose";
    "openTransition": "openTransition";
    "closeTransition": "closeTransition";
}, {
    "opened": "opened";
    "closed": "closed";
    "afterOpen": "afterOpen";
    "afterClose": "afterClose";
    "backdropClicked": "backdropClicked";
    "overlayKeydown": "overlayKeydown";
}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci5jb21wb25lbnQuZC50cyIsInNvdXJjZXMiOlsicG9wb3Zlci5jb21wb25lbnQuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0FBS0E7Ozs7Ozs7Ozs7QUFNQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStHQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgVGVtcGxhdGVSZWYsIE9uSW5pdCwgVmlld0NvbnRhaW5lclJlZiwgQWZ0ZXJWaWV3SW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQW5pbWF0aW9uRXZlbnQgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IEZvY3VzVHJhcEZhY3RvcnkgfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XG5pbXBvcnQgeyBTYXRQb3BvdmVyU2Nyb2xsU3RyYXRlZ3ksIFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ24sIFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduLCBTYXRQb3BvdmVyT3Blbk9wdGlvbnMgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IFNhdFBvcG92ZXJBbmNob3JpbmdTZXJ2aWNlIH0gZnJvbSAnLi9wb3BvdmVyLWFuY2hvcmluZy5zZXJ2aWNlJztcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIFNhdFBvcG92ZXJBbmNob3IgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcbiAgICBlbGVtZW50UmVmOiBFbGVtZW50UmVmO1xuICAgIHZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWY7XG4gICAgcG9wb3ZlcjogU2F0UG9wb3ZlcjtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCB2aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmKTtcbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZDtcbn1cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIFNhdFBvcG92ZXIgaW1wbGVtZW50cyBPbkluaXQge1xuICAgIHByaXZhdGUgX2ZvY3VzVHJhcEZhY3Rvcnk7XG4gICAgcHJpdmF0ZSBfdmlld0NvbnRhaW5lclJlZjtcbiAgICBwcml2YXRlIF9kb2N1bWVudDtcbiAgICAvKiogQW5jaG9yIGVsZW1lbnQuICovXG4gICAgYW5jaG9yOiBTYXRQb3BvdmVyQW5jaG9yIHwgRWxlbWVudFJlZjxIVE1MRWxlbWVudD4gfCBIVE1MRWxlbWVudDtcbiAgICBwcml2YXRlIF9hbmNob3I7XG4gICAgLyoqIEFsaWdubWVudCBvZiB0aGUgcG9wb3ZlciBvbiB0aGUgaG9yaXpvbnRhbCBheGlzLiAqL1xuICAgIGhvcml6b250YWxBbGlnbjogU2F0UG9wb3Zlckhvcml6b250YWxBbGlnbjtcbiAgICBwcml2YXRlIF9ob3Jpem9udGFsQWxpZ247XG4gICAgLyoqIEFsaWdubWVudCBvZiB0aGUgcG9wb3ZlciBvbiB0aGUgeCBheGlzLiBBbGlhcyBmb3IgYGhvcml6b250YWxBbGlnbmAuICovXG4gICAgeEFsaWduOiBTYXRQb3BvdmVySG9yaXpvbnRhbEFsaWduO1xuICAgIC8qKiBBbGlnbm1lbnQgb2YgdGhlIHBvcG92ZXIgb24gdGhlIHZlcnRpY2FsIGF4aXMuICovXG4gICAgdmVydGljYWxBbGlnbjogU2F0UG9wb3ZlclZlcnRpY2FsQWxpZ247XG4gICAgcHJpdmF0ZSBfdmVydGljYWxBbGlnbjtcbiAgICAvKiogQWxpZ25tZW50IG9mIHRoZSBwb3BvdmVyIG9uIHRoZSB5IGF4aXMuIEFsaWFzIGZvciBgdmVydGljYWxBbGlnbmAuICovXG4gICAgeUFsaWduOiBTYXRQb3BvdmVyVmVydGljYWxBbGlnbjtcbiAgICAvKiogV2hldGhlciB0aGUgcG9wb3ZlciBhbHdheXMgb3BlbnMgd2l0aCB0aGUgc3BlY2lmaWVkIGFsaWdubWVudC4gKi9cbiAgICBmb3JjZUFsaWdubWVudDogYm9vbGVhbjtcbiAgICBwcml2YXRlIF9mb3JjZUFsaWdubWVudDtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBwb3BvdmVyJ3MgYWxpZ25tZW50IGlzIGxvY2tlZCBhZnRlciBvcGVuaW5nLiBUaGlzIHByZXZlbnRzIHRoZSBwb3BvdmVyXG4gICAgICogZnJvbSBjaGFuZ2luZyBpdHMgYWxpZ25lbWVudCB3aGVuIHNjcm9sbGluZyBvciBjaGFuZ2luZyB0aGUgc2l6ZSBvZiB0aGUgdmlld3BvcnQuXG4gICAgICovXG4gICAgbG9ja0FsaWdubWVudDogYm9vbGVhbjtcbiAgICBwcml2YXRlIF9sb2NrQWxpZ25tZW50O1xuICAgIC8qKiBXaGV0aGVyIHRoZSBmaXJzdCBmb2N1c2FibGUgZWxlbWVudCBzaG91bGQgYmUgZm9jdXNlZCBvbiBvcGVuLiAqL1xuICAgIGF1dG9Gb2N1czogYm9vbGVhbjtcbiAgICBwcml2YXRlIF9hdXRvRm9jdXM7XG4gICAgX2F1dG9Gb2N1c092ZXJyaWRlOiBib29sZWFuO1xuICAgIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIHNob3VsZCByZXR1cm4gZm9jdXMgdG8gdGhlIHByZXZpb3VzbHkgZm9jdXNlZCBlbGVtZW50IGFmdGVyIGNsb3NpbmcuICovXG4gICAgcmVzdG9yZUZvY3VzOiBib29sZWFuO1xuICAgIHByaXZhdGUgX3Jlc3RvcmVGb2N1cztcbiAgICBfcmVzdG9yZUZvY3VzT3ZlcnJpZGU6IGJvb2xlYW47XG4gICAgLyoqIEhvdyB0aGUgcG9wb3ZlciBzaG91bGQgaGFuZGxlIHNjcm9sbGluZy4gKi9cbiAgICBzY3JvbGxTdHJhdGVneTogU2F0UG9wb3ZlclNjcm9sbFN0cmF0ZWd5O1xuICAgIHByaXZhdGUgX3Njcm9sbFN0cmF0ZWd5O1xuICAgIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIHNob3VsZCBoYXZlIGEgYmFja2Ryb3AgKGluY2x1ZGVzIGNsb3Npbmcgb24gY2xpY2spLiAqL1xuICAgIGhhc0JhY2tkcm9wOiBib29sZWFuO1xuICAgIHByaXZhdGUgX2hhc0JhY2tkcm9wO1xuICAgIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIHNob3VsZCBjbG9zZSB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgYmFja2Ryb3Agb3IgcHJlc3NlcyBFU0MuICovXG4gICAgaW50ZXJhY3RpdmVDbG9zZTogYm9vbGVhbjtcbiAgICBwcml2YXRlIF9pbnRlcmFjdGl2ZUNsb3NlO1xuICAgIC8qKiBDdXN0b20gdHJhbnNpdGlvbiB0byB1c2Ugd2hpbGUgb3BlbmluZy4gKi9cbiAgICBvcGVuVHJhbnNpdGlvbjogc3RyaW5nO1xuICAgIHByaXZhdGUgX29wZW5UcmFuc2l0aW9uO1xuICAgIC8qKiBDdXN0b20gdHJhbnNpdGlvbiB0byB1c2Ugd2hpbGUgY2xvc2luZy4gKi9cbiAgICBjbG9zZVRyYW5zaXRpb246IHN0cmluZztcbiAgICBwcml2YXRlIF9jbG9zZVRyYW5zaXRpb247XG4gICAgLyoqIE9wdGlvbmFsIGJhY2tkcm9wIGNsYXNzLiAqL1xuICAgIGJhY2tkcm9wQ2xhc3M6IHN0cmluZztcbiAgICAvKiogRW1pdHMgd2hlbiB0aGUgcG9wb3ZlciBpcyBvcGVuZWQuICovXG4gICAgb3BlbmVkOiBFdmVudEVtaXR0ZXI8dm9pZD47XG4gICAgLyoqIEVtaXRzIHdoZW4gdGhlIHBvcG92ZXIgaXMgY2xvc2VkLiAqL1xuICAgIGNsb3NlZDogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgLyoqIEVtaXRzIHdoZW4gdGhlIHBvcG92ZXIgaGFzIGZpbmlzaGVkIG9wZW5pbmcuICovXG4gICAgYWZ0ZXJPcGVuOiBFdmVudEVtaXR0ZXI8dm9pZD47XG4gICAgLyoqIEVtaXRzIHdoZW4gdGhlIHBvcG92ZXIgaGFzIGZpbmlzaGVkIGNsb3NpbmcuICovXG4gICAgYWZ0ZXJDbG9zZTogRXZlbnRFbWl0dGVyPHZvaWQ+O1xuICAgIC8qKiBFbWl0cyB3aGVuIHRoZSBiYWNrZHJvcCBpcyBjbGlja2VkLiAqL1xuICAgIGJhY2tkcm9wQ2xpY2tlZDogRXZlbnRFbWl0dGVyPHZvaWQ+O1xuICAgIC8qKiBFbWl0cyB3aGVuIGEga2V5ZG93biBldmVudCBpcyB0YXJnZXRlZCB0byB0aGlzIHBvcG92ZXIncyBvdmVybGF5LiAqL1xuICAgIG92ZXJsYXlLZXlkb3duOiBFdmVudEVtaXR0ZXI8S2V5Ym9hcmRFdmVudD47XG4gICAgLyoqIFJlZmVyZW5jZSB0byB0ZW1wbGF0ZSBzbyBpdCBjYW4gYmUgcGxhY2VkIHdpdGhpbiBhIHBvcnRhbC4gKi9cbiAgICBfdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgLyoqIENsYXNzZXMgdG8gYmUgYWRkZWQgdG8gdGhlIHBvcG92ZXIgZm9yIHNldHRpbmcgdGhlIGNvcnJlY3QgdHJhbnNmb3JtIG9yaWdpbi4gKi9cbiAgICBfY2xhc3NMaXN0OiBhbnk7XG4gICAgLyoqIFdoZXRoZXIgdGhlIHBvcG92ZXIgaXMgcHJlc2VudGx5IG9wZW4uICovXG4gICAgX29wZW46IGJvb2xlYW47XG4gICAgLyoqIFJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCB0byBidWlsZCBhIGZvY3VzIHRyYXAgYXJvdW5kLiAqL1xuICAgIHByaXZhdGUgX2ZvY3VzVHJhcEVsZW1lbnQ7XG4gICAgLyoqIFJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCB0aGF0IHdhcyBmb2N1c2VkIGJlZm9yZSBvcGVuaW5nLiAqL1xuICAgIHByaXZhdGUgX3ByZXZpb3VzbHlGb2N1c2VkRWxlbWVudDtcbiAgICAvKiogUmVmZXJlbmNlIHRvIGEgZm9jdXMgdHJhcCBhcm91bmQgdGhlIHBvcG92ZXIuICovXG4gICAgcHJpdmF0ZSBfZm9jdXNUcmFwO1xuICAgIGNvbnN0cnVjdG9yKF9mb2N1c1RyYXBGYWN0b3J5OiBGb2N1c1RyYXBGYWN0b3J5LCBfYW5jaG9yaW5nU2VydmljZTogU2F0UG9wb3ZlckFuY2hvcmluZ1NlcnZpY2UsIF92aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmLCBfZG9jdW1lbnQ6IGFueSk7XG4gICAgbmdPbkluaXQoKTogdm9pZDtcbiAgICAvKiogT3BlbiB0aGlzIHBvcG92ZXIuICovXG4gICAgb3BlbihvcHRpb25zPzogU2F0UG9wb3Zlck9wZW5PcHRpb25zKTogdm9pZDtcbiAgICAvKiogQ2xvc2UgdGhpcyBwb3BvdmVyLiAqL1xuICAgIGNsb3NlKHZhbHVlPzogYW55KTogdm9pZDtcbiAgICAvKiogVG9nZ2xlIHRoaXMgcG9wb3ZlciBvcGVuIG9yIGNsb3NlZC4gKi9cbiAgICB0b2dnbGUoKTogdm9pZDtcbiAgICAvKiogUmVhbGlnbiB0aGUgcG9wb3ZlciB0byB0aGUgYW5jaG9yLiAqL1xuICAgIHJlYWxpZ24oKTogdm9pZDtcbiAgICAvKiogR2V0cyB3aGV0aGVyIHRoZSBwb3BvdmVyIGlzIHByZXNlbnRseSBvcGVuLiAqL1xuICAgIGlzT3BlbigpOiBib29sZWFuO1xuICAgIC8qKiBBbGxvd3MgcHJvZ3JhbW1hdGljYWxseSBzZXR0aW5nIGEgY3VzdG9tIGFuY2hvci4gKi9cbiAgICBzZXRDdXN0b21BbmNob3Iodmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZiwgZWw6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+IHwgSFRNTEVsZW1lbnQpOiB2b2lkO1xuICAgIC8qKiBHZXRzIGFuIGFuaW1hdGlvbiBjb25maWcgd2l0aCBjdXN0b21pemVkIChvciBkZWZhdWx0KSB0cmFuc2l0aW9uIHZhbHVlcy4gKi9cbiAgICBfZ2V0QW5pbWF0aW9uKCk6IHtcbiAgICAgICAgdmFsdWU6IGFueTtcbiAgICAgICAgcGFyYW1zOiBhbnk7XG4gICAgfTtcbiAgICAvKiogQ2FsbGJhY2sgZm9yIHdoZW4gdGhlIHBvcG92ZXIgaXMgZmluaXNoZWQgYW5pbWF0aW5nIGluIG9yIG91dC4gKi9cbiAgICBfb25BbmltYXRpb25Eb25lKGV2ZW50OiBBbmltYXRpb25FdmVudCk6IHZvaWQ7XG4gICAgLyoqIEFwcGx5IGFsaWdubWVudCBjbGFzc2VzIGJhc2VkIG9uIGFsaWdubWVudCBpbnB1dHMuICovXG4gICAgX3NldEFsaWdubWVudENsYXNzZXMoaG9yaXpBbGlnbj86IFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ24sIHZlcnRBbGlnbj86IFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduKTogdm9pZDtcbiAgICAvKiogTW92ZSB0aGUgZm9jdXMgaW5zaWRlIHRoZSBmb2N1cyB0cmFwIGFuZCByZW1lbWJlciB3aGVyZSB0byByZXR1cm4gbGF0ZXIuICovXG4gICAgcHJpdmF0ZSBfdHJhcEZvY3VzO1xuICAgIC8qKiBSZXN0b3JlIGZvY3VzIHRvIHRoZSBlbGVtZW50IGZvY3VzZWQgYmVmb3JlIHRoZSBwb3BvdmVyIG9wZW5lZC4gQWxzbyBkZXN0cm95IHRyYXAuICovXG4gICAgcHJpdmF0ZSBfcmVzdG9yZUZvY3VzQW5kRGVzdHJveVRyYXA7XG4gICAgLyoqIFNhdmUgYSByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgZm9jdXNlZCBiZWZvcmUgdGhlIHBvcG92ZXIgd2FzIG9wZW5lZC4gKi9cbiAgICBwcml2YXRlIF9zYXZlUHJldmlvdXNseUZvY3VzZWRFbGVtZW50O1xuICAgIC8qKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGFsaWdubWVudCBpcyBub3QgYSB2YWxpZCBob3Jpem9udGFsQWxpZ24uICovXG4gICAgcHJpdmF0ZSBfdmFsaWRhdGVIb3Jpem9udGFsQWxpZ247XG4gICAgLyoqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgYWxpZ25tZW50IGlzIG5vdCBhIHZhbGlkIHZlcnRpY2FsQWxpZ24uICovXG4gICAgcHJpdmF0ZSBfdmFsaWRhdGVWZXJ0aWNhbEFsaWduO1xuICAgIC8qKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHNjcm9sbCBzdHJhdGVneSBpcyBub3QgYSB2YWxpZCBzdHJhdGVneS4gKi9cbiAgICBwcml2YXRlIF92YWxpZGF0ZVNjcm9sbFN0cmF0ZWd5O1xufVxuIl19