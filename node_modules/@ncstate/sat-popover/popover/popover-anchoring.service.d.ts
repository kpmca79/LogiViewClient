import { ElementRef, NgZone, OnDestroy, ViewContainerRef } from '@angular/core';
import { Overlay, OverlayRef } from '@angular/cdk/overlay';
import { Directionality } from '@angular/cdk/bidi';
import { Subject } from 'rxjs';
import { SatPopover } from './popover.component';
import { SatPopoverOpenOptions } from './types';
import * as ɵngcc0 from '@angular/core';
export declare class SatPopoverAnchoringService implements OnDestroy {
    private _overlay;
    private _ngZone;
    private _dir;
    /** Emits when the popover is opened. */
    popoverOpened: Subject<void>;
    /** Emits when the popover is closed. */
    popoverClosed: Subject<void>;
    /** Reference to the overlay containing the popover component. */
    _overlayRef: OverlayRef;
    /** Reference to the target popover. */
    private _popover;
    /** Reference to the view container for the popover template. */
    private _viewContainerRef;
    /** Reference to the anchor element. */
    private _anchor;
    /** Reference to a template portal where the overlay will be attached. */
    private _portal;
    /** Single subscription to notifications service events. */
    private _notificationsSubscription;
    /** Single subscription to position changes. */
    private _positionChangeSubscription;
    /** Whether the popover is presently open. */
    private _popoverOpen;
    /** Emits when the service is destroyed. */
    private _onDestroy;
    constructor(_overlay: Overlay, _ngZone: NgZone, _dir: Directionality);
    ngOnDestroy(): void;
    /** Anchor a popover instance to a view and connection element. */
    anchor(popover: SatPopover, viewContainerRef: ViewContainerRef, anchor: ElementRef | HTMLElement): void;
    /** Gets whether the popover is presently open. */
    isPopoverOpen(): boolean;
    /** Toggles the popover between the open and closed states. */
    togglePopover(): void;
    /** Opens the popover. */
    openPopover(options?: SatPopoverOpenOptions): void;
    /** Closes the popover. */
    closePopover(value?: any): void;
    /** TODO: implement when the overlay's position can be dynamically changed */
    repositionPopover(): void;
    /** TODO: when the overlay's position can be dynamically changed, do not destroy */
    updatePopoverConfig(): void;
    /** Realign the popover to the anchor. */
    realignPopoverToAnchor(): void;
    /** Get a reference to the anchor element. */
    getAnchorElement(): HTMLElement;
    /** Apply behavior properties on the popover based on the open options. */
    private _applyOpenOptions;
    /** Create an overlay to be attached to the portal. */
    private _createOverlay;
    /** Removes the popover from the DOM. Does NOT update open state. */
    private _destroyPopover;
    /**
     * Destroys the popover immediately if it is closed, or waits until it
     * has been closed to destroy it.
     */
    private _destroyPopoverOnceClosed;
    /** Close popover when backdrop is clicked. */
    private _subscribeToBackdrop;
    /** Close popover when escape keydown event occurs. */
    private _subscribeToEscape;
    /** Set state back to closed when detached. */
    private _subscribeToDetachments;
    /** Save the opened state of the popover and emit. */
    private _saveOpenedState;
    /** Save the closed state of the popover and emit. */
    private _saveClosedState;
    /** Gets the text direction of the containing app. */
    private _getDirection;
    /** Create and return a config for creating the overlay. */
    private _getOverlayConfig;
    /**
     * Listen to changes in the position of the overlay and set the correct alignment classes,
     * ensuring that the animation origin is correct, even with a fallback position.
     */
    private _subscribeToPositionChanges;
    /** Map a scroll strategy string type to an instance of a scroll strategy. */
    private _getScrollStrategyInstance;
    /** Create and return a position strategy based on config provided to the component instance. */
    private _getPositionStrategy;
    /** Get fallback positions based around target alignments. */
    private _getFallbacks;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<SatPopoverAnchoringService>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<SatPopoverAnchoringService>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci1hbmNob3Jpbmcuc2VydmljZS5kLnRzIiwic291cmNlcyI6WyJwb3BvdmVyLWFuY2hvcmluZy5zZXJ2aWNlLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7QUFNQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0ZBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRWxlbWVudFJlZiwgTmdab25lLCBPbkRlc3Ryb3ksIFZpZXdDb250YWluZXJSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE92ZXJsYXksIE92ZXJsYXlSZWYgfSBmcm9tICdAYW5ndWxhci9jZGsvb3ZlcmxheSc7XG5pbXBvcnQgeyBEaXJlY3Rpb25hbGl0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9iaWRpJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFNhdFBvcG92ZXIgfSBmcm9tICcuL3BvcG92ZXIuY29tcG9uZW50JztcbmltcG9ydCB7IFNhdFBvcG92ZXJPcGVuT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgU2F0UG9wb3ZlckFuY2hvcmluZ1NlcnZpY2UgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICAgIHByaXZhdGUgX292ZXJsYXk7XG4gICAgcHJpdmF0ZSBfbmdab25lO1xuICAgIHByaXZhdGUgX2RpcjtcbiAgICAvKiogRW1pdHMgd2hlbiB0aGUgcG9wb3ZlciBpcyBvcGVuZWQuICovXG4gICAgcG9wb3Zlck9wZW5lZDogU3ViamVjdDx2b2lkPjtcbiAgICAvKiogRW1pdHMgd2hlbiB0aGUgcG9wb3ZlciBpcyBjbG9zZWQuICovXG4gICAgcG9wb3ZlckNsb3NlZDogU3ViamVjdDx2b2lkPjtcbiAgICAvKiogUmVmZXJlbmNlIHRvIHRoZSBvdmVybGF5IGNvbnRhaW5pbmcgdGhlIHBvcG92ZXIgY29tcG9uZW50LiAqL1xuICAgIF9vdmVybGF5UmVmOiBPdmVybGF5UmVmO1xuICAgIC8qKiBSZWZlcmVuY2UgdG8gdGhlIHRhcmdldCBwb3BvdmVyLiAqL1xuICAgIHByaXZhdGUgX3BvcG92ZXI7XG4gICAgLyoqIFJlZmVyZW5jZSB0byB0aGUgdmlldyBjb250YWluZXIgZm9yIHRoZSBwb3BvdmVyIHRlbXBsYXRlLiAqL1xuICAgIHByaXZhdGUgX3ZpZXdDb250YWluZXJSZWY7XG4gICAgLyoqIFJlZmVyZW5jZSB0byB0aGUgYW5jaG9yIGVsZW1lbnQuICovXG4gICAgcHJpdmF0ZSBfYW5jaG9yO1xuICAgIC8qKiBSZWZlcmVuY2UgdG8gYSB0ZW1wbGF0ZSBwb3J0YWwgd2hlcmUgdGhlIG92ZXJsYXkgd2lsbCBiZSBhdHRhY2hlZC4gKi9cbiAgICBwcml2YXRlIF9wb3J0YWw7XG4gICAgLyoqIFNpbmdsZSBzdWJzY3JpcHRpb24gdG8gbm90aWZpY2F0aW9ucyBzZXJ2aWNlIGV2ZW50cy4gKi9cbiAgICBwcml2YXRlIF9ub3RpZmljYXRpb25zU3Vic2NyaXB0aW9uO1xuICAgIC8qKiBTaW5nbGUgc3Vic2NyaXB0aW9uIHRvIHBvc2l0aW9uIGNoYW5nZXMuICovXG4gICAgcHJpdmF0ZSBfcG9zaXRpb25DaGFuZ2VTdWJzY3JpcHRpb247XG4gICAgLyoqIFdoZXRoZXIgdGhlIHBvcG92ZXIgaXMgcHJlc2VudGx5IG9wZW4uICovXG4gICAgcHJpdmF0ZSBfcG9wb3Zlck9wZW47XG4gICAgLyoqIEVtaXRzIHdoZW4gdGhlIHNlcnZpY2UgaXMgZGVzdHJveWVkLiAqL1xuICAgIHByaXZhdGUgX29uRGVzdHJveTtcbiAgICBjb25zdHJ1Y3Rvcihfb3ZlcmxheTogT3ZlcmxheSwgX25nWm9uZTogTmdab25lLCBfZGlyOiBEaXJlY3Rpb25hbGl0eSk7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICAvKiogQW5jaG9yIGEgcG9wb3ZlciBpbnN0YW5jZSB0byBhIHZpZXcgYW5kIGNvbm5lY3Rpb24gZWxlbWVudC4gKi9cbiAgICBhbmNob3IocG9wb3ZlcjogU2F0UG9wb3Zlciwgdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZiwgYW5jaG9yOiBFbGVtZW50UmVmIHwgSFRNTEVsZW1lbnQpOiB2b2lkO1xuICAgIC8qKiBHZXRzIHdoZXRoZXIgdGhlIHBvcG92ZXIgaXMgcHJlc2VudGx5IG9wZW4uICovXG4gICAgaXNQb3BvdmVyT3BlbigpOiBib29sZWFuO1xuICAgIC8qKiBUb2dnbGVzIHRoZSBwb3BvdmVyIGJldHdlZW4gdGhlIG9wZW4gYW5kIGNsb3NlZCBzdGF0ZXMuICovXG4gICAgdG9nZ2xlUG9wb3ZlcigpOiB2b2lkO1xuICAgIC8qKiBPcGVucyB0aGUgcG9wb3Zlci4gKi9cbiAgICBvcGVuUG9wb3ZlcihvcHRpb25zPzogU2F0UG9wb3Zlck9wZW5PcHRpb25zKTogdm9pZDtcbiAgICAvKiogQ2xvc2VzIHRoZSBwb3BvdmVyLiAqL1xuICAgIGNsb3NlUG9wb3Zlcih2YWx1ZT86IGFueSk6IHZvaWQ7XG4gICAgLyoqIFRPRE86IGltcGxlbWVudCB3aGVuIHRoZSBvdmVybGF5J3MgcG9zaXRpb24gY2FuIGJlIGR5bmFtaWNhbGx5IGNoYW5nZWQgKi9cbiAgICByZXBvc2l0aW9uUG9wb3ZlcigpOiB2b2lkO1xuICAgIC8qKiBUT0RPOiB3aGVuIHRoZSBvdmVybGF5J3MgcG9zaXRpb24gY2FuIGJlIGR5bmFtaWNhbGx5IGNoYW5nZWQsIGRvIG5vdCBkZXN0cm95ICovXG4gICAgdXBkYXRlUG9wb3ZlckNvbmZpZygpOiB2b2lkO1xuICAgIC8qKiBSZWFsaWduIHRoZSBwb3BvdmVyIHRvIHRoZSBhbmNob3IuICovXG4gICAgcmVhbGlnblBvcG92ZXJUb0FuY2hvcigpOiB2b2lkO1xuICAgIC8qKiBHZXQgYSByZWZlcmVuY2UgdG8gdGhlIGFuY2hvciBlbGVtZW50LiAqL1xuICAgIGdldEFuY2hvckVsZW1lbnQoKTogSFRNTEVsZW1lbnQ7XG4gICAgLyoqIEFwcGx5IGJlaGF2aW9yIHByb3BlcnRpZXMgb24gdGhlIHBvcG92ZXIgYmFzZWQgb24gdGhlIG9wZW4gb3B0aW9ucy4gKi9cbiAgICBwcml2YXRlIF9hcHBseU9wZW5PcHRpb25zO1xuICAgIC8qKiBDcmVhdGUgYW4gb3ZlcmxheSB0byBiZSBhdHRhY2hlZCB0byB0aGUgcG9ydGFsLiAqL1xuICAgIHByaXZhdGUgX2NyZWF0ZU92ZXJsYXk7XG4gICAgLyoqIFJlbW92ZXMgdGhlIHBvcG92ZXIgZnJvbSB0aGUgRE9NLiBEb2VzIE5PVCB1cGRhdGUgb3BlbiBzdGF0ZS4gKi9cbiAgICBwcml2YXRlIF9kZXN0cm95UG9wb3ZlcjtcbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgcG9wb3ZlciBpbW1lZGlhdGVseSBpZiBpdCBpcyBjbG9zZWQsIG9yIHdhaXRzIHVudGlsIGl0XG4gICAgICogaGFzIGJlZW4gY2xvc2VkIHRvIGRlc3Ryb3kgaXQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfZGVzdHJveVBvcG92ZXJPbmNlQ2xvc2VkO1xuICAgIC8qKiBDbG9zZSBwb3BvdmVyIHdoZW4gYmFja2Ryb3AgaXMgY2xpY2tlZC4gKi9cbiAgICBwcml2YXRlIF9zdWJzY3JpYmVUb0JhY2tkcm9wO1xuICAgIC8qKiBDbG9zZSBwb3BvdmVyIHdoZW4gZXNjYXBlIGtleWRvd24gZXZlbnQgb2NjdXJzLiAqL1xuICAgIHByaXZhdGUgX3N1YnNjcmliZVRvRXNjYXBlO1xuICAgIC8qKiBTZXQgc3RhdGUgYmFjayB0byBjbG9zZWQgd2hlbiBkZXRhY2hlZC4gKi9cbiAgICBwcml2YXRlIF9zdWJzY3JpYmVUb0RldGFjaG1lbnRzO1xuICAgIC8qKiBTYXZlIHRoZSBvcGVuZWQgc3RhdGUgb2YgdGhlIHBvcG92ZXIgYW5kIGVtaXQuICovXG4gICAgcHJpdmF0ZSBfc2F2ZU9wZW5lZFN0YXRlO1xuICAgIC8qKiBTYXZlIHRoZSBjbG9zZWQgc3RhdGUgb2YgdGhlIHBvcG92ZXIgYW5kIGVtaXQuICovXG4gICAgcHJpdmF0ZSBfc2F2ZUNsb3NlZFN0YXRlO1xuICAgIC8qKiBHZXRzIHRoZSB0ZXh0IGRpcmVjdGlvbiBvZiB0aGUgY29udGFpbmluZyBhcHAuICovXG4gICAgcHJpdmF0ZSBfZ2V0RGlyZWN0aW9uO1xuICAgIC8qKiBDcmVhdGUgYW5kIHJldHVybiBhIGNvbmZpZyBmb3IgY3JlYXRpbmcgdGhlIG92ZXJsYXkuICovXG4gICAgcHJpdmF0ZSBfZ2V0T3ZlcmxheUNvbmZpZztcbiAgICAvKipcbiAgICAgKiBMaXN0ZW4gdG8gY2hhbmdlcyBpbiB0aGUgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkgYW5kIHNldCB0aGUgY29ycmVjdCBhbGlnbm1lbnQgY2xhc3NlcyxcbiAgICAgKiBlbnN1cmluZyB0aGF0IHRoZSBhbmltYXRpb24gb3JpZ2luIGlzIGNvcnJlY3QsIGV2ZW4gd2l0aCBhIGZhbGxiYWNrIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIHByaXZhdGUgX3N1YnNjcmliZVRvUG9zaXRpb25DaGFuZ2VzO1xuICAgIC8qKiBNYXAgYSBzY3JvbGwgc3RyYXRlZ3kgc3RyaW5nIHR5cGUgdG8gYW4gaW5zdGFuY2Ugb2YgYSBzY3JvbGwgc3RyYXRlZ3kuICovXG4gICAgcHJpdmF0ZSBfZ2V0U2Nyb2xsU3RyYXRlZ3lJbnN0YW5jZTtcbiAgICAvKiogQ3JlYXRlIGFuZCByZXR1cm4gYSBwb3NpdGlvbiBzdHJhdGVneSBiYXNlZCBvbiBjb25maWcgcHJvdmlkZWQgdG8gdGhlIGNvbXBvbmVudCBpbnN0YW5jZS4gKi9cbiAgICBwcml2YXRlIF9nZXRQb3NpdGlvblN0cmF0ZWd5O1xuICAgIC8qKiBHZXQgZmFsbGJhY2sgcG9zaXRpb25zIGJhc2VkIGFyb3VuZCB0YXJnZXQgYWxpZ25tZW50cy4gKi9cbiAgICBwcml2YXRlIF9nZXRGYWxsYmFja3M7XG59XG4iXX0=