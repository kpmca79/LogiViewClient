/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { ElementRef, Injectable, NgZone, Optional } from '@angular/core';
import { ConnectionPositionPair, Overlay, OverlayConfig, } from '@angular/cdk/overlay';
import { Directionality } from '@angular/cdk/bidi';
import { ESCAPE } from '@angular/cdk/keycodes';
import { TemplatePortal } from '@angular/cdk/portal';
import { Subject } from 'rxjs';
import { takeUntil, take, filter, tap } from 'rxjs/operators';
/**
 * Configuration provided by the popover for the anchoring service
 * to build the correct overlay config.
 * @record
 */
function PopoverConfig() { }
if (false) {
    /** @type {?} */
    PopoverConfig.prototype.horizontalAlign;
    /** @type {?} */
    PopoverConfig.prototype.verticalAlign;
    /** @type {?} */
    PopoverConfig.prototype.hasBackdrop;
    /** @type {?} */
    PopoverConfig.prototype.backdropClass;
    /** @type {?} */
    PopoverConfig.prototype.scrollStrategy;
    /** @type {?} */
    PopoverConfig.prototype.forceAlignment;
    /** @type {?} */
    PopoverConfig.prototype.lockAlignment;
}
var SatPopoverAnchoringService = /** @class */ (function () {
    function SatPopoverAnchoringService(_overlay, _ngZone, _dir) {
        this._overlay = _overlay;
        this._ngZone = _ngZone;
        this._dir = _dir;
        /**
         * Emits when the popover is opened.
         */
        this.popoverOpened = new Subject();
        /**
         * Emits when the popover is closed.
         */
        this.popoverClosed = new Subject();
        /**
         * Whether the popover is presently open.
         */
        this._popoverOpen = false;
        /**
         * Emits when the service is destroyed.
         */
        this._onDestroy = new Subject();
    }
    /**
     * @return {?}
     */
    SatPopoverAnchoringService.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        // Destroy popover before terminating subscriptions so that any resulting
        // detachments update 'closed state'
        this._destroyPopover();
        // Terminate subscriptions
        if (this._notificationsSubscription) {
            this._notificationsSubscription.unsubscribe();
        }
        if (this._positionChangeSubscription) {
            this._positionChangeSubscription.unsubscribe();
        }
        this._onDestroy.next();
        this._onDestroy.complete();
        this.popoverOpened.complete();
        this.popoverClosed.complete();
    };
    /** Anchor a popover instance to a view and connection element. */
    /**
     * Anchor a popover instance to a view and connection element.
     * @param {?} popover
     * @param {?} viewContainerRef
     * @param {?} anchor
     * @return {?}
     */
    SatPopoverAnchoringService.prototype.anchor = /**
     * Anchor a popover instance to a view and connection element.
     * @param {?} popover
     * @param {?} viewContainerRef
     * @param {?} anchor
     * @return {?}
     */
    function (popover, viewContainerRef, anchor) {
        // If we're just changing the anchor element and the overlayRef already exists,
        // simply update the existing _overlayRef's anchor.
        if (this._popover === popover &&
            this._viewContainerRef === viewContainerRef &&
            this._overlayRef) {
            this._anchor = anchor instanceof ElementRef
                ? anchor.nativeElement
                : anchor;
            /** @type {?} */
            var config = this._overlayRef.getConfig();
            /** @type {?} */
            var strategy = (/** @type {?} */ (config.positionStrategy));
            strategy.setOrigin(this._anchor);
            this._overlayRef.updatePosition();
            return;
        }
        // Destroy any previous popovers
        this._destroyPopover();
        // Assign local refs
        this._popover = popover;
        this._viewContainerRef = viewContainerRef;
        this._anchor = anchor instanceof ElementRef
            ? anchor.nativeElement
            : anchor;
    };
    /** Gets whether the popover is presently open. */
    /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    SatPopoverAnchoringService.prototype.isPopoverOpen = /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    function () {
        return this._popoverOpen;
    };
    /** Toggles the popover between the open and closed states. */
    /**
     * Toggles the popover between the open and closed states.
     * @return {?}
     */
    SatPopoverAnchoringService.prototype.togglePopover = /**
     * Toggles the popover between the open and closed states.
     * @return {?}
     */
    function () {
        return this._popoverOpen ? this.closePopover() : this.openPopover();
    };
    /** Opens the popover. */
    /**
     * Opens the popover.
     * @param {?=} options
     * @return {?}
     */
    SatPopoverAnchoringService.prototype.openPopover = /**
     * Opens the popover.
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        if (options === void 0) { options = {}; }
        if (!this._popoverOpen) {
            this._applyOpenOptions(options);
            this._createOverlay();
            this._subscribeToBackdrop();
            this._subscribeToEscape();
            this._subscribeToDetachments();
            this._saveOpenedState();
        }
    };
    /** Closes the popover. */
    /**
     * Closes the popover.
     * @param {?=} value
     * @return {?}
     */
    SatPopoverAnchoringService.prototype.closePopover = /**
     * Closes the popover.
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        if (this._overlayRef) {
            this._saveClosedState(value);
            this._overlayRef.detach();
        }
    };
    /** TODO: implement when the overlay's position can be dynamically changed */
    /**
     * TODO: implement when the overlay's position can be dynamically changed
     * @return {?}
     */
    SatPopoverAnchoringService.prototype.repositionPopover = /**
     * TODO: implement when the overlay's position can be dynamically changed
     * @return {?}
     */
    function () {
        this.updatePopoverConfig();
    };
    /** TODO: when the overlay's position can be dynamically changed, do not destroy */
    /**
     * TODO: when the overlay's position can be dynamically changed, do not destroy
     * @return {?}
     */
    SatPopoverAnchoringService.prototype.updatePopoverConfig = /**
     * TODO: when the overlay's position can be dynamically changed, do not destroy
     * @return {?}
     */
    function () {
        this._destroyPopoverOnceClosed();
    };
    /** Realign the popover to the anchor. */
    /**
     * Realign the popover to the anchor.
     * @return {?}
     */
    SatPopoverAnchoringService.prototype.realignPopoverToAnchor = /**
     * Realign the popover to the anchor.
     * @return {?}
     */
    function () {
        if (this._overlayRef) {
            /** @type {?} */
            var config = this._overlayRef.getConfig();
            /** @type {?} */
            var strategy = (/** @type {?} */ (config.positionStrategy));
            strategy.reapplyLastPosition();
        }
    };
    /** Get a reference to the anchor element. */
    /**
     * Get a reference to the anchor element.
     * @return {?}
     */
    SatPopoverAnchoringService.prototype.getAnchorElement = /**
     * Get a reference to the anchor element.
     * @return {?}
     */
    function () {
        return this._anchor;
    };
    /** Apply behavior properties on the popover based on the open options. */
    /**
     * Apply behavior properties on the popover based on the open options.
     * @private
     * @param {?} options
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._applyOpenOptions = /**
     * Apply behavior properties on the popover based on the open options.
     * @private
     * @param {?} options
     * @return {?}
     */
    function (options) {
        // Only override restoreFocus as `false` if the option is explicitly `false`
        /** @type {?} */
        var restoreFocus = options.restoreFocus !== false;
        this._popover._restoreFocusOverride = restoreFocus;
        // Only override autoFocus as `false` if the option is explicitly `false`
        /** @type {?} */
        var autoFocus = options.autoFocus !== false;
        this._popover._autoFocusOverride = autoFocus;
    };
    /** Create an overlay to be attached to the portal. */
    /**
     * Create an overlay to be attached to the portal.
     * @private
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._createOverlay = /**
     * Create an overlay to be attached to the portal.
     * @private
     * @return {?}
     */
    function () {
        // Create overlay if it doesn't yet exist
        if (!this._overlayRef) {
            this._portal = new TemplatePortal(this._popover._templateRef, this._viewContainerRef);
            /** @type {?} */
            var popoverConfig = {
                horizontalAlign: this._popover.horizontalAlign,
                verticalAlign: this._popover.verticalAlign,
                hasBackdrop: this._popover.hasBackdrop,
                backdropClass: this._popover.backdropClass,
                scrollStrategy: this._popover.scrollStrategy,
                forceAlignment: this._popover.forceAlignment,
                lockAlignment: this._popover.lockAlignment,
            };
            /** @type {?} */
            var overlayConfig = this._getOverlayConfig(popoverConfig, this._anchor);
            this._subscribeToPositionChanges((/** @type {?} */ (overlayConfig.positionStrategy)));
            this._overlayRef = this._overlay.create(overlayConfig);
        }
        // Actually open the popover
        this._overlayRef.attach(this._portal);
        return this._overlayRef;
    };
    /** Removes the popover from the DOM. Does NOT update open state. */
    /**
     * Removes the popover from the DOM. Does NOT update open state.
     * @private
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._destroyPopover = /**
     * Removes the popover from the DOM. Does NOT update open state.
     * @private
     * @return {?}
     */
    function () {
        if (this._overlayRef) {
            this._overlayRef.dispose();
            this._overlayRef = null;
        }
    };
    /**
     * Destroys the popover immediately if it is closed, or waits until it
     * has been closed to destroy it.
     */
    /**
     * Destroys the popover immediately if it is closed, or waits until it
     * has been closed to destroy it.
     * @private
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._destroyPopoverOnceClosed = /**
     * Destroys the popover immediately if it is closed, or waits until it
     * has been closed to destroy it.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.isPopoverOpen() && this._overlayRef) {
            this._overlayRef.detachments().pipe(take(1), takeUntil(this._onDestroy)).subscribe((/**
             * @return {?}
             */
            function () { return _this._destroyPopover(); }));
        }
        else {
            this._destroyPopover();
        }
    };
    /** Close popover when backdrop is clicked. */
    /**
     * Close popover when backdrop is clicked.
     * @private
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._subscribeToBackdrop = /**
     * Close popover when backdrop is clicked.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this._overlayRef
            .backdropClick()
            .pipe(tap((/**
         * @return {?}
         */
        function () { return _this._popover.backdropClicked.emit(); })), filter((/**
         * @return {?}
         */
        function () { return _this._popover.interactiveClose; })), takeUntil(this.popoverClosed), takeUntil(this._onDestroy))
            .subscribe((/**
         * @return {?}
         */
        function () { return _this.closePopover(); }));
    };
    /** Close popover when escape keydown event occurs. */
    /**
     * Close popover when escape keydown event occurs.
     * @private
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._subscribeToEscape = /**
     * Close popover when escape keydown event occurs.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this._overlayRef
            .keydownEvents()
            .pipe(tap((/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this._popover.overlayKeydown.emit(event); })), filter((/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return event.keyCode === ESCAPE; })), filter((/**
         * @return {?}
         */
        function () { return _this._popover.interactiveClose; })), takeUntil(this.popoverClosed), takeUntil(this._onDestroy))
            .subscribe((/**
         * @return {?}
         */
        function () { return _this.closePopover(); }));
    };
    /** Set state back to closed when detached. */
    /**
     * Set state back to closed when detached.
     * @private
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._subscribeToDetachments = /**
     * Set state back to closed when detached.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this._overlayRef
            .detachments()
            .pipe(takeUntil(this._onDestroy))
            .subscribe((/**
         * @return {?}
         */
        function () { return _this._saveClosedState(); }));
    };
    /** Save the opened state of the popover and emit. */
    /**
     * Save the opened state of the popover and emit.
     * @private
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._saveOpenedState = /**
     * Save the opened state of the popover and emit.
     * @private
     * @return {?}
     */
    function () {
        if (!this._popoverOpen) {
            this._popover._open = this._popoverOpen = true;
            this.popoverOpened.next();
            this._popover.opened.emit();
        }
    };
    /** Save the closed state of the popover and emit. */
    /**
     * Save the closed state of the popover and emit.
     * @private
     * @param {?=} value
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._saveClosedState = /**
     * Save the closed state of the popover and emit.
     * @private
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        if (this._popoverOpen) {
            this._popover._open = this._popoverOpen = false;
            this.popoverClosed.next(value);
            this._popover.closed.emit(value);
        }
    };
    /** Gets the text direction of the containing app. */
    /**
     * Gets the text direction of the containing app.
     * @private
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._getDirection = /**
     * Gets the text direction of the containing app.
     * @private
     * @return {?}
     */
    function () {
        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
    };
    /** Create and return a config for creating the overlay. */
    /**
     * Create and return a config for creating the overlay.
     * @private
     * @param {?} config
     * @param {?} anchor
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._getOverlayConfig = /**
     * Create and return a config for creating the overlay.
     * @private
     * @param {?} config
     * @param {?} anchor
     * @return {?}
     */
    function (config, anchor) {
        return new OverlayConfig({
            positionStrategy: this._getPositionStrategy(config.horizontalAlign, config.verticalAlign, config.forceAlignment, config.lockAlignment, anchor),
            hasBackdrop: config.hasBackdrop,
            backdropClass: config.backdropClass || 'cdk-overlay-transparent-backdrop',
            scrollStrategy: this._getScrollStrategyInstance(config.scrollStrategy),
            direction: this._getDirection(),
        });
    };
    /**
     * Listen to changes in the position of the overlay and set the correct alignment classes,
     * ensuring that the animation origin is correct, even with a fallback position.
     */
    /**
     * Listen to changes in the position of the overlay and set the correct alignment classes,
     * ensuring that the animation origin is correct, even with a fallback position.
     * @private
     * @param {?} position
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._subscribeToPositionChanges = /**
     * Listen to changes in the position of the overlay and set the correct alignment classes,
     * ensuring that the animation origin is correct, even with a fallback position.
     * @private
     * @param {?} position
     * @return {?}
     */
    function (position) {
        var _this = this;
        if (this._positionChangeSubscription) {
            this._positionChangeSubscription.unsubscribe();
        }
        this._positionChangeSubscription = position.positionChanges
            .pipe(takeUntil(this._onDestroy))
            .subscribe((/**
         * @param {?} change
         * @return {?}
         */
        function (change) {
            // Position changes may occur outside the Angular zone
            _this._ngZone.run((/**
             * @return {?}
             */
            function () {
                _this._popover._setAlignmentClasses(getHorizontalPopoverAlignment(change.connectionPair.overlayX), getVerticalPopoverAlignment(change.connectionPair.overlayY));
            }));
        }));
    };
    /** Map a scroll strategy string type to an instance of a scroll strategy. */
    /**
     * Map a scroll strategy string type to an instance of a scroll strategy.
     * @private
     * @param {?} strategy
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._getScrollStrategyInstance = /**
     * Map a scroll strategy string type to an instance of a scroll strategy.
     * @private
     * @param {?} strategy
     * @return {?}
     */
    function (strategy) {
        switch (strategy) {
            case 'block':
                return this._overlay.scrollStrategies.block();
            case 'reposition':
                return this._overlay.scrollStrategies.reposition();
            case 'close':
                return this._overlay.scrollStrategies.close();
            case 'noop':
            default:
                return this._overlay.scrollStrategies.noop();
        }
    };
    /** Create and return a position strategy based on config provided to the component instance. */
    /**
     * Create and return a position strategy based on config provided to the component instance.
     * @private
     * @param {?} horizontalTarget
     * @param {?} verticalTarget
     * @param {?} forceAlignment
     * @param {?} lockAlignment
     * @param {?} anchor
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._getPositionStrategy = /**
     * Create and return a position strategy based on config provided to the component instance.
     * @private
     * @param {?} horizontalTarget
     * @param {?} verticalTarget
     * @param {?} forceAlignment
     * @param {?} lockAlignment
     * @param {?} anchor
     * @return {?}
     */
    function (horizontalTarget, verticalTarget, forceAlignment, lockAlignment, anchor) {
        // Attach the overlay at the preferred position
        /** @type {?} */
        var targetPosition = getPosition(horizontalTarget, verticalTarget);
        /** @type {?} */
        var positions = [targetPosition];
        /** @type {?} */
        var strategy = this._overlay.position()
            .flexibleConnectedTo(anchor)
            .withFlexibleDimensions(false)
            .withPush(false)
            .withViewportMargin(0)
            .withLockedPosition(lockAlignment);
        // Unless the alignment is forced, add fallbacks based on the preferred positions
        if (!forceAlignment) {
            /** @type {?} */
            var fallbacks = this._getFallbacks(horizontalTarget, verticalTarget);
            positions.push.apply(positions, tslib_1.__spread(fallbacks));
        }
        return strategy.withPositions(positions);
    };
    /** Get fallback positions based around target alignments. */
    /**
     * Get fallback positions based around target alignments.
     * @private
     * @param {?} hTarget
     * @param {?} vTarget
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._getFallbacks = /**
     * Get fallback positions based around target alignments.
     * @private
     * @param {?} hTarget
     * @param {?} vTarget
     * @return {?}
     */
    function (hTarget, vTarget) {
        // Determine if the target alignments overlap the anchor
        /** @type {?} */
        var horizontalOverlapAllowed = hTarget !== 'before' && hTarget !== 'after';
        /** @type {?} */
        var verticalOverlapAllowed = vTarget !== 'above' && vTarget !== 'below';
        // If a target alignment doesn't cover the anchor, don't let any of the fallback alignments
        // cover the anchor
        /** @type {?} */
        var possibleHorizontalAlignments = horizontalOverlapAllowed ?
            ['before', 'start', 'center', 'end', 'after'] :
            ['before', 'after'];
        /** @type {?} */
        var possibleVerticalAlignments = verticalOverlapAllowed ?
            ['above', 'start', 'center', 'end', 'below'] :
            ['above', 'below'];
        // Create fallbacks for each allowed prioritized fallback alignment combo
        /** @type {?} */
        var fallbacks = [];
        prioritizeAroundTarget(hTarget, possibleHorizontalAlignments).forEach((/**
         * @param {?} h
         * @return {?}
         */
        function (h) {
            prioritizeAroundTarget(vTarget, possibleVerticalAlignments).forEach((/**
             * @param {?} v
             * @return {?}
             */
            function (v) {
                fallbacks.push(getPosition(h, v));
            }));
        }));
        // Remove the first item since it will be the target alignment and isn't considered a fallback
        return fallbacks.slice(1, fallbacks.length);
    };
    SatPopoverAnchoringService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    SatPopoverAnchoringService.ctorParameters = function () { return [
        { type: Overlay },
        { type: NgZone },
        { type: Directionality, decorators: [{ type: Optional }] }
    ]; };
    return SatPopoverAnchoringService;
}());
export { SatPopoverAnchoringService };
if (false) {
    /**
     * Emits when the popover is opened.
     * @type {?}
     */
    SatPopoverAnchoringService.prototype.popoverOpened;
    /**
     * Emits when the popover is closed.
     * @type {?}
     */
    SatPopoverAnchoringService.prototype.popoverClosed;
    /**
     * Reference to the overlay containing the popover component.
     * @type {?}
     */
    SatPopoverAnchoringService.prototype._overlayRef;
    /**
     * Reference to the target popover.
     * @type {?}
     * @private
     */
    SatPopoverAnchoringService.prototype._popover;
    /**
     * Reference to the view container for the popover template.
     * @type {?}
     * @private
     */
    SatPopoverAnchoringService.prototype._viewContainerRef;
    /**
     * Reference to the anchor element.
     * @type {?}
     * @private
     */
    SatPopoverAnchoringService.prototype._anchor;
    /**
     * Reference to a template portal where the overlay will be attached.
     * @type {?}
     * @private
     */
    SatPopoverAnchoringService.prototype._portal;
    /**
     * Single subscription to notifications service events.
     * @type {?}
     * @private
     */
    SatPopoverAnchoringService.prototype._notificationsSubscription;
    /**
     * Single subscription to position changes.
     * @type {?}
     * @private
     */
    SatPopoverAnchoringService.prototype._positionChangeSubscription;
    /**
     * Whether the popover is presently open.
     * @type {?}
     * @private
     */
    SatPopoverAnchoringService.prototype._popoverOpen;
    /**
     * Emits when the service is destroyed.
     * @type {?}
     * @private
     */
    SatPopoverAnchoringService.prototype._onDestroy;
    /**
     * @type {?}
     * @private
     */
    SatPopoverAnchoringService.prototype._overlay;
    /**
     * @type {?}
     * @private
     */
    SatPopoverAnchoringService.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    SatPopoverAnchoringService.prototype._dir;
}
/**
 * Helper function to get a cdk position pair from SatPopover alignments.
 * @param {?} h
 * @param {?} v
 * @return {?}
 */
function getPosition(h, v) {
    var _a = getHorizontalConnectionPosPair(h), originX = _a.originX, overlayX = _a.overlayX;
    var _b = getVerticalConnectionPosPair(v), originY = _b.originY, overlayY = _b.overlayY;
    return new ConnectionPositionPair({ originX: originX, originY: originY }, { overlayX: overlayX, overlayY: overlayY });
}
/**
 * Helper function to convert an overlay connection position to equivalent popover alignment.
 * @param {?} h
 * @return {?}
 */
function getHorizontalPopoverAlignment(h) {
    if (h === 'start') {
        return 'after';
    }
    if (h === 'end') {
        return 'before';
    }
    return 'center';
}
/**
 * Helper function to convert an overlay connection position to equivalent popover alignment.
 * @param {?} v
 * @return {?}
 */
function getVerticalPopoverAlignment(v) {
    if (v === 'top') {
        return 'below';
    }
    if (v === 'bottom') {
        return 'above';
    }
    return 'center';
}
/**
 * Helper function to convert alignment to origin/overlay position pair.
 * @param {?} h
 * @return {?}
 */
function getHorizontalConnectionPosPair(h) {
    switch (h) {
        case 'before':
            return { originX: 'start', overlayX: 'end' };
        case 'start':
            return { originX: 'start', overlayX: 'start' };
        case 'end':
            return { originX: 'end', overlayX: 'end' };
        case 'after':
            return { originX: 'end', overlayX: 'start' };
        default:
            return { originX: 'center', overlayX: 'center' };
    }
}
/**
 * Helper function to convert alignment to origin/overlay position pair.
 * @param {?} v
 * @return {?}
 */
function getVerticalConnectionPosPair(v) {
    switch (v) {
        case 'above':
            return { originY: 'top', overlayY: 'bottom' };
        case 'start':
            return { originY: 'top', overlayY: 'top' };
        case 'end':
            return { originY: 'bottom', overlayY: 'bottom' };
        case 'below':
            return { originY: 'bottom', overlayY: 'top' };
        default:
            return { originY: 'center', overlayY: 'center' };
    }
}
/**
 * Helper function that takes an ordered array options and returns a reorderded
 * array around the target item. e.g.:
 *
 * target: 3; options: [1, 2, 3, 4, 5, 6, 7];
 *
 * return: [3, 4, 2, 5, 1, 6, 7]
 * @template T
 * @param {?} target
 * @param {?} options
 * @return {?}
 */
function prioritizeAroundTarget(target, options) {
    /** @type {?} */
    var targetIndex = options.indexOf(target);
    // Set the first item to be the target
    /** @type {?} */
    var reordered = [target];
    // Make left and right stacks where the highest priority item is last
    /** @type {?} */
    var left = options.slice(0, targetIndex);
    /** @type {?} */
    var right = options.slice(targetIndex + 1, options.length).reverse();
    // Alternate between stacks until one is empty
    while (left.length && right.length) {
        reordered.push(right.pop());
        reordered.push(left.pop());
    }
    // Flush out right side
    while (right.length) {
        reordered.push(right.pop());
    }
    // Flush out left side
    while (left.length) {
        reordered.push(left.pop());
    }
    return reordered;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci1hbmNob3Jpbmcuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuY3N0YXRlL3NhdC1wb3BvdmVyLyIsInNvdXJjZXMiOlsicG9wb3Zlci9wb3BvdmVyLWFuY2hvcmluZy5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUNMLFVBQVUsRUFDVixVQUFVLEVBQ1YsTUFBTSxFQUVOLFFBQVEsRUFFVCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQ0wsc0JBQXNCLEVBR3RCLE9BQU8sRUFDUCxhQUFhLEdBSWQsTUFBTSxzQkFBc0IsQ0FBQztBQUM5QixPQUFPLEVBQUUsY0FBYyxFQUFZLE1BQU0sbUJBQW1CLENBQUM7QUFDN0QsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQy9DLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUNyRCxPQUFPLEVBQWdCLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUM3QyxPQUFPLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7Ozs7OztBQWM5RCw0QkFRQzs7O0lBUEMsd0NBQTJDOztJQUMzQyxzQ0FBdUM7O0lBQ3ZDLG9DQUFxQjs7SUFDckIsc0NBQXNCOztJQUN0Qix1Q0FBeUM7O0lBQ3pDLHVDQUF3Qjs7SUFDeEIsc0NBQXVCOztBQUd6QjtJQW9DRSxvQ0FDVSxRQUFpQixFQUNqQixPQUFlLEVBQ0gsSUFBb0I7UUFGaEMsYUFBUSxHQUFSLFFBQVEsQ0FBUztRQUNqQixZQUFPLEdBQVAsT0FBTyxDQUFRO1FBQ0gsU0FBSSxHQUFKLElBQUksQ0FBZ0I7Ozs7UUFuQzFDLGtCQUFhLEdBQUcsSUFBSSxPQUFPLEVBQVEsQ0FBQzs7OztRQUdwQyxrQkFBYSxHQUFHLElBQUksT0FBTyxFQUFRLENBQUM7Ozs7UUF3QjVCLGlCQUFZLEdBQUcsS0FBSyxD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Q0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7S0FDNUI7SUFFRCx1QkFBdUI7SUFDdkIsT0FBTyxLQUFLLENBQUMsTUFBTSxFQUFFO1FBQ25CLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7S0FDN0I7SUFFRCxzQkFBc0I7SUFDdEIsT0FBTyxJQUFJLENBQUMsTUFBTSxFQUFFO1FBQ2xCLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7S0FDNUI7SUFFRCxPQUFPLFNBQVMsQ0FBQztBQUNuQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgRWxlbWVudFJlZixcbiAgSW5qZWN0YWJsZSxcbiAgTmdab25lLFxuICBPbkRlc3Ryb3ksXG4gIE9wdGlvbmFsLFxuICBWaWV3Q29udGFpbmVyUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgQ29ubmVjdGlvblBvc2l0aW9uUGFpcixcbiAgRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LFxuICBIb3Jpem9udGFsQ29ubmVjdGlvblBvcyxcbiAgT3ZlcmxheSxcbiAgT3ZlcmxheUNvbmZpZyxcbiAgT3ZlcmxheVJlZixcbiAgU2Nyb2xsU3RyYXRlZ3ksXG4gIFZlcnRpY2FsQ29ubmVjdGlvblBvcyxcbn0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHsgRGlyZWN0aW9uYWxpdHksIERpcmVjdGlvbn0gZnJvbSAnQGFuZ3VsYXIvY2RrL2JpZGknO1xuaW1wb3J0IHsgRVNDQVBFIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcbmltcG9ydCB7IFRlbXBsYXRlUG9ydGFsIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BvcnRhbCc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24sIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCwgdGFrZSwgZmlsdGVyLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IFNhdFBvcG92ZXIgfSBmcm9tICcuL3BvcG92ZXIuY29tcG9uZW50JztcbmltcG9ydCB7XG4gIFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ24sXG4gIFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduLFxuICBTYXRQb3BvdmVyU2Nyb2xsU3RyYXRlZ3ksXG4gIFNhdFBvcG92ZXJPcGVuT3B0aW9ucyxcbn0gZnJvbSAnLi90eXBlcyc7XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBwcm92aWRlZCBieSB0aGUgcG9wb3ZlciBmb3IgdGhlIGFuY2hvcmluZyBzZXJ2aWNlXG4gKiB0byBidWlsZCB0aGUgY29ycmVjdCBvdmVybGF5IGNvbmZpZy5cbiAqL1xuaW50ZXJmYWNlIFBvcG92ZXJDb25maWcge1xuICBob3Jpem9udGFsQWxpZ246IFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ247XG4gIHZlcnRpY2FsQWxpZ246IFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduO1xuICBoYXNCYWNrZHJvcDogYm9vbGVhbjtcbiAgYmFja2Ryb3BDbGFzczogc3RyaW5nO1xuICBzY3JvbGxTdHJhdGVneTogU2F0UG9wb3ZlclNjcm9sbFN0cmF0ZWd5O1xuICBmb3JjZUFsaWdubWVudDogYm9vbGVhbjtcbiAgbG9ja0FsaWdubWVudDogYm9vbGVhbjtcbn1cblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNhdFBvcG92ZXJBbmNob3JpbmdTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgcG9wb3ZlciBpcyBvcGVuZWQuICovXG4gIHBvcG92ZXJPcGVuZWQgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSBwb3BvdmVyIGlzIGNsb3NlZC4gKi9cbiAgcG9wb3ZlckNsb3NlZCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgb3ZlcmxheSBjb250YWluaW5nIHRoZSBwb3BvdmVyIGNvbXBvbmVudC4gKi9cbiAgX292ZXJsYXlSZWY6IE92ZXJsYXlSZWY7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgdGFyZ2V0IHBvcG92ZXIuICovXG4gIHByaXZhdGUgX3BvcG92ZXI6IFNhdFBvcG92ZXI7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgdmlldyBjb250YWluZXIgZm9yIHRoZSBwb3BvdmVyIHRlbXBsYXRlLiAqL1xuICBwcml2YXRlIF92aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmO1xuXG4gIC8qKiBSZWZlcmVuY2UgdG8gdGhlIGFuY2hvciBlbGVtZW50LiAqL1xuICBwcml2YXRlIF9hbmNob3I6IEhUTUxFbGVtZW50O1xuXG4gIC8qKiBSZWZlcmVuY2UgdG8gYSB0ZW1wbGF0ZSBwb3J0YWwgd2hlcmUgdGhlIG92ZXJsYXkgd2lsbCBiZSBhdHRhY2hlZC4gKi9cbiAgcHJpdmF0ZSBfcG9ydGFsOiBUZW1wbGF0ZVBvcnRhbDxhbnk+O1xuXG4gIC8qKiBTaW5nbGUgc3Vic2NyaXB0aW9uIHRvIG5vdGlmaWNhdGlvbnMgc2VydmljZSBldmVudHMuICovXG4gIHByaXZhdGUgX25vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAvKiogU2luZ2xlIHN1YnNjcmlwdGlvbiB0byBwb3NpdGlvbiBjaGFuZ2VzLiAqL1xuICBwcml2YXRlIF9wb3NpdGlvbkNoYW5nZVN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIGlzIHByZXNlbnRseSBvcGVuLiAqL1xuICBwcml2YXRlIF9wb3BvdmVyT3BlbiA9IGZhbHNlO1xuXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSBzZXJ2aWNlIGlzIGRlc3Ryb3llZC4gKi9cbiAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9vdmVybGF5OiBPdmVybGF5LFxuICAgIHByaXZhdGUgX25nWm9uZTogTmdab25lLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX2RpcjogRGlyZWN0aW9uYWxpdHlcbiAgKSB7IH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICAvLyBEZXN0cm95IHBvcG92ZXIgYmVmb3JlIHRlcm1pbmF0aW5nIHN1YnNjcmlwdGlvbnMgc28gdGhhdCBhbnkgcmVzdWx0aW5nXG4gICAgLy8gZGV0YWNobWVudHMgdXBkYXRlICdjbG9zZWQgc3RhdGUnXG4gICAgdGhpcy5fZGVzdHJveVBvcG92ZXIoKTtcblxuICAgIC8vIFRlcm1pbmF0ZSBzdWJzY3JpcHRpb25zXG4gICAgaWYgKHRoaXMuX25vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuX25vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3Bvc2l0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLl9wb3NpdGlvbkNoYW5nZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgIHRoaXMuX29uRGVzdHJveS5jb21wbGV0ZSgpO1xuXG4gICAgdGhpcy5wb3BvdmVyT3BlbmVkLmNvbXBsZXRlKCk7XG4gICAgdGhpcy5wb3BvdmVyQ2xvc2VkLmNvbXBsZXRlKCk7XG4gIH1cblxuICAvKiogQW5jaG9yIGEgcG9wb3ZlciBpbnN0YW5jZSB0byBhIHZpZXcgYW5kIGNvbm5lY3Rpb24gZWxlbWVudC4gKi9cbiAgYW5jaG9yKFxuICAgIHBvcG92ZXI6IFNhdFBvcG92ZXIsXG4gICAgdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZixcbiAgICBhbmNob3I6IEVsZW1lbnRSZWYgfCBIVE1MRWxlbWVudFxuICApOiB2b2lkIHtcbiAgICAvLyBJZiB3ZSdyZSBqdXN0IGNoYW5naW5nIHRoZSBhbmNob3IgZWxlbWVudCBhbmQgdGhlIG92ZXJsYXlSZWYgYWxyZWFkeSBleGlzdHMsXG4gICAgLy8gc2ltcGx5IHVwZGF0ZSB0aGUgZXhpc3RpbmcgX292ZXJsYXlSZWYncyBhbmNob3IuXG4gICAgaWYgKFxuICAgICAgdGhpcy5fcG9wb3ZlciA9PT0gcG9wb3ZlciAmJlxuICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZiA9PT0gdmlld0NvbnRhaW5lclJlZiAmJlxuICAgICAgdGhpcy5fb3ZlcmxheVJlZlxuICAgICkge1xuICAgICAgdGhpcy5fYW5jaG9yID0gYW5jaG9yIGluc3RhbmNlb2YgRWxlbWVudFJlZlxuICAgICAgICA/IGFuY2hvci5uYXRpdmVFbGVtZW50XG4gICAgICAgIDogYW5jaG9yO1xuICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5fb3ZlcmxheVJlZi5nZXRDb25maWcoKTtcbiAgICAgIGNvbnN0IHN0cmF0ZWd5ID0gY29uZmlnLnBvc2l0aW9uU3RyYXRlZ3kgYXMgRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5O1xuICAgICAgc3RyYXRlZ3kuc2V0T3JpZ2luKHRoaXMuX2FuY2hvcik7XG4gICAgICB0aGlzLl9vdmVybGF5UmVmLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRGVzdHJveSBhbnkgcHJldmlvdXMgcG9wb3ZlcnNcbiAgICB0aGlzLl9kZXN0cm95UG9wb3ZlcigpO1xuXG4gICAgLy8gQXNzaWduIGxvY2FsIHJlZnNcbiAgICB0aGlzLl9wb3BvdmVyID0gcG9wb3ZlcjtcbiAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmID0gdmlld0NvbnRhaW5lclJlZjtcbiAgICB0aGlzLl9hbmNob3IgPSBhbmNob3IgaW5zdGFuY2VvZiBFbGVtZW50UmVmXG4gICAgICA/IGFuY2hvci5uYXRpdmVFbGVtZW50XG4gICAgICA6IGFuY2hvcjtcbiAgfVxuXG4gIC8qKiBHZXRzIHdoZXRoZXIgdGhlIHBvcG92ZXIgaXMgcHJlc2VudGx5IG9wZW4uICovXG4gIGlzUG9wb3Zlck9wZW4oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3BvcG92ZXJPcGVuO1xuICB9XG5cbiAgLyoqIFRvZ2dsZXMgdGhlIHBvcG92ZXIgYmV0d2VlbiB0aGUgb3BlbiBhbmQgY2xvc2VkIHN0YXRlcy4gKi9cbiAgdG9nZ2xlUG9wb3ZlcigpOiB2b2lkIHtcbiAgICByZXR1cm4gdGhpcy5fcG9wb3Zlck9wZW4gPyB0aGlzLmNsb3NlUG9wb3ZlcigpIDogdGhpcy5vcGVuUG9wb3ZlcigpO1xuICB9XG5cbiAgLyoqIE9wZW5zIHRoZSBwb3BvdmVyLiAqL1xuICBvcGVuUG9wb3ZlcihvcHRpb25zOiBTYXRQb3BvdmVyT3Blbk9wdGlvbnMgPSB7fSk6IHZvaWQge1xuICAgIGlmICghdGhpcy5fcG9wb3Zlck9wZW4pIHtcbiAgICAgIHRoaXMuX2FwcGx5T3Blbk9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB0aGlzLl9jcmVhdGVPdmVybGF5KCk7XG4gICAgICB0aGlzLl9zdWJzY3JpYmVUb0JhY2tkcm9wKCk7XG4gICAgICB0aGlzLl9zdWJzY3JpYmVUb0VzY2FwZSgpO1xuICAgICAgdGhpcy5fc3Vic2NyaWJlVG9EZXRhY2htZW50cygpO1xuICAgICAgdGhpcy5fc2F2ZU9wZW5lZFN0YXRlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIENsb3NlcyB0aGUgcG9wb3Zlci4gKi9cbiAgY2xvc2VQb3BvdmVyKHZhbHVlPzogYW55KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgIHRoaXMuX3NhdmVDbG9zZWRTdGF0ZSh2YWx1ZSk7XG4gICAgICB0aGlzLl9vdmVybGF5UmVmLmRldGFjaCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBUT0RPOiBpbXBsZW1lbnQgd2hlbiB0aGUgb3ZlcmxheSdzIHBvc2l0aW9uIGNhbiBiZSBkeW5hbWljYWxseSBjaGFuZ2VkICovXG4gIHJlcG9zaXRpb25Qb3BvdmVyKCk6IHZvaWQge1xuICAgIHRoaXMudXBkYXRlUG9wb3ZlckNvbmZpZygpO1xuICB9XG5cbiAgLyoqIFRPRE86IHdoZW4gdGhlIG92ZXJsYXkncyBwb3NpdGlvbiBjYW4gYmUgZHluYW1pY2FsbHkgY2hhbmdlZCwgZG8gbm90IGRlc3Ryb3kgKi9cbiAgdXBkYXRlUG9wb3ZlckNvbmZpZygpOiB2b2lkIHtcbiAgICB0aGlzLl9kZXN0cm95UG9wb3Zlck9uY2VDbG9zZWQoKTtcbiAgfVxuXG4gIC8qKiBSZWFsaWduIHRoZSBwb3BvdmVyIHRvIHRoZSBhbmNob3IuICovXG4gIHJlYWxpZ25Qb3BvdmVyVG9BbmNob3IoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuX292ZXJsYXlSZWYuZ2V0Q29uZmlnKCk7XG4gICAgICBjb25zdCBzdHJhdGVneSA9IGNvbmZpZy5wb3NpdGlvblN0cmF0ZWd5IGFzIEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneTtcbiAgICAgIHN0cmF0ZWd5LnJlYXBwbHlMYXN0UG9zaXRpb24oKTtcbiAgICB9XG4gIH1cblxuICAvKiogR2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBhbmNob3IgZWxlbWVudC4gKi9cbiAgZ2V0QW5jaG9yRWxlbWVudCgpOiBIVE1MRWxlbWVudCB7XG4gICAgcmV0dXJuIHRoaXMuX2FuY2hvcjtcbiAgfVxuXG4gIC8qKiBBcHBseSBiZWhhdmlvciBwcm9wZXJ0aWVzIG9uIHRoZSBwb3BvdmVyIGJhc2VkIG9uIHRoZSBvcGVuIG9wdGlvbnMuICovXG4gIHByaXZhdGUgX2FwcGx5T3Blbk9wdGlvbnMob3B0aW9uczogU2F0UG9wb3Zlck9wZW5PcHRpb25zKTogdm9pZCB7XG4gICAgLy8gT25seSBvdmVycmlkZSByZXN0b3JlRm9jdXMgYXMgYGZhbHNlYCBpZiB0aGUgb3B0aW9uIGlzIGV4cGxpY2l0bHkgYGZhbHNlYFxuICAgIGNvbnN0IHJlc3RvcmVGb2N1cyA9IG9wdGlvbnMucmVzdG9yZUZvY3VzICE9PSBmYWxzZTtcbiAgICB0aGlzLl9wb3BvdmVyLl9yZXN0b3JlRm9jdXNPdmVycmlkZSA9IHJlc3RvcmVGb2N1cztcblxuICAgIC8vIE9ubHkgb3ZlcnJpZGUgYXV0b0ZvY3VzIGFzIGBmYWxzZWAgaWYgdGhlIG9wdGlvbiBpcyBleHBsaWNpdGx5IGBmYWxzZWBcbiAgICBjb25zdCBhdXRvRm9jdXMgPSBvcHRpb25zLmF1dG9Gb2N1cyAhPT0gZmFsc2U7XG4gICAgdGhpcy5fcG9wb3Zlci5fYXV0b0ZvY3VzT3ZlcnJpZGUgPSBhdXRvRm9jdXM7XG4gIH1cblxuICAvKiogQ3JlYXRlIGFuIG92ZXJsYXkgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIHBvcnRhbC4gKi9cbiAgcHJpdmF0ZSBfY3JlYXRlT3ZlcmxheSgpOiBPdmVybGF5UmVmIHtcbiAgICAvLyBDcmVhdGUgb3ZlcmxheSBpZiBpdCBkb2Vzbid0IHlldCBleGlzdFxuICAgIGlmICghdGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgdGhpcy5fcG9ydGFsID0gbmV3IFRlbXBsYXRlUG9ydGFsKHRoaXMuX3BvcG92ZXIuX3RlbXBsYXRlUmVmLCB0aGlzLl92aWV3Q29udGFpbmVyUmVmKTtcblxuICAgICAgY29uc3QgcG9wb3ZlckNvbmZpZyA9IHtcbiAgICAgICAgaG9yaXpvbnRhbEFsaWduOiB0aGlzLl9wb3BvdmVyLmhvcml6b250YWxBbGlnbixcbiAgICAgICAgdmVydGljYWxBbGlnbjogdGhpcy5fcG9wb3Zlci52ZXJ0aWNhbEFsaWduLFxuICAgICAgICBoYXNCYWNrZHJvcDogdGhpcy5fcG9wb3Zlci5oYXNCYWNrZHJvcCxcbiAgICAgICAgYmFja2Ryb3BDbGFzczogdGhpcy5fcG9wb3Zlci5iYWNrZHJvcENsYXNzLFxuICAgICAgICBzY3JvbGxTdHJhdGVneTogdGhpcy5fcG9wb3Zlci5zY3JvbGxTdHJhdGVneSxcbiAgICAgICAgZm9yY2VBbGlnbm1lbnQ6IHRoaXMuX3BvcG92ZXIuZm9yY2VBbGlnbm1lbnQsXG4gICAgICAgIGxvY2tBbGlnbm1lbnQ6IHRoaXMuX3BvcG92ZXIubG9ja0FsaWdubWVudCxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG92ZXJsYXlDb25maWcgPSB0aGlzLl9nZXRPdmVybGF5Q29uZmlnKHBvcG92ZXJDb25maWcsIHRoaXMuX2FuY2hvcik7XG5cbiAgICAgIHRoaXMuX3N1YnNjcmliZVRvUG9zaXRpb25DaGFuZ2VzKFxuICAgICAgICBvdmVybGF5Q29uZmlnLnBvc2l0aW9uU3RyYXRlZ3kgYXMgRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5XG4gICAgICApO1xuXG4gICAgICB0aGlzLl9vdmVybGF5UmVmID0gdGhpcy5fb3ZlcmxheS5jcmVhdGUob3ZlcmxheUNvbmZpZyk7XG4gICAgfVxuXG4gICAgLy8gQWN0dWFsbHkgb3BlbiB0aGUgcG9wb3ZlclxuICAgIHRoaXMuX292ZXJsYXlSZWYuYXR0YWNoKHRoaXMuX3BvcnRhbCk7XG4gICAgcmV0dXJuIHRoaXMuX292ZXJsYXlSZWY7XG4gIH1cblxuXG4gIC8qKiBSZW1vdmVzIHRoZSBwb3BvdmVyIGZyb20gdGhlIERPTS4gRG9lcyBOT1QgdXBkYXRlIG9wZW4gc3RhdGUuICovXG4gIHByaXZhdGUgX2Rlc3Ryb3lQb3BvdmVyKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICB0aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgcG9wb3ZlciBpbW1lZGlhdGVseSBpZiBpdCBpcyBjbG9zZWQsIG9yIHdhaXRzIHVudGlsIGl0XG4gICAqIGhhcyBiZWVuIGNsb3NlZCB0byBkZXN0cm95IGl0LlxuICAgKi9cbiAgcHJpdmF0ZSBfZGVzdHJveVBvcG92ZXJPbmNlQ2xvc2VkKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzUG9wb3Zlck9wZW4oKSAmJiB0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICB0aGlzLl9vdmVybGF5UmVmLmRldGFjaG1lbnRzKCkucGlwZShcbiAgICAgICAgdGFrZSgxKSxcbiAgICAgICAgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSlcbiAgICAgICkuc3Vic2NyaWJlKCgpID0+IHRoaXMuX2Rlc3Ryb3lQb3BvdmVyKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kZXN0cm95UG9wb3ZlcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBDbG9zZSBwb3BvdmVyIHdoZW4gYmFja2Ryb3AgaXMgY2xpY2tlZC4gKi9cbiAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9CYWNrZHJvcCgpOiB2b2lkIHtcbiAgICB0aGlzLl9vdmVybGF5UmVmXG4gICAgICAuYmFja2Ryb3BDbGljaygpXG4gICAgICAucGlwZShcbiAgICAgICAgdGFwKCgpID0+IHRoaXMuX3BvcG92ZXIuYmFja2Ryb3BDbGlja2VkLmVtaXQoKSksXG4gICAgICAgIGZpbHRlcigoKSA9PiB0aGlzLl9wb3BvdmVyLmludGVyYWN0aXZlQ2xvc2UpLFxuICAgICAgICB0YWtlVW50aWwodGhpcy5wb3BvdmVyQ2xvc2VkKSxcbiAgICAgICAgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSksXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuY2xvc2VQb3BvdmVyKCkpO1xuICB9XG5cbiAgLyoqIENsb3NlIHBvcG92ZXIgd2hlbiBlc2NhcGUga2V5ZG93biBldmVudCBvY2N1cnMuICovXG4gIHByaXZhdGUgX3N1YnNjcmliZVRvRXNjYXBlKCk6IHZvaWQge1xuICAgIHRoaXMuX292ZXJsYXlSZWZcbiAgICAgIC5rZXlkb3duRXZlbnRzKClcbiAgICAgIC5waXBlKFxuICAgICAgICB0YXAoZXZlbnQgPT4gdGhpcy5fcG9wb3Zlci5vdmVybGF5S2V5ZG93bi5lbWl0KGV2ZW50KSksXG4gICAgICAgIGZpbHRlcihldmVudCA9PiBldmVudC5rZXlDb2RlID09PSBFU0NBUEUpLFxuICAgICAgICBmaWx0ZXIoKCkgPT4gdGhpcy5fcG9wb3Zlci5pbnRlcmFjdGl2ZUNsb3NlKSxcbiAgICAgICAgdGFrZVVudGlsKHRoaXMucG9wb3ZlckNsb3NlZCksXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpLFxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNsb3NlUG9wb3ZlcigpKTtcbiAgfVxuXG4gIC8qKiBTZXQgc3RhdGUgYmFjayB0byBjbG9zZWQgd2hlbiBkZXRhY2hlZC4gKi9cbiAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9EZXRhY2htZW50cygpOiB2b2lkIHtcbiAgICB0aGlzLl9vdmVybGF5UmVmXG4gICAgICAuZGV0YWNobWVudHMoKVxuICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuX3NhdmVDbG9zZWRTdGF0ZSgpKTtcbiAgfVxuXG4gIC8qKiBTYXZlIHRoZSBvcGVuZWQgc3RhdGUgb2YgdGhlIHBvcG92ZXIgYW5kIGVtaXQuICovXG4gIHByaXZhdGUgX3NhdmVPcGVuZWRTdGF0ZSgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuX3BvcG92ZXJPcGVuKSB7XG4gICAgICB0aGlzLl9wb3BvdmVyLl9vcGVuID0gdGhpcy5fcG9wb3Zlck9wZW4gPSB0cnVlO1xuXG4gICAgICB0aGlzLnBvcG92ZXJPcGVuZWQubmV4dCgpO1xuICAgICAgdGhpcy5fcG9wb3Zlci5vcGVuZWQuZW1pdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBTYXZlIHRoZSBjbG9zZWQgc3RhdGUgb2YgdGhlIHBvcG92ZXIgYW5kIGVtaXQuICovXG4gIHByaXZhdGUgX3NhdmVDbG9zZWRTdGF0ZSh2YWx1ZT86IGFueSk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9wb3BvdmVyT3Blbikge1xuICAgICAgdGhpcy5fcG9wb3Zlci5fb3BlbiA9IHRoaXMuX3BvcG92ZXJPcGVuID0gZmFsc2U7XG5cbiAgICAgIHRoaXMucG9wb3ZlckNsb3NlZC5uZXh0KHZhbHVlKTtcbiAgICAgIHRoaXMuX3BvcG92ZXIuY2xvc2VkLmVtaXQodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBHZXRzIHRoZSB0ZXh0IGRpcmVjdGlvbiBvZiB0aGUgY29udGFpbmluZyBhcHAuICovXG4gIHByaXZhdGUgX2dldERpcmVjdGlvbigpOiBEaXJlY3Rpb24ge1xuICAgIHJldHVybiB0aGlzLl9kaXIgJiYgdGhpcy5fZGlyLnZhbHVlID09PSAncnRsJyA/ICdydGwnIDogJ2x0cic7XG4gIH1cblxuICAvKiogQ3JlYXRlIGFuZCByZXR1cm4gYSBjb25maWcgZm9yIGNyZWF0aW5nIHRoZSBvdmVybGF5LiAqL1xuICBwcml2YXRlIF9nZXRPdmVybGF5Q29uZmlnKGNvbmZpZzogUG9wb3ZlckNvbmZpZywgYW5jaG9yOiBIVE1MRWxlbWVudCk6IE92ZXJsYXlDb25maWcge1xuICAgIHJldHVybiBuZXcgT3ZlcmxheUNvbmZpZyh7XG4gICAgICBwb3NpdGlvblN0cmF0ZWd5OiB0aGlzLl9nZXRQb3NpdGlvblN0cmF0ZWd5KFxuICAgICAgICBjb25maWcuaG9yaXpvbnRhbEFsaWduLFxuICAgICAgICBjb25maWcudmVydGljYWxBbGlnbixcbiAgICAgICAgY29uZmlnLmZvcmNlQWxpZ25tZW50LFxuICAgICAgICBjb25maWcubG9ja0FsaWdubWVudCxcbiAgICAgICAgYW5jaG9yLFxuICAgICAgKSxcbiAgICAgIGhhc0JhY2tkcm9wOiBjb25maWcuaGFzQmFja2Ryb3AsXG4gICAgICBiYWNrZHJvcENsYXNzOiBjb25maWcuYmFja2Ryb3BDbGFzcyB8fCAnY2RrLW92ZXJsYXktdHJhbnNwYXJlbnQtYmFja2Ryb3AnLFxuICAgICAgc2Nyb2xsU3RyYXRlZ3k6IHRoaXMuX2dldFNjcm9sbFN0cmF0ZWd5SW5zdGFuY2UoY29uZmlnLnNjcm9sbFN0cmF0ZWd5KSxcbiAgICAgIGRpcmVjdGlvbjogdGhpcy5fZ2V0RGlyZWN0aW9uKCksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdGVuIHRvIGNoYW5nZXMgaW4gdGhlIHBvc2l0aW9uIG9mIHRoZSBvdmVybGF5IGFuZCBzZXQgdGhlIGNvcnJlY3QgYWxpZ25tZW50IGNsYXNzZXMsXG4gICAqIGVuc3VyaW5nIHRoYXQgdGhlIGFuaW1hdGlvbiBvcmlnaW4gaXMgY29ycmVjdCwgZXZlbiB3aXRoIGEgZmFsbGJhY2sgcG9zaXRpb24uXG4gICAqL1xuICBwcml2YXRlIF9zdWJzY3JpYmVUb1Bvc2l0aW9uQ2hhbmdlcyhwb3NpdGlvbjogRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX3Bvc2l0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLl9wb3NpdGlvbkNoYW5nZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3Bvc2l0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uID0gcG9zaXRpb24ucG9zaXRpb25DaGFuZ2VzXG4gICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSlcbiAgICAgIC5zdWJzY3JpYmUoY2hhbmdlID0+IHtcbiAgICAgICAgLy8gUG9zaXRpb24gY2hhbmdlcyBtYXkgb2NjdXIgb3V0c2lkZSB0aGUgQW5ndWxhciB6b25lXG4gICAgICAgIHRoaXMuX25nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX3BvcG92ZXIuX3NldEFsaWdubWVudENsYXNzZXMoXG4gICAgICAgICAgICBnZXRIb3Jpem9udGFsUG9wb3ZlckFsaWdubWVudChjaGFuZ2UuY29ubmVjdGlvblBhaXIub3ZlcmxheVgpLFxuICAgICAgICAgICAgZ2V0VmVydGljYWxQb3BvdmVyQWxpZ25tZW50KGNoYW5nZS5jb25uZWN0aW9uUGFpci5vdmVybGF5WSksXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKiBNYXAgYSBzY3JvbGwgc3RyYXRlZ3kgc3RyaW5nIHR5cGUgdG8gYW4gaW5zdGFuY2Ugb2YgYSBzY3JvbGwgc3RyYXRlZ3kuICovXG4gIHByaXZhdGUgX2dldFNjcm9sbFN0cmF0ZWd5SW5zdGFuY2Uoc3RyYXRlZ3k6IFNhdFBvcG92ZXJTY3JvbGxTdHJhdGVneSk6IFNjcm9sbFN0cmF0ZWd5IHtcbiAgICBzd2l0Y2ggKHN0cmF0ZWd5KSB7XG4gICAgICBjYXNlICdibG9jayc6XG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMuYmxvY2soKTtcbiAgICAgIGNhc2UgJ3JlcG9zaXRpb24nOlxuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLnJlcG9zaXRpb24oKTtcbiAgICAgIGNhc2UgJ2Nsb3NlJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5jbG9zZSgpO1xuICAgICAgY2FzZSAnbm9vcCc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLm5vb3AoKTtcbiAgICB9XG4gIH1cblxuICAvKiogQ3JlYXRlIGFuZCByZXR1cm4gYSBwb3NpdGlvbiBzdHJhdGVneSBiYXNlZCBvbiBjb25maWcgcHJvdmlkZWQgdG8gdGhlIGNvbXBvbmVudCBpbnN0YW5jZS4gKi9cbiAgcHJpdmF0ZSBfZ2V0UG9zaXRpb25TdHJhdGVneShcbiAgICBob3Jpem9udGFsVGFyZ2V0OiBTYXRQb3BvdmVySG9yaXpvbnRhbEFsaWduLFxuICAgIHZlcnRpY2FsVGFyZ2V0OiBTYXRQb3BvdmVyVmVydGljYWxBbGlnbixcbiAgICBmb3JjZUFsaWdubWVudDogYm9vbGVhbixcbiAgICBsb2NrQWxpZ25tZW50OiBib29sZWFuLFxuICAgIGFuY2hvcjogSFRNTEVsZW1lbnQsXG4gICk6IEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSB7XG4gICAgLy8gQXR0YWNoIHRoZSBvdmVybGF5IGF0IHRoZSBwcmVmZXJyZWQgcG9zaXRpb25cbiAgICBjb25zdCB0YXJnZXRQb3NpdGlvbiA9IGdldFBvc2l0aW9uKGhvcml6b250YWxUYXJnZXQsIHZlcnRpY2FsVGFyZ2V0KTtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBbdGFyZ2V0UG9zaXRpb25dO1xuXG4gICAgY29uc3Qgc3RyYXRlZ3kgPSB0aGlzLl9vdmVybGF5LnBvc2l0aW9uKClcbiAgICAgIC5mbGV4aWJsZUNvbm5lY3RlZFRvKGFuY2hvcilcbiAgICAgIC53aXRoRmxleGlibGVEaW1lbnNpb25zKGZhbHNlKVxuICAgICAgLndpdGhQdXNoKGZhbHNlKVxuICAgICAgLndpdGhWaWV3cG9ydE1hcmdpbigwKVxuICAgICAgLndpdGhMb2NrZWRQb3NpdGlvbihsb2NrQWxpZ25tZW50KTtcblxuICAgIC8vIFVubGVzcyB0aGUgYWxpZ25tZW50IGlzIGZvcmNlZCwgYWRkIGZhbGxiYWNrcyBiYXNlZCBvbiB0aGUgcHJlZmVycmVkIHBvc2l0aW9uc1xuICAgIGlmICghZm9yY2VBbGlnbm1lbnQpIHtcbiAgICAgIGNvbnN0IGZhbGxiYWNrcyA9IHRoaXMuX2dldEZhbGxiYWNrcyhob3Jpem9udGFsVGFyZ2V0LCB2ZXJ0aWNhbFRhcmdldCk7XG4gICAgICBwb3NpdGlvbnMucHVzaCguLi5mYWxsYmFja3MpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJhdGVneS53aXRoUG9zaXRpb25zKHBvc2l0aW9ucyk7XG4gIH1cblxuICAvKiogR2V0IGZhbGxiYWNrIHBvc2l0aW9ucyBiYXNlZCBhcm91bmQgdGFyZ2V0IGFsaWdubWVudHMuICovXG4gIHByaXZhdGUgX2dldEZhbGxiYWNrcyhcbiAgICBoVGFyZ2V0OiBTYXRQb3BvdmVySG9yaXpvbnRhbEFsaWduLFxuICAgIHZUYXJnZXQ6IFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduXG4gICk6IENvbm5lY3Rpb25Qb3NpdGlvblBhaXJbXSB7XG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSB0YXJnZXQgYWxpZ25tZW50cyBvdmVybGFwIHRoZSBhbmNob3JcbiAgICBjb25zdCBob3Jpem9udGFsT3ZlcmxhcEFsbG93ZWQgPSBoVGFyZ2V0ICE9PSAnYmVmb3JlJyAmJiBoVGFyZ2V0ICE9PSAnYWZ0ZXInO1xuICAgIGNvbnN0IHZlcnRpY2FsT3ZlcmxhcEFsbG93ZWQgPSB2VGFyZ2V0ICE9PSAnYWJvdmUnICYmIHZUYXJnZXQgIT09ICdiZWxvdyc7XG5cbiAgICAvLyBJZiBhIHRhcmdldCBhbGlnbm1lbnQgZG9lc24ndCBjb3ZlciB0aGUgYW5jaG9yLCBkb24ndCBsZXQgYW55IG9mIHRoZSBmYWxsYmFjayBhbGlnbm1lbnRzXG4gICAgLy8gY292ZXIgdGhlIGFuY2hvclxuICAgIGNvbnN0IHBvc3NpYmxlSG9yaXpvbnRhbEFsaWdubWVudHM6IFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ25bXSA9XG4gICAgICBob3Jpem9udGFsT3ZlcmxhcEFsbG93ZWQgP1xuICAgICAgICBbJ2JlZm9yZScsICdzdGFydCcsICdjZW50ZXInLCAnZW5kJywgJ2FmdGVyJ10gOlxuICAgICAgICBbJ2JlZm9yZScsICdhZnRlciddO1xuICAgIGNvbnN0IHBvc3NpYmxlVmVydGljYWxBbGlnbm1lbnRzOiBTYXRQb3BvdmVyVmVydGljYWxBbGlnbltdID1cbiAgICAgIHZlcnRpY2FsT3ZlcmxhcEFsbG93ZWQgP1xuICAgICAgICBbJ2Fib3ZlJywgJ3N0YXJ0JywgJ2NlbnRlcicsICdlbmQnLCAnYmVsb3cnXSA6XG4gICAgICAgIFsnYWJvdmUnLCAnYmVsb3cnXTtcblxuICAgIC8vIENyZWF0ZSBmYWxsYmFja3MgZm9yIGVhY2ggYWxsb3dlZCBwcmlvcml0aXplZCBmYWxsYmFjayBhbGlnbm1lbnQgY29tYm9cbiAgICBjb25zdCBmYWxsYmFja3M6IENvbm5lY3Rpb25Qb3NpdGlvblBhaXJbXSA9IFtdO1xuICAgIHByaW9yaXRpemVBcm91bmRUYXJnZXQoaFRhcmdldCwgcG9zc2libGVIb3Jpem9udGFsQWxpZ25tZW50cykuZm9yRWFjaChoID0+IHtcbiAgICAgIHByaW9yaXRpemVBcm91bmRUYXJnZXQodlRhcmdldCwgcG9zc2libGVWZXJ0aWNhbEFsaWdubWVudHMpLmZvckVhY2godiA9PiB7XG4gICAgICAgIGZhbGxiYWNrcy5wdXNoKGdldFBvc2l0aW9uKGgsIHYpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBpdGVtIHNpbmNlIGl0IHdpbGwgYmUgdGhlIHRhcmdldCBhbGlnbm1lbnQgYW5kIGlzbid0IGNvbnNpZGVyZWQgYSBmYWxsYmFja1xuICAgIHJldHVybiBmYWxsYmFja3Muc2xpY2UoMSwgZmFsbGJhY2tzLmxlbmd0aCk7XG4gIH1cblxufVxuXG4vKiogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBhIGNkayBwb3NpdGlvbiBwYWlyIGZyb20gU2F0UG9wb3ZlciBhbGlnbm1lbnRzLiAqL1xuZnVuY3Rpb24gZ2V0UG9zaXRpb24oXG4gIGg6IFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ24sXG4gIHY6IFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduLFxuKTogQ29ubmVjdGlvblBvc2l0aW9uUGFpciB7XG4gIGNvbnN0IHtvcmlnaW5YLCBvdmVybGF5WH0gPSBnZXRIb3Jpem9udGFsQ29ubmVjdGlvblBvc1BhaXIoaCk7XG4gIGNvbnN0IHtvcmlnaW5ZLCBvdmVybGF5WX0gPSBnZXRWZXJ0aWNhbENvbm5lY3Rpb25Qb3NQYWlyKHYpO1xuICByZXR1cm4gbmV3IENvbm5lY3Rpb25Qb3NpdGlvblBhaXIoe29yaWdpblgsIG9yaWdpbll9LCB7b3ZlcmxheVgsIG92ZXJsYXlZfSk7XG59XG5cbi8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBhbiBvdmVybGF5IGNvbm5lY3Rpb24gcG9zaXRpb24gdG8gZXF1aXZhbGVudCBwb3BvdmVyIGFsaWdubWVudC4gKi9cbmZ1bmN0aW9uIGdldEhvcml6b250YWxQb3BvdmVyQWxpZ25tZW50KGg6IEhvcml6b250YWxDb25uZWN0aW9uUG9zKTogU2F0UG9wb3Zlckhvcml6b250YWxBbGlnbiB7XG4gIGlmIChoID09PSAnc3RhcnQnKSB7XG4gICAgcmV0dXJuICdhZnRlcic7XG4gIH1cblxuICBpZiAoaCA9PT0gJ2VuZCcpIHtcbiAgICByZXR1cm4gJ2JlZm9yZSc7XG4gIH1cblxuICByZXR1cm4gJ2NlbnRlcic7XG59XG5cbi8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBhbiBvdmVybGF5IGNvbm5lY3Rpb24gcG9zaXRpb24gdG8gZXF1aXZhbGVudCBwb3BvdmVyIGFsaWdubWVudC4gKi9cbmZ1bmN0aW9uIGdldFZlcnRpY2FsUG9wb3ZlckFsaWdubWVudCh2OiBWZXJ0aWNhbENvbm5lY3Rpb25Qb3MpOiBTYXRQb3BvdmVyVmVydGljYWxBbGlnbiB7XG4gIGlmICh2ID09PSAndG9wJykge1xuICAgIHJldHVybiAnYmVsb3cnO1xuICB9XG5cbiAgaWYgKHYgPT09ICdib3R0b20nKSB7XG4gICAgcmV0dXJuICdhYm92ZSc7XG4gIH1cblxuICByZXR1cm4gJ2NlbnRlcic7XG59XG5cbi8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBhbGlnbm1lbnQgdG8gb3JpZ2luL292ZXJsYXkgcG9zaXRpb24gcGFpci4gKi9cbmZ1bmN0aW9uIGdldEhvcml6b250YWxDb25uZWN0aW9uUG9zUGFpcihoOiBTYXRQb3BvdmVySG9yaXpvbnRhbEFsaWduKTpcbiAgICB7b3JpZ2luWDogSG9yaXpvbnRhbENvbm5lY3Rpb25Qb3MsIG92ZXJsYXlYOiBIb3Jpem9udGFsQ29ubmVjdGlvblBvc30ge1xuICBzd2l0Y2ggKGgpIHtcbiAgICBjYXNlICdiZWZvcmUnOlxuICAgICAgcmV0dXJuIHtvcmlnaW5YOiAnc3RhcnQnLCBvdmVybGF5WDogJ2VuZCd9O1xuICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgIHJldHVybiB7b3JpZ2luWDogJ3N0YXJ0Jywgb3ZlcmxheVg6ICdzdGFydCd9O1xuICAgIGNhc2UgJ2VuZCc6XG4gICAgICByZXR1cm4ge29yaWdpblg6ICdlbmQnLCBvdmVybGF5WDogJ2VuZCd9O1xuICAgIGNhc2UgJ2FmdGVyJzpcbiAgICAgIHJldHVybiB7b3JpZ2luWDogJ2VuZCcsIG92ZXJsYXlYOiAnc3RhcnQnfTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHtvcmlnaW5YOiAnY2VudGVyJywgb3ZlcmxheVg6ICdjZW50ZXInfTtcbiAgfVxufVxuXG4vKiogSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYWxpZ25tZW50IHRvIG9yaWdpbi9vdmVybGF5IHBvc2l0aW9uIHBhaXIuICovXG5mdW5jdGlvbiBnZXRWZXJ0aWNhbENvbm5lY3Rpb25Qb3NQYWlyKHY6IFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduKTpcbiAgICB7b3JpZ2luWTogVmVydGljYWxDb25uZWN0aW9uUG9zLCBvdmVybGF5WTogVmVydGljYWxDb25uZWN0aW9uUG9zfSB7XG4gIHN3aXRjaCAodikge1xuICAgIGNhc2UgJ2Fib3ZlJzpcbiAgICAgIHJldHVybiB7b3JpZ2luWTogJ3RvcCcsIG92ZXJsYXlZOiAnYm90dG9tJ307XG4gICAgY2FzZSAnc3RhcnQnOlxuICAgICAgcmV0dXJuIHtvcmlnaW5ZOiAndG9wJywgb3ZlcmxheVk6ICd0b3AnfTtcbiAgICBjYXNlICdlbmQnOlxuICAgICAgcmV0dXJuIHtvcmlnaW5ZOiAnYm90dG9tJywgb3ZlcmxheVk6ICdib3R0b20nfTtcbiAgICBjYXNlICdiZWxvdyc6XG4gICAgICByZXR1cm4ge29yaWdpblk6ICdib3R0b20nLCBvdmVybGF5WTogJ3RvcCd9O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4ge29yaWdpblk6ICdjZW50ZXInLCBvdmVybGF5WTogJ2NlbnRlcid9O1xuICB9XG59XG5cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBvcmRlcmVkIGFycmF5IG9wdGlvbnMgYW5kIHJldHVybnMgYSByZW9yZGVyZGVkXG4gKiBhcnJheSBhcm91bmQgdGhlIHRhcmdldCBpdGVtLiBlLmcuOlxuICpcbiAqIHRhcmdldDogMzsgb3B0aW9uczogWzEsIDIsIDMsIDQsIDUsIDYsIDddO1xuICpcbiAqIHJldHVybjogWzMsIDQsIDIsIDUsIDEsIDYsIDddXG4gKi9cbmZ1bmN0aW9uIHByaW9yaXRpemVBcm91bmRUYXJnZXQ8VD4odGFyZ2V0OiBULCBvcHRpb25zOiBUW10pOiBUW10ge1xuICBjb25zdCB0YXJnZXRJbmRleCA9IG9wdGlvbnMuaW5kZXhPZih0YXJnZXQpO1xuXG4gIC8vIFNldCB0aGUgZmlyc3QgaXRlbSB0byBiZSB0aGUgdGFyZ2V0XG4gIGNvbnN0IHJlb3JkZXJlZCA9IFt0YXJnZXRdO1xuXG4gIC8vIE1ha2UgbGVmdCBhbmQgcmlnaHQgc3RhY2tzIHdoZXJlIHRoZSBoaWdoZXN0IHByaW9yaXR5IGl0ZW0gaXMgbGFzdFxuICBjb25zdCBsZWZ0ID0gb3B0aW9ucy5zbGljZSgwLCB0YXJnZXRJbmRleCk7XG4gIGNvbnN0IHJpZ2h0ID0gb3B0aW9ucy5zbGljZSh0YXJnZXRJbmRleCArIDEsIG9wdGlvbnMubGVuZ3RoKS5yZXZlcnNlKCk7XG5cbiAgLy8gQWx0ZXJuYXRlIGJldHdlZW4gc3RhY2tzIHVudGlsIG9uZSBpcyBlbXB0eVxuICB3aGlsZSAobGVmdC5sZW5ndGggJiYgcmlnaHQubGVuZ3RoKSB7XG4gICAgcmVvcmRlcmVkLnB1c2gocmlnaHQucG9wKCkpO1xuICAgIHJlb3JkZXJlZC5wdXNoKGxlZnQucG9wKCkpO1xuICB9XG5cbiAgLy8gRmx1c2ggb3V0IHJpZ2h0IHNpZGVcbiAgd2hpbGUgKHJpZ2h0Lmxlbmd0aCkge1xuICAgIHJlb3JkZXJlZC5wdXNoKHJpZ2h0LnBvcCgpKTtcbiAgfVxuXG4gIC8vIEZsdXNoIG91dCBsZWZ0IHNpZGVcbiAgd2hpbGUgKGxlZnQubGVuZ3RoKSB7XG4gICAgcmVvcmRlcmVkLnB1c2gobGVmdC5wb3AoKSk7XG4gIH1cblxuICByZXR1cm4gcmVvcmRlcmVkO1xufVxuIl19