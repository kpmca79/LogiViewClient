/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ElementRef, EventEmitter, Inject, Input, ViewChild, ViewEncapsulation, TemplateRef, Optional, Output, Directive, ViewContainerRef } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { FocusTrapFactory } from '@angular/cdk/a11y';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { transformPopover } from './popover.animations';
import { getUnanchoredPopoverError, getInvalidHorizontalAlignError, getInvalidVerticalAlignError, getInvalidScrollStrategyError, getInvalidPopoverAnchorError, getInvalidSatPopoverAnchorError, getInvalidPopoverError } from './popover.errors';
import { VALID_SCROLL, VALID_HORIZ_ALIGN, VALID_VERT_ALIGN } from './types';
import { SatPopoverAnchoringService } from './popover-anchoring.service';
// See http://cubic-bezier.com/#.25,.8,.25,1 for reference.
/** @type {?} */
var DEFAULT_TRANSITION = '200ms cubic-bezier(0.25, 0.8, 0.25, 1)';
var SatPopoverAnchor = /** @class */ (function () {
    function SatPopoverAnchor(elementRef, viewContainerRef) {
        this.elementRef = elementRef;
        this.viewContainerRef = viewContainerRef;
    }
    Object.defineProperty(SatPopoverAnchor.prototype, "popover", {
        get: /**
         * @return {?}
         */
        function () {
            return this._popover;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            if (val instanceof SatPopover) {
                val.anchor = this;
            }
            else {
                // when a directive is added with no arguments,
                // angular assigns `''` as the argument
                if (val !== '') {
                    throw getInvalidPopoverError();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    SatPopoverAnchor.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        if (!this.popover) {
            throw getInvalidSatPopoverAnchorError();
        }
    };
    SatPopoverAnchor.decorators = [
        { type: Directive, args: [{
                    selector: '[satPopoverAnchor]',
                    exportAs: 'satPopoverAnchor'
                },] }
    ];
    /** @nocollapse */
    SatPopoverAnchor.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ViewContainerRef }
    ]; };
    SatPopoverAnchor.propDecorators = {
        popover: [{ type: Input, args: ['satPopoverAnchor',] }]
    };
    return SatPopoverAnchor;
}());
export { SatPopoverAnchor };
if (false) {
    /**
     * \@internal
     * @type {?}
     */
    SatPopoverAnchor.prototype._popover;
    /** @type {?} */
    SatPopoverAnchor.prototype.elementRef;
    /** @type {?} */
    SatPopoverAnchor.prototype.viewContainerRef;
}
var SatPopover = /** @class */ (function () {
    function SatPopover(_focusTrapFactory, _anchoringService, _viewContainerRef, _document) {
        this._focusTrapFactory = _focusTrapFactory;
        this._viewContainerRef = _viewContainerRef;
        this._document = _document;
        this._horizontalAlign = 'center';
        this._verticalAlign = 'center';
        this._forceAlignment = false;
        this._lockAlignment = false;
        this._autoFocus = true;
        this._autoFocusOverride = true;
        this._restoreFocus = true;
        this._restoreFocusOverride = true;
        this._scrollStrategy = 'reposition';
        this._hasBackdrop = false;
        this._interactiveClose = true;
        this._openTransition = DEFAULT_TRANSITION;
        this._closeTransition = DEFAULT_TRANSITION;
        /**
         * Optional backdrop class.
         */
        this.backdropClass = '';
        /**
         * Emits when the popover is opened.
         */
        this.opened = new EventEmitter();
        /**
         * Emits when the popover is closed.
         */
        this.closed = new EventEmitter();
        /**
         * Emits when the popover has finished opening.
         */
        this.afterOpen = new EventEmitter();
        /**
         * Emits when the popover has finished closing.
         */
        this.afterClose = new EventEmitter();
        /**
         * Emits when the backdrop is clicked.
         */
        this.backdropClicked = new EventEmitter();
        /**
         * Emits when a keydown event is targeted to this popover's overlay.
         */
        this.overlayKeydown = new EventEmitter();
        /**
         * Classes to be added to the popover for setting the correct transform origin.
         */
        this._classList = {};
        /**
         * Whether the popover is presently open.
         */
        this._open = false;
        // `@internal` stripping doesn't seem to work if the property is
        // declared inside the constructor
        this._anchoringService = _anchoringService;
    }
    Object.defineProperty(SatPopover.prototype, "anchor", {
        /** Anchor element. */
        get: /**
         * Anchor element.
         * @return {?}
         */
        function () {
            return this._anchor;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            if (val instanceof SatPopoverAnchor) {
                val._popover = this;
                this._anchoringService.anchor(this, val.viewContainerRef, val.elementRef);
                this._anchor = val;
            }
            else if (val instanceof ElementRef || val instanceof HTMLElement) {
                this._anchoringService.anchor(this, this._viewContainerRef, val);
                this._anchor = val;
            }
            else if (val) {
                throw getInvalidPopoverAnchorError();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "horizontalAlign", {
        /** Alignment of the popover on the horizontal axis. */
        get: /**
         * Alignment of the popover on the horizontal axis.
         * @return {?}
         */
        function () {
            return this._horizontalAlign;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._validateHorizontalAlign(val);
            if (this._horizontalAlign !== val) {
                this._horizontalAlign = val;
                this._anchoringService.repositionPopover();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "xAlign", {
        /** Alignment of the popover on the x axis. Alias for `horizontalAlign`. */
        get: /**
         * Alignment of the popover on the x axis. Alias for `horizontalAlign`.
         * @return {?}
         */
        function () {
            return this.horizontalAlign;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this.horizontalAlign = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "verticalAlign", {
        /** Alignment of the popover on the vertical axis. */
        get: /**
         * Alignment of the popover on the vertical axis.
         * @return {?}
         */
        function () {
            return this._verticalAlign;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._validateVerticalAlign(val);
            if (this._verticalAlign !== val) {
                this._verticalAlign = val;
                this._anchoringService.repositionPopover();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "yAlign", {
        /** Alignment of the popover on the y axis. Alias for `verticalAlign`. */
        get: /**
         * Alignment of the popover on the y axis. Alias for `verticalAlign`.
         * @return {?}
         */
        function () {
            return this.verticalAlign;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this.verticalAlign = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "forceAlignment", {
        /** Whether the popover always opens with the specified alignment. */
        get: /**
         * Whether the popover always opens with the specified alignment.
         * @return {?}
         */
        function () {
            return this._forceAlignment;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            /** @type {?} */
            var coercedVal = coerceBooleanProperty(val);
            if (this._forceAlignment !== coercedVal) {
                this._forceAlignment = coercedVal;
                this._anchoringService.repositionPopover();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "lockAlignment", {
        /**
         * Whether the popover's alignment is locked after opening. This prevents the popover
         * from changing its alignement when scrolling or changing the size of the viewport.
         */
        get: /**
         * Whether the popover's alignment is locked after opening. This prevents the popover
         * from changing its alignement when scrolling or changing the size of the viewport.
         * @return {?}
         */
        function () {
            return this._lockAlignment;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            /** @type {?} */
            var coercedVal = coerceBooleanProperty(val);
            if (this._lockAlignment !== coercedVal) {
                this._lockAlignment = coerceBooleanProperty(val);
                this._anchoringService.repositionPopover();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "autoFocus", {
        /** Whether the first focusable element should be focused on open. */
        get: /**
         * Whether the first focusable element should be focused on open.
         * @return {?}
         */
        function () {
            return this._autoFocus && this._autoFocusOverride;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._autoFocus = coerceBooleanProperty(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "restoreFocus", {
        /** Whether the popover should return focus to the previously focused element after closing. */
        get: /**
         * Whether the popover should return focus to the previously focused element after closing.
         * @return {?}
         */
        function () {
            return this._restoreFocus && this._restoreFocusOverride;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._restoreFocus = coerceBooleanProperty(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "scrollStrategy", {
        /** How the popover should handle scrolling. */
        get: /**
         * How the popover should handle scrolling.
         * @return {?}
         */
        function () {
            return this._scrollStrategy;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._validateScrollStrategy(val);
            if (this._scrollStrategy !== val) {
                this._scrollStrategy = val;
                this._anchoringService.updatePopoverConfig();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "hasBackdrop", {
        /** Whether the popover should have a backdrop (includes closing on click). */
        get: /**
         * Whether the popover should have a backdrop (includes closing on click).
         * @return {?}
         */
        function () {
            return this._hasBackdrop;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._hasBackdrop = coerceBooleanProperty(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "interactiveClose", {
        /** Whether the popover should close when the user clicks the backdrop or presses ESC. */
        get: /**
         * Whether the popover should close when the user clicks the backdrop or presses ESC.
         * @return {?}
         */
        function () {
            return this._interactiveClose;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._interactiveClose = coerceBooleanProperty(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "openTransition", {
        /** Custom transition to use while opening. */
        get: /**
         * Custom transition to use while opening.
         * @return {?}
         */
        function () {
            return this._openTransition;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            if (val) {
                this._openTransition = val;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "closeTransition", {
        /** Custom transition to use while closing. */
        get: /**
         * Custom transition to use while closing.
         * @return {?}
         */
        function () {
            return this._closeTransition;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            if (val) {
                this._closeTransition = val;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    SatPopover.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this._setAlignmentClasses();
    };
    /** Open this popover. */
    /**
     * Open this popover.
     * @param {?=} options
     * @return {?}
     */
    SatPopover.prototype.open = /**
     * Open this popover.
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        if (options === void 0) { options = {}; }
        if (this._anchor) {
            this._anchoringService.openPopover(options);
            return;
        }
        throw getUnanchoredPopoverError();
    };
    /** Close this popover. */
    /**
     * Close this popover.
     * @param {?=} value
     * @return {?}
     */
    SatPopover.prototype.close = /**
     * Close this popover.
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        this._anchoringService.closePopover(value);
    };
    /** Toggle this popover open or closed. */
    /**
     * Toggle this popover open or closed.
     * @return {?}
     */
    SatPopover.prototype.toggle = /**
     * Toggle this popover open or closed.
     * @return {?}
     */
    function () {
        this._anchoringService.togglePopover();
    };
    /** Realign the popover to the anchor. */
    /**
     * Realign the popover to the anchor.
     * @return {?}
     */
    SatPopover.prototype.realign = /**
     * Realign the popover to the anchor.
     * @return {?}
     */
    function () {
        this._anchoringService.realignPopoverToAnchor();
    };
    /** Gets whether the popover is presently open. */
    /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    SatPopover.prototype.isOpen = /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    function () {
        return this._open;
    };
    /** Allows programmatically setting a custom anchor. */
    /**
     * Allows programmatically setting a custom anchor.
     * @param {?} viewContainer
     * @param {?} el
     * @return {?}
     */
    SatPopover.prototype.setCustomAnchor = /**
     * Allows programmatically setting a custom anchor.
     * @param {?} viewContainer
     * @param {?} el
     * @return {?}
     */
    function (viewContainer, el) {
        this._anchor = el;
        this._anchoringService.anchor(this, viewContainer, el);
    };
    /** Gets an animation config with customized (or default) transition values. */
    /**
     * Gets an animation config with customized (or default) transition values.
     * @return {?}
     */
    SatPopover.prototype._getAnimation = /**
     * Gets an animation config with customized (or default) transition values.
     * @return {?}
     */
    function () {
        return {
            value: 'visible',
            params: { openTransition: this.openTransition, closeTransition: this.closeTransition }
        };
    };
    /** Callback for when the popover is finished animating in or out. */
    /**
     * Callback for when the popover is finished animating in or out.
     * @param {?} event
     * @return {?}
     */
    SatPopover.prototype._onAnimationDone = /**
     * Callback for when the popover is finished animating in or out.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.toState === 'visible') {
            this._trapFocus();
            this.afterOpen.emit();
        }
        else if (event.toState === 'void') {
            this._restoreFocusAndDestroyTrap();
            this.afterClose.emit();
        }
    };
    /** Apply alignment classes based on alignment inputs. */
    /**
     * Apply alignment classes based on alignment inputs.
     * @param {?=} horizAlign
     * @param {?=} vertAlign
     * @return {?}
     */
    SatPopover.prototype._setAlignmentClasses = /**
     * Apply alignment classes based on alignment inputs.
     * @param {?=} horizAlign
     * @param {?=} vertAlign
     * @return {?}
     */
    function (horizAlign, vertAlign) {
        if (horizAlign === void 0) { horizAlign = this.horizontalAlign; }
        if (vertAlign === void 0) { vertAlign = this.verticalAlign; }
        this._classList['sat-popover-before'] = horizAlign === 'before' || horizAlign === 'end';
        this._classList['sat-popover-after'] = horizAlign === 'after' || horizAlign === 'start';
        this._classList['sat-popover-above'] = vertAlign === 'above' || vertAlign === 'end';
        this._classList['sat-popover-below'] = vertAlign === 'below' || vertAlign === 'start';
        this._classList['sat-popover-center'] = horizAlign === 'center' || vertAlign === 'center';
    };
    /** Move the focus inside the focus trap and remember where to return later. */
    /**
     * Move the focus inside the focus trap and remember where to return later.
     * @private
     * @return {?}
     */
    SatPopover.prototype._trapFocus = /**
     * Move the focus inside the focus trap and remember where to return later.
     * @private
     * @return {?}
     */
    function () {
        this._savePreviouslyFocusedElement();
        // There won't be a focus trap element if the close animation starts before open finishes
        if (!this._focusTrapElement) {
            return;
        }
        if (!this._focusTrap && this._focusTrapElement) {
            this._focusTrap = this._focusTrapFactory.create(this._focusTrapElement.nativeElement);
        }
        if (this.autoFocus) {
            this._focusTrap.focusInitialElementWhenReady();
        }
    };
    /** Restore focus to the element focused before the popover opened. Also destroy trap. */
    /**
     * Restore focus to the element focused before the popover opened. Also destroy trap.
     * @private
     * @return {?}
     */
    SatPopover.prototype._restoreFocusAndDestroyTrap = /**
     * Restore focus to the element focused before the popover opened. Also destroy trap.
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var toFocus = this._previouslyFocusedElement;
        // Must check active element is focusable for IE sake
        if (toFocus && 'focus' in toFocus && this.restoreFocus) {
            this._previouslyFocusedElement.focus();
        }
        this._previouslyFocusedElement = null;
        if (this._focusTrap) {
            this._focusTrap.destroy();
            this._focusTrap = undefined;
        }
    };
    /** Save a reference to the element focused before the popover was opened. */
    /**
     * Save a reference to the element focused before the popover was opened.
     * @private
     * @return {?}
     */
    SatPopover.prototype._savePreviouslyFocusedElement = /**
     * Save a reference to the element focused before the popover was opened.
     * @private
     * @return {?}
     */
    function () {
        if (this._document) {
            this._previouslyFocusedElement = (/** @type {?} */ (this._document.activeElement));
        }
    };
    /** Throws an error if the alignment is not a valid horizontalAlign. */
    /**
     * Throws an error if the alignment is not a valid horizontalAlign.
     * @private
     * @param {?} pos
     * @return {?}
     */
    SatPopover.prototype._validateHorizontalAlign = /**
     * Throws an error if the alignment is not a valid horizontalAlign.
     * @private
     * @param {?} pos
     * @return {?}
     */
    function (pos) {
        if (VALID_HORIZ_ALIGN.indexOf(pos) === -1) {
            throw getInvalidHorizontalAlignError(pos);
        }
    };
    /** Throws an error if the alignment is not a valid verticalAlign. */
    /**
     * Throws an error if the alignment is not a valid verticalAlign.
     * @private
     * @param {?} pos
     * @return {?}
     */
    SatPopover.prototype._validateVerticalAlign = /**
     * Throws an error if the alignment is not a valid verticalAlign.
     * @private
     * @param {?} pos
     * @return {?}
     */
    function (pos) {
        if (VALID_VERT_ALIGN.indexOf(pos) === -1) {
            throw getInvalidVerticalAlignError(pos);
        }
    };
    /** Throws an error if the scroll strategy is not a valid strategy. */
    /**
     * Throws an error if the scroll strategy is not a valid strategy.
     * @private
     * @param {?} strategy
     * @return {?}
     */
    SatPopover.prototype._validateScrollStrategy = /**
     * Throws an error if the scroll strategy is not a valid strategy.
     * @private
     * @param {?} strategy
     * @return {?}
     */
    function (strategy) {
        if (VALID_SCROLL.indexOf(strategy) === -1) {
            throw getInvalidScrollStrategyError(strategy);
        }
    };
    SatPopover.decorators = [
        { type: Component, args: [{
                    selector: 'sat-popover',
                    encapsulation: ViewEncapsulation.None,
                    animations: [transformPopover],
                    template: "<ng-template>\n  <div class=\"sat-popover-container\"\n      #focusTrapElement\n      [ngClass]=\"_classList\"\n      [@transformPopover]=\"_getAnimation()\"\n      (@transformPopover.done)=\"_onAnimationDone($event)\">\n    <ng-content></ng-content>\n  </div>\n</ng-template>\n",
                    providers: [SatPopoverAnchoringService],
                    styles: [".cdk-global-overlay-wrapper,.cdk-overlay-container{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}@media screen and (-ms-high-contrast:active){.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop,.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}.sat-popover-container.sat-popover-before.sat-popover-above{-webkit-transform-origin:right bottom;transform-origin:right bottom}[dir=rtl] .sat-popover-container.sat-popover-before.sat-popover-above{-webkit-transform-origin:left bottom;transform-origin:left bottom}.sat-popover-container.sat-popover-before.sat-popover-center{-webkit-transform-origin:right center;transform-origin:right center}[dir=rtl] .sat-popover-container.sat-popover-before.sat-popover-center{-webkit-transform-origin:left center;transform-origin:left center}.sat-popover-container.sat-popover-before.sat-popover-below{-webkit-transform-origin:right top;transform-origin:right top}[dir=rtl] .sat-popover-container.sat-popover-before.sat-popover-below{-webkit-transform-origin:left top;transform-origin:left top}.sat-popover-container.sat-popover-center.sat-popover-above{-webkit-transform-origin:center bottom;transform-origin:center bottom}.sat-popover-container.sat-popover-center.sat-popover-below{-webkit-transform-origin:center top;transform-origin:center top}.sat-popover-container.sat-popover-after.sat-popover-above{-webkit-transform-origin:left bottom;transform-origin:left bottom}[dir=rtl] .sat-popover-container.sat-popover-after.sat-popover-above{-webkit-transform-origin:right bottom;transform-origin:right bottom}.sat-popover-container.sat-popover-after.sat-popover-center{-webkit-transform-origin:left center;transform-origin:left center}[dir=rtl] .sat-popover-container.sat-popover-after.sat-popover-center{-webkit-transform-origin:right center;transform-origin:right center}.sat-popover-container.sat-popover-after.sat-popover-below{-webkit-transform-origin:left top;transform-origin:left top}[dir=rtl] .sat-popover-container.sat-popover-after.sat-popover-below{-webkit-transform-origin:right top;transform-origin:right top}"]
                }] }
    ];
    /** @nocollapse */
    SatPopover.ctorParameters = function () { return [
        { type: FocusTrapFactory },
        { type: SatPopoverAnchoringService },
        { type: ViewContainerRef },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
    ]; };
    SatPopover.propDecorators = {
        anchor: [{ type: Input }],
        horizontalAlign: [{ type: Input }],
        xAlign: [{ type: Input }],
        verticalAlign: [{ type: Input }],
        yAlign: [{ type: Input }],
        forceAlignment: [{ type: Input }],
        lockAlignment: [{ type: Input }],
        autoFocus: [{ type: Input }],
        restoreFocus: [{ type: Input }],
        scrollStrategy: [{ type: Input }],
        hasBackdrop: [{ type: Input }],
        interactiveClose: [{ type: Input }],
        openTransition: [{ type: Input }],
        closeTransition: [{ type: Input }],
        backdropClass: [{ type: Input }],
        opened: [{ type: Output }],
        closed: [{ type: Output }],
        afterOpen: [{ type: Output }],
        afterClose: [{ type: Output }],
        backdropClicked: [{ type: Output }],
        overlayKeydown: [{ type: Output }],
        _templateRef: [{ type: ViewChild, args: [TemplateRef, { static: true },] }],
        _focusTrapElement: [{ type: ViewChild, args: ['focusTrapElement', { static: false },] }]
    };
    return SatPopover;
}());
export { SatPopover };
if (false) {
    /**
     * @type {?}
     * @private
     */
    SatPopover.prototype._anchor;
    /**
     * @type {?}
     * @private
     */
    SatPopover.prototype._horizontalAlign;
    /**
     * @type {?}
     * @private
     */
    SatPopover.prototype._verticalAlign;
    /**
     * @type {?}
     * @private
     */
    SatPopover.prototype._forceAlignment;
    /**
     * @type {?}
     * @private
     */
    SatPopover.prototype._lockAlignment;
    /**
     * @type {?}
     * @private
     */
    SatPopover.prototype._autoFocus;
    /** @type {?} */
    SatPopover.prototype._autoFocusOverride;
    /**
     * @type {?}
     * @private
     */
    SatPopover.prototype._restoreFocus;
    /** @type {?} */
    SatPopover.prototype._restoreFocusOverride;
    /**
     * @type {?}
     * @private
     */
    SatPopover.prototype._scrollStrategy;
    /**
     * @type {?}
     * @private
     */
    SatPopover.prototype._hasBackdrop;
    /**
     * @type {?}
     * @private
     */
    SatPopover.prototype._interactiveClose;
    /**
     * @type {?}
     * @private
     */
    SatPopover.prototype._openTransition;
    /**
     * @type {?}
     * @private
     */
    SatPopover.prototype._closeTransition;
    /**
     * Optional backdrop class.
     * @type {?}
     */
    SatPopover.prototype.backdropClass;
    /**
     * Emits when the popover is opened.
     * @type {?}
     */
    SatPopover.prototype.opened;
    /**
     * Emits when the popover is closed.
     * @type {?}
     */
    SatPopover.prototype.closed;
    /**
     * Emits when the popover has finished opening.
     * @type {?}
     */
    SatPopover.prototype.afterOpen;
    /**
     * Emits when the popover has finished closing.
     * @type {?}
     */
    SatPopover.prototype.afterClose;
    /**
     * Emits when the backdrop is clicked.
     * @type {?}
     */
    SatPopover.prototype.backdropClicked;
    /**
     * Emits when a keydown event is targeted to this popover's overlay.
     * @type {?}
     */
    SatPopover.prototype.overlayKeydown;
    /**
     * Reference to template so it can be placed within a portal.
     * @type {?}
     */
    SatPopover.prototype._templateRef;
    /**
     * Classes to be added to the popover for setting the correct transform origin.
     * @type {?}
     */
    SatPopover.prototype._classList;
    /**
     * Whether the popover is presently open.
     * @type {?}
     */
    SatPopover.prototype._open;
    /**
     * \@internal
     * @type {?}
     */
    SatPopover.prototype._anchoringService;
    /**
     * Reference to the element to build a focus trap around.
     * @type {?}
     * @private
     */
    SatPopover.prototype._focusTrapElement;
    /**
     * Reference to the element that was focused before opening.
     * @type {?}
     * @private
     */
    SatPopover.prototype._previouslyFocusedElement;
    /**
     * Reference to a focus trap around the popover.
     * @type {?}
     * @private
     */
    SatPopover.prototype._focusTrap;
    /**
     * @type {?}
     * @private
     */
    SatPopover.prototype._focusTrapFactory;
    /**
     * @type {?}
     * @private
     */
    SatPopover.prototype._viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    SatPopover.prototype._document;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AbmNzdGF0ZS9zYXQtcG9wb3Zlci8iLCJzb3VyY2VzIjpbInBvcG92ZXIvcG9wb3Zlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQ1QsVUFBVSxFQUNWLFlBQVksRUFDWixNQUFNLEVBQ04sS0FBSyxFQUNMLFNBQVMsRUFDVCxpQkFBaUIsRUFDakIsV0FBVyxFQUVYLFFBQVEsRUFDUixNQUFNLEVBQ04sU0FBUyxFQUNULGdCQUFnQixFQUVqQixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUFhLGdCQUFnQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDaEUsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFFOUQsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDeEQsT0FBTyxFQUNMLHlCQUF5QixFQUN6Qiw4QkFBOEIsRUFDOUIsNEJBQTRCLEVBQzVCLDZCQUE2QixFQUM3Qiw0QkFBNEIsRUFDNUIsK0JBQStCLEVBQy9CLHNCQUFzQixFQUN2QixNQUFNLGtCQUFrQixDQUFDO0FBQzFCLE9BQU8sRUFJTCxZQUFZLEVBQ1osaUJBQWlCLEVBQ2pCLGdCQUFnQixFQUVqQixNQUFNLFNBQVMsQ0FBQztBQUNqQixPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQzs7O0lBR25FLGtCQUFrQixHQUFHLHdDQUF3QztBQUVuRTtJQXdCRSwwQkFBbUIsVUFBc0IsRUFBUyxnQkFBa0M7UUFBakUsZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQUFTLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBa0I7SUFBRyxDQUFDO0lBbkJ4RixzQkFDSSxxQ0FBTzs7OztRQURYO1lBRUUsT0FBTyxJQUFJLENB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Ozs7O0lBVTdCLHVDQUFpQzs7Ozs7SUFZakMscUNBQTZDOzs7OztJQVk3QyxzQ0FBOEM7Ozs7O0lBRzlDLG1DQUE0Qjs7Ozs7SUFHNUIsNEJBQTRDOzs7OztJQUc1Qyw0QkFBMkM7Ozs7O0lBRzNDLCtCQUErQzs7Ozs7SUFHL0MsZ0NBQWdEOzs7OztJQUdoRCxxQ0FBcUQ7Ozs7O0lBR3JELG9DQUE2RDs7Ozs7SUFHN0Qsa0NBQXlFOzs7OztJQUd6RSxnQ0FBcUI7Ozs7O0lBR3JCLDJCQUFjOzs7OztJQUdkLHVDQUE4Qzs7Ozs7O0lBRzlDLHVDQUNzQzs7Ozs7O0lBR3RDLCtDQUErQzs7Ozs7O0lBRy9DLGdDQUE4Qjs7Ozs7SUFHNUIsdUNBQTJDOzs7OztJQUUzQyx1Q0FBMkM7Ozs7O0lBQzNDLCtCQUFvRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbmplY3QsXG4gIElucHV0LFxuICBWaWV3Q2hpbGQsXG4gIFZpZXdFbmNhcHN1bGF0aW9uLFxuICBUZW1wbGF0ZVJlZixcbiAgT25Jbml0LFxuICBPcHRpb25hbCxcbiAgT3V0cHV0LFxuICBEaXJlY3RpdmUsXG4gIFZpZXdDb250YWluZXJSZWYsXG4gIEFmdGVyVmlld0luaXRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBbmltYXRpb25FdmVudCB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgRm9jdXNUcmFwLCBGb2N1c1RyYXBGYWN0b3J5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHsgY29lcmNlQm9vbGVhblByb3BlcnR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcblxuaW1wb3J0IHsgdHJhbnNmb3JtUG9wb3ZlciB9IGZyb20gJy4vcG9wb3Zlci5hbmltYXRpb25zJztcbmltcG9ydCB7XG4gIGdldFVuYW5jaG9yZWRQb3BvdmVyRXJyb3IsXG4gIGdldEludmFsaWRIb3Jpem9udGFsQWxpZ25FcnJvcixcbiAgZ2V0SW52YWxpZFZlcnRpY2FsQWxpZ25FcnJvcixcbiAgZ2V0SW52YWxpZFNjcm9sbFN0cmF0ZWd5RXJyb3IsXG4gIGdldEludmFsaWRQb3BvdmVyQW5jaG9yRXJyb3IsXG4gIGdldEludmFsaWRTYXRQb3BvdmVyQW5jaG9yRXJyb3IsXG4gIGdldEludmFsaWRQb3BvdmVyRXJyb3Jcbn0gZnJvbSAnLi9wb3BvdmVyLmVycm9ycyc7XG5pbXBvcnQge1xuICBTYXRQb3BvdmVyU2Nyb2xsU3RyYXRlZ3ksXG4gIFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ24sXG4gIFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduLFxuICBWQUxJRF9TQ1JPTEwsXG4gIFZBTElEX0hPUklaX0FMSUdOLFxuICBWQUxJRF9WRVJUX0FMSUdOLFxuICBTYXRQb3BvdmVyT3Blbk9wdGlvbnNcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBTYXRQb3BvdmVyQW5jaG9yaW5nU2VydmljZSB9IGZyb20gJy4vcG9wb3Zlci1hbmNob3Jpbmcuc2VydmljZSc7XG5cbi8vIFNlZSBodHRwOi8vY3ViaWMtYmV6aWVyLmNvbS8jLjI1LC44LC4yNSwxIGZvciByZWZlcmVuY2UuXG5jb25zdCBERUZBVUxUX1RSQU5TSVRJT04gPSAnMjAwbXMgY3ViaWMtYmV6aWVyKDAuMjUsIDAuOCwgMC4yNSwgMSknO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbc2F0UG9wb3ZlckFuY2hvcl0nLFxuICBleHBvcnRBczogJ3NhdFBvcG92ZXJBbmNob3InXG59KVxuZXhwb3J0IGNsYXNzIFNhdFBvcG92ZXJBbmNob3IgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcbiAgQElucHV0KCdzYXRQb3BvdmVyQW5jaG9yJylcbiAgZ2V0IHBvcG92ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BvcG92ZXI7XG4gIH1cbiAgc2V0IHBvcG92ZXIodmFsOiBTYXRQb3BvdmVyKSB7XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIFNhdFBvcG92ZXIpIHtcbiAgICAgIHZhbC5hbmNob3IgPSB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB3aGVuIGEgZGlyZWN0aXZlIGlzIGFkZGVkIHdpdGggbm8gYXJndW1lbnRzLFxuICAgICAgLy8gYW5ndWxhciBhc3NpZ25zIGAnJ2AgYXMgdGhlIGFyZ3VtZW50XG4gICAgICBpZiAodmFsICE9PSAnJykge1xuICAgICAgICB0aHJvdyBnZXRJbnZhbGlkUG9wb3ZlckVycm9yKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcG9wb3ZlcjogU2F0UG9wb3ZlcjtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHVibGljIHZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYpIHt9XG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIGlmICghdGhpcy5wb3BvdmVyKSB7XG4gICAgICB0aHJvdyBnZXRJbnZhbGlkU2F0UG9wb3ZlckFuY2hvckVycm9yKCk7XG4gICAgfVxuICB9XG59XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3NhdC1wb3BvdmVyJyxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgYW5pbWF0aW9uczogW3RyYW5zZm9ybVBvcG92ZXJdLFxuICBzdHlsZVVybHM6IFsnLi9wb3BvdmVyLmNvbXBvbmVudC5zY3NzJ10sXG4gIHRlbXBsYXRlVXJsOiAnLi9wb3BvdmVyLmNvbXBvbmVudC5odG1sJyxcbiAgcHJvdmlkZXJzOiBbU2F0UG9wb3ZlckFuY2hvcmluZ1NlcnZpY2VdXG59KVxuZXhwb3J0IGNsYXNzIFNhdFBvcG92ZXIgaW1wbGVtZW50cyBPbkluaXQge1xuICAvKiogQW5jaG9yIGVsZW1lbnQuICovXG4gIEBJbnB1dCgpXG4gIGdldCBhbmNob3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FuY2hvcjtcbiAgfVxuICBzZXQgYW5jaG9yKHZhbDogU2F0UG9wb3ZlckFuY2hvciB8IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+IHwgSFRNTEVsZW1lbnQpIHtcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgU2F0UG9wb3ZlckFuY2hvcikge1xuICAgICAgdmFsLl9wb3BvdmVyID0gdGhpcztcbiAgICAgIHRoaXMuX2FuY2hvcmluZ1NlcnZpY2UuYW5jaG9yKHRoaXMsIHZhbC52aWV3Q29udGFpbmVyUmVmLCB2YWwuZWxlbWVudFJlZik7XG4gICAgICB0aGlzLl9hbmNob3IgPSB2YWw7XG4gICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBFbGVtZW50UmVmIHx8IHZhbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICB0aGlzLl9hbmNob3JpbmdTZXJ2aWNlLmFuY2hvcih0aGlzLCB0aGlzLl92aWV3Q29udGFpbmVyUmVmLCB2YWwpO1xuICAgICAgdGhpcy5fYW5jaG9yID0gdmFsO1xuICAgIH0gZWxzZSBpZiAodmFsKSB7XG4gICAgICB0aHJvdyBnZXRJbnZhbGlkUG9wb3ZlckFuY2hvckVycm9yKCk7XG4gICAgfVxuICB9XG4gIHByaXZhdGUgX2FuY2hvcjogU2F0UG9wb3ZlckFuY2hvciB8IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+IHwgSFRNTEVsZW1lbnQ7XG5cbiAgLyoqIEFsaWdubWVudCBvZiB0aGUgcG9wb3ZlciBvbiB0aGUgaG9yaXpvbnRhbCBheGlzLiAqL1xuICBASW5wdXQoKVxuICBnZXQgaG9yaXpvbnRhbEFsaWduKCkge1xuICAgIHJldHVybiB0aGlzLl9ob3Jpem9udGFsQWxpZ247XG4gIH1cbiAgc2V0IGhvcml6b250YWxBbGlnbih2YWw6IFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ24pIHtcbiAgICB0aGlzLl92YWxpZGF0ZUhvcml6b250YWxBbGlnbih2YWwpO1xuICAgIGlmICh0aGlzLl9ob3Jpem9udGFsQWxpZ24gIT09IHZhbCkge1xuICAgICAgdGhpcy5faG9yaXpvbnRhbEFsaWduID0gdmFsO1xuICAgICAgdGhpcy5fYW5jaG9yaW5nU2VydmljZS5yZXBvc2l0aW9uUG9wb3ZlcigpO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIF9ob3Jpem9udGFsQWxpZ246IFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ24gPSAnY2VudGVyJztcblxuICAvKiogQWxpZ25tZW50IG9mIHRoZSBwb3BvdmVyIG9uIHRoZSB4IGF4aXMuIEFsaWFzIGZvciBgaG9yaXpvbnRhbEFsaWduYC4gKi9cbiAgQElucHV0KClcbiAgZ2V0IHhBbGlnbigpIHtcbiAgICByZXR1cm4gdGhpcy5ob3Jpem9udGFsQWxpZ247XG4gIH1cbiAgc2V0IHhBbGlnbih2YWw6IFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ24pIHtcbiAgICB0aGlzLmhvcml6b250YWxBbGlnbiA9IHZhbDtcbiAgfVxuXG4gIC8qKiBBbGlnbm1lbnQgb2YgdGhlIHBvcG92ZXIgb24gdGhlIHZlcnRpY2FsIGF4aXMuICovXG4gIEBJbnB1dCgpXG4gIGdldCB2ZXJ0aWNhbEFsaWduKCkge1xuICAgIHJldHVybiB0aGlzLl92ZXJ0aWNhbEFsaWduO1xuICB9XG4gIHNldCB2ZXJ0aWNhbEFsaWduKHZhbDogU2F0UG9wb3ZlclZlcnRpY2FsQWxpZ24pIHtcbiAgICB0aGlzLl92YWxpZGF0ZVZlcnRpY2FsQWxpZ24odmFsKTtcbiAgICBpZiAodGhpcy5fdmVydGljYWxBbGlnbiAhPT0gdmFsKSB7XG4gICAgICB0aGlzLl92ZXJ0aWNhbEFsaWduID0gdmFsO1xuICAgICAgdGhpcy5fYW5jaG9yaW5nU2VydmljZS5yZXBvc2l0aW9uUG9wb3ZlcigpO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIF92ZXJ0aWNhbEFsaWduOiBTYXRQb3BvdmVyVmVydGljYWxBbGlnbiA9ICdjZW50ZXInO1xuXG4gIC8qKiBBbGlnbm1lbnQgb2YgdGhlIHBvcG92ZXIgb24gdGhlIHkgYXhpcy4gQWxpYXMgZm9yIGB2ZXJ0aWNhbEFsaWduYC4gKi9cbiAgQElucHV0KClcbiAgZ2V0IHlBbGlnbigpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJ0aWNhbEFsaWduO1xuICB9XG4gIHNldCB5QWxpZ24odmFsOiBTYXRQb3BvdmVyVmVydGljYWxBbGlnbikge1xuICAgIHRoaXMudmVydGljYWxBbGlnbiA9IHZhbDtcbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIGFsd2F5cyBvcGVucyB3aXRoIHRoZSBzcGVjaWZpZWQgYWxpZ25tZW50LiAqL1xuICBASW5wdXQoKVxuICBnZXQgZm9yY2VBbGlnbm1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvcmNlQWxpZ25tZW50O1xuICB9XG4gIHNldCBmb3JjZUFsaWdubWVudCh2YWw6IGJvb2xlYW4pIHtcbiAgICBjb25zdCBjb2VyY2VkVmFsID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbCk7XG4gICAgaWYgKHRoaXMuX2ZvcmNlQWxpZ25tZW50ICE9PSBjb2VyY2VkVmFsKSB7XG4gICAgICB0aGlzLl9mb3JjZUFsaWdubWVudCA9IGNvZXJjZWRWYWw7XG4gICAgICB0aGlzLl9hbmNob3JpbmdTZXJ2aWNlLnJlcG9zaXRpb25Qb3BvdmVyKCk7XG4gICAgfVxuICB9XG4gIHByaXZhdGUgX2ZvcmNlQWxpZ25tZW50ID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHBvcG92ZXIncyBhbGlnbm1lbnQgaXMgbG9ja2VkIGFmdGVyIG9wZW5pbmcuIFRoaXMgcHJldmVudHMgdGhlIHBvcG92ZXJcbiAgICogZnJvbSBjaGFuZ2luZyBpdHMgYWxpZ25lbWVudCB3aGVuIHNjcm9sbGluZyBvciBjaGFuZ2luZyB0aGUgc2l6ZSBvZiB0aGUgdmlld3BvcnQuXG4gICAqL1xuICBASW5wdXQoKVxuICBnZXQgbG9ja0FsaWdubWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9ja0FsaWdubWVudDtcbiAgfVxuICBzZXQgbG9ja0FsaWdubWVudCh2YWw6IGJvb2xlYW4pIHtcbiAgICBjb25zdCBjb2VyY2VkVmFsID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbCk7XG4gICAgaWYgKHRoaXMuX2xvY2tBbGlnbm1lbnQgIT09IGNvZXJjZWRWYWwpIHtcbiAgICAgIHRoaXMuX2xvY2tBbGlnbm1lbnQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsKTtcbiAgICAgIHRoaXMuX2FuY2hvcmluZ1NlcnZpY2UucmVwb3NpdGlvblBvcG92ZXIoKTtcbiAgICB9XG4gIH1cbiAgcHJpdmF0ZSBfbG9ja0FsaWdubWVudCA9IGZhbHNlO1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBmaXJzdCBmb2N1c2FibGUgZWxlbWVudCBzaG91bGQgYmUgZm9jdXNlZCBvbiBvcGVuLiAqL1xuICBASW5wdXQoKVxuICBnZXQgYXV0b0ZvY3VzKCkge1xuICAgIHJldHVybiB0aGlzLl9hdXRvRm9jdXMgJiYgdGhpcy5fYXV0b0ZvY3VzT3ZlcnJpZGU7XG4gIH1cbiAgc2V0IGF1dG9Gb2N1cyh2YWw6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9hdXRvRm9jdXMgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsKTtcbiAgfVxuICBwcml2YXRlIF9hdXRvRm9jdXMgPSB0cnVlO1xuICBfYXV0b0ZvY3VzT3ZlcnJpZGUgPSB0cnVlO1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIHNob3VsZCByZXR1cm4gZm9jdXMgdG8gdGhlIHByZXZpb3VzbHkgZm9jdXNlZCBlbGVtZW50IGFmdGVyIGNsb3NpbmcuICovXG4gIEBJbnB1dCgpXG4gIGdldCByZXN0b3JlRm9jdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc3RvcmVGb2N1cyAmJiB0aGlzLl9yZXN0b3JlRm9jdXNPdmVycmlkZTtcbiAgfVxuICBzZXQgcmVzdG9yZUZvY3VzKHZhbDogYm9vbGVhbikge1xuICAgIHRoaXMuX3Jlc3RvcmVGb2N1cyA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWwpO1xuICB9XG4gIHByaXZhdGUgX3Jlc3RvcmVGb2N1cyA9IHRydWU7XG4gIF9yZXN0b3JlRm9jdXNPdmVycmlkZSA9IHRydWU7XG5cbiAgLyoqIEhvdyB0aGUgcG9wb3ZlciBzaG91bGQgaGFuZGxlIHNjcm9sbGluZy4gKi9cbiAgQElucHV0KClcbiAgZ2V0IHNjcm9sbFN0cmF0ZWd5KCkge1xuICAgIHJldHVybiB0aGlzLl9zY3JvbGxTdHJhdGVneTtcbiAgfVxuICBzZXQgc2Nyb2xsU3RyYXRlZ3kodmFsOiBTYXRQb3BvdmVyU2Nyb2xsU3RyYXRlZ3kpIHtcbiAgICB0aGlzLl92YWxpZGF0ZVNjcm9sbFN0cmF0ZWd5KHZhbCk7XG4gICAgaWYgKHRoaXMuX3Njcm9sbFN0cmF0ZWd5ICE9PSB2YWwpIHtcbiAgICAgIHRoaXMuX3Njcm9sbFN0cmF0ZWd5ID0gdmFsO1xuICAgICAgdGhpcy5fYW5jaG9yaW5nU2VydmljZS51cGRhdGVQb3BvdmVyQ29uZmlnKCk7XG4gICAgfVxuICB9XG4gIHByaXZhdGUgX3Njcm9sbFN0cmF0ZWd5OiBTYXRQb3BvdmVyU2Nyb2xsU3RyYXRlZ3kgPSAncmVwb3NpdGlvbic7XG5cbiAgLyoqIFdoZXRoZXIgdGhlIHBvcG92ZXIgc2hvdWxkIGhhdmUgYSBiYWNrZHJvcCAoaW5jbHVkZXMgY2xvc2luZyBvbiBjbGljaykuICovXG4gIEBJbnB1dCgpXG4gIGdldCBoYXNCYWNrZHJvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5faGFzQmFja2Ryb3A7XG4gIH1cbiAgc2V0IGhhc0JhY2tkcm9wKHZhbDogYm9vbGVhbikge1xuICAgIHRoaXMuX2hhc0JhY2tkcm9wID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbCk7XG4gIH1cbiAgcHJpdmF0ZSBfaGFzQmFja2Ryb3AgPSBmYWxzZTtcblxuICAvKiogV2hldGhlciB0aGUgcG9wb3ZlciBzaG91bGQgY2xvc2Ugd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlIGJhY2tkcm9wIG9yIHByZXNzZXMgRVNDLiAqL1xuICBASW5wdXQoKVxuICBnZXQgaW50ZXJhY3RpdmVDbG9zZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW50ZXJhY3RpdmVDbG9zZTtcbiAgfVxuICBzZXQgaW50ZXJhY3RpdmVDbG9zZSh2YWw6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9pbnRlcmFjdGl2ZUNsb3NlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbCk7XG4gIH1cbiAgcHJpdmF0ZSBfaW50ZXJhY3RpdmVDbG9zZSA9IHRydWU7XG5cbiAgLyoqIEN1c3RvbSB0cmFuc2l0aW9uIHRvIHVzZSB3aGlsZSBvcGVuaW5nLiAqL1xuICBASW5wdXQoKVxuICBnZXQgb3BlblRyYW5zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wZW5UcmFuc2l0aW9uO1xuICB9XG4gIHNldCBvcGVuVHJhbnNpdGlvbih2YWw6IHN0cmluZykge1xuICAgIGlmICh2YWwpIHtcbiAgICAgIHRoaXMuX29wZW5UcmFuc2l0aW9uID0gdmFsO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIF9vcGVuVHJhbnNpdGlvbiA9IERFRkFVTFRfVFJBTlNJVElPTjtcblxuICAvKiogQ3VzdG9tIHRyYW5zaXRpb24gdG8gdXNlIHdoaWxlIGNsb3NpbmcuICovXG4gIEBJbnB1dCgpXG4gIGdldCBjbG9zZVRyYW5zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nsb3NlVHJhbnNpdGlvbjtcbiAgfVxuICBzZXQgY2xvc2VUcmFuc2l0aW9uKHZhbDogc3RyaW5nKSB7XG4gICAgaWYgKHZhbCkge1xuICAgICAgdGhpcy5fY2xvc2VUcmFuc2l0aW9uID0gdmFsO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIF9jbG9zZVRyYW5zaXRpb24gPSBERUZBVUxUX1RSQU5TSVRJT047XG5cbiAgLyoqIE9wdGlvbmFsIGJhY2tkcm9wIGNsYXNzLiAqL1xuICBASW5wdXQoKSBiYWNrZHJvcENsYXNzID0gJyc7XG5cbiAgLyoqIEVtaXRzIHdoZW4gdGhlIHBvcG92ZXIgaXMgb3BlbmVkLiAqL1xuICBAT3V0cHV0KCkgb3BlbmVkID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSBwb3BvdmVyIGlzIGNsb3NlZC4gKi9cbiAgQE91dHB1dCgpIGNsb3NlZCA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSBwb3BvdmVyIGhhcyBmaW5pc2hlZCBvcGVuaW5nLiAqL1xuICBAT3V0cHV0KCkgYWZ0ZXJPcGVuID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSBwb3BvdmVyIGhhcyBmaW5pc2hlZCBjbG9zaW5nLiAqL1xuICBAT3V0cHV0KCkgYWZ0ZXJDbG9zZSA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgYmFja2Ryb3AgaXMgY2xpY2tlZC4gKi9cbiAgQE91dHB1dCgpIGJhY2tkcm9wQ2xpY2tlZCA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAvKiogRW1pdHMgd2hlbiBhIGtleWRvd24gZXZlbnQgaXMgdGFyZ2V0ZWQgdG8gdGhpcyBwb3BvdmVyJ3Mgb3ZlcmxheS4gKi9cbiAgQE91dHB1dCgpIG92ZXJsYXlLZXlkb3duID0gbmV3IEV2ZW50RW1pdHRlcjxLZXlib2FyZEV2ZW50PigpO1xuXG4gIC8qKiBSZWZlcmVuY2UgdG8gdGVtcGxhdGUgc28gaXQgY2FuIGJlIHBsYWNlZCB3aXRoaW4gYSBwb3J0YWwuICovXG4gIEBWaWV3Q2hpbGQoVGVtcGxhdGVSZWYsIHsgc3RhdGljOiB0cnVlIH0pIF90ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55PjtcblxuICAvKiogQ2xhc3NlcyB0byBiZSBhZGRlZCB0byB0aGUgcG9wb3ZlciBmb3Igc2V0dGluZyB0aGUgY29ycmVjdCB0cmFuc2Zvcm0gb3JpZ2luLiAqL1xuICBfY2xhc3NMaXN0OiBhbnkgPSB7fTtcblxuICAvKiogV2hldGhlciB0aGUgcG9wb3ZlciBpcyBwcmVzZW50bHkgb3Blbi4gKi9cbiAgX29wZW4gPSBmYWxzZTtcblxuICAvKiogQGludGVybmFsICovXG4gIF9hbmNob3JpbmdTZXJ2aWNlOiBTYXRQb3BvdmVyQW5jaG9yaW5nU2VydmljZTtcblxuICAvKiogUmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50IHRvIGJ1aWxkIGEgZm9jdXMgdHJhcCBhcm91bmQuICovXG4gIEBWaWV3Q2hpbGQoJ2ZvY3VzVHJhcEVsZW1lbnQnLCB7IHN0YXRpYzogZmFsc2UgfSlcbiAgcHJpdmF0ZSBfZm9jdXNUcmFwRWxlbWVudDogRWxlbWVudFJlZjtcblxuICAvKiogUmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50IHRoYXQgd2FzIGZvY3VzZWQgYmVmb3JlIG9wZW5pbmcuICovXG4gIHByaXZhdGUgX3ByZXZpb3VzbHlGb2N1c2VkRWxlbWVudDogSFRNTEVsZW1lbnQ7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byBhIGZvY3VzIHRyYXAgYXJvdW5kIHRoZSBwb3BvdmVyLiAqL1xuICBwcml2YXRlIF9mb2N1c1RyYXA6IEZvY3VzVHJhcDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9mb2N1c1RyYXBGYWN0b3J5OiBGb2N1c1RyYXBGYWN0b3J5LFxuICAgIF9hbmNob3JpbmdTZXJ2aWNlOiBTYXRQb3BvdmVyQW5jaG9yaW5nU2VydmljZSxcbiAgICBwcml2YXRlIF92aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoRE9DVU1FTlQpIHByaXZhdGUgX2RvY3VtZW50OiBhbnlcbiAgKSB7XG4gICAgLy8gYEBpbnRlcm5hbGAgc3RyaXBwaW5nIGRvZXNuJ3Qgc2VlbSB0byB3b3JrIGlmIHRoZSBwcm9wZXJ0eSBpc1xuICAgIC8vIGRlY2xhcmVkIGluc2lkZSB0aGUgY29uc3RydWN0b3JcbiAgICB0aGlzLl9hbmNob3JpbmdTZXJ2aWNlID0gX2FuY2hvcmluZ1NlcnZpY2U7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLl9zZXRBbGlnbm1lbnRDbGFzc2VzKCk7XG4gIH1cblxuICAvKiogT3BlbiB0aGlzIHBvcG92ZXIuICovXG4gIG9wZW4ob3B0aW9uczogU2F0UG9wb3Zlck9wZW5PcHRpb25zID0ge30pOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fYW5jaG9yKSB7XG4gICAgICB0aGlzLl9hbmNob3JpbmdTZXJ2aWNlLm9wZW5Qb3BvdmVyKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRocm93IGdldFVuYW5jaG9yZWRQb3BvdmVyRXJyb3IoKTtcbiAgfVxuXG4gIC8qKiBDbG9zZSB0aGlzIHBvcG92ZXIuICovXG4gIGNsb3NlKHZhbHVlPzogYW55KTogdm9pZCB7XG4gICAgdGhpcy5fYW5jaG9yaW5nU2VydmljZS5jbG9zZVBvcG92ZXIodmFsdWUpO1xuICB9XG5cbiAgLyoqIFRvZ2dsZSB0aGlzIHBvcG92ZXIgb3BlbiBvciBjbG9zZWQuICovXG4gIHRvZ2dsZSgpOiB2b2lkIHtcbiAgICB0aGlzLl9hbmNob3JpbmdTZXJ2aWNlLnRvZ2dsZVBvcG92ZXIoKTtcbiAgfVxuXG4gIC8qKiBSZWFsaWduIHRoZSBwb3BvdmVyIHRvIHRoZSBhbmNob3IuICovXG4gIHJlYWxpZ24oKTogdm9pZCB7XG4gICAgdGhpcy5fYW5jaG9yaW5nU2VydmljZS5yZWFsaWduUG9wb3ZlclRvQW5jaG9yKCk7XG4gIH1cblxuICAvKiogR2V0cyB3aGV0aGVyIHRoZSBwb3BvdmVyIGlzIHByZXNlbnRseSBvcGVuLiAqL1xuICBpc09wZW4oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX29wZW47XG4gIH1cblxuICAvKiogQWxsb3dzIHByb2dyYW1tYXRpY2FsbHkgc2V0dGluZyBhIGN1c3RvbSBhbmNob3IuICovXG4gIHNldEN1c3RvbUFuY2hvcih2aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLCBlbDogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4gfCBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAgIHRoaXMuX2FuY2hvciA9IGVsO1xuICAgIHRoaXMuX2FuY2hvcmluZ1NlcnZpY2UuYW5jaG9yKHRoaXMsIHZpZXdDb250YWluZXIsIGVsKTtcbiAgfVxuXG4gIC8qKiBHZXRzIGFuIGFuaW1hdGlvbiBjb25maWcgd2l0aCBjdXN0b21pemVkIChvciBkZWZhdWx0KSB0cmFuc2l0aW9uIHZhbHVlcy4gKi9cbiAgX2dldEFuaW1hdGlvbigpOiB7IHZhbHVlOiBhbnk7IHBhcmFtczogYW55IH0ge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogJ3Zpc2libGUnLFxuICAgICAgcGFyYW1zOiB7IG9wZW5UcmFuc2l0aW9uOiB0aGlzLm9wZW5UcmFuc2l0aW9uLCBjbG9zZVRyYW5zaXRpb246IHRoaXMuY2xvc2VUcmFuc2l0aW9uIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqIENhbGxiYWNrIGZvciB3aGVuIHRoZSBwb3BvdmVyIGlzIGZpbmlzaGVkIGFuaW1hdGluZyBpbiBvciBvdXQuICovXG4gIF9vbkFuaW1hdGlvbkRvbmUoZXZlbnQ6IEFuaW1hdGlvbkV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRvU3RhdGUgPT09ICd2aXNpYmxlJykge1xuICAgICAgdGhpcy5fdHJhcEZvY3VzKCk7XG4gICAgICB0aGlzLmFmdGVyT3Blbi5lbWl0KCk7XG4gICAgfSBlbHNlIGlmIChldmVudC50b1N0YXRlID09PSAndm9pZCcpIHtcbiAgICAgIHRoaXMuX3Jlc3RvcmVGb2N1c0FuZERlc3Ryb3lUcmFwKCk7XG4gICAgICB0aGlzLmFmdGVyQ2xvc2UuZW1pdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBBcHBseSBhbGlnbm1lbnQgY2xhc3NlcyBiYXNlZCBvbiBhbGlnbm1lbnQgaW5wdXRzLiAqL1xuICBfc2V0QWxpZ25tZW50Q2xhc3Nlcyhob3JpekFsaWduID0gdGhpcy5ob3Jpem9udGFsQWxpZ24sIHZlcnRBbGlnbiA9IHRoaXMudmVydGljYWxBbGlnbikge1xuICAgIHRoaXMuX2NsYXNzTGlzdFsnc2F0LXBvcG92ZXItYmVmb3JlJ10gPSBob3JpekFsaWduID09PSAnYmVmb3JlJyB8fCBob3JpekFsaWduID09PSAnZW5kJztcbiAgICB0aGlzLl9jbGFzc0xpc3RbJ3NhdC1wb3BvdmVyLWFmdGVyJ10gPSBob3JpekFsaWduID09PSAnYWZ0ZXInIHx8IGhvcml6QWxpZ24gPT09ICdzdGFydCc7XG5cbiAgICB0aGlzLl9jbGFzc0xpc3RbJ3NhdC1wb3BvdmVyLWFib3ZlJ10gPSB2ZXJ0QWxpZ24gPT09ICdhYm92ZScgfHwgdmVydEFsaWduID09PSAnZW5kJztcbiAgICB0aGlzLl9jbGFzc0xpc3RbJ3NhdC1wb3BvdmVyLWJlbG93J10gPSB2ZXJ0QWxpZ24gPT09ICdiZWxvdycgfHwgdmVydEFsaWduID09PSAnc3RhcnQnO1xuXG4gICAgdGhpcy5fY2xhc3NMaXN0WydzYXQtcG9wb3Zlci1jZW50ZXInXSA9IGhvcml6QWxpZ24gPT09ICdjZW50ZXInIHx8IHZlcnRBbGlnbiA9PT0gJ2NlbnRlcic7XG4gIH1cblxuICAvKiogTW92ZSB0aGUgZm9jdXMgaW5zaWRlIHRoZSBmb2N1cyB0cmFwIGFuZCByZW1lbWJlciB3aGVyZSB0byByZXR1cm4gbGF0ZXIuICovXG4gIHByaXZhdGUgX3RyYXBGb2N1cygpOiB2b2lkIHtcbiAgICB0aGlzLl9zYXZlUHJldmlvdXNseUZvY3VzZWRFbGVtZW50KCk7XG5cbiAgICAvLyBUaGVyZSB3b24ndCBiZSBhIGZvY3VzIHRyYXAgZWxlbWVudCBpZiB0aGUgY2xvc2UgYW5pbWF0aW9uIHN0YXJ0cyBiZWZvcmUgb3BlbiBmaW5pc2hlc1xuICAgIGlmICghdGhpcy5fZm9jdXNUcmFwRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZm9jdXNUcmFwICYmIHRoaXMuX2ZvY3VzVHJhcEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX2ZvY3VzVHJhcCA9IHRoaXMuX2ZvY3VzVHJhcEZhY3RvcnkuY3JlYXRlKHRoaXMuX2ZvY3VzVHJhcEVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYXV0b0ZvY3VzKSB7XG4gICAgICB0aGlzLl9mb2N1c1RyYXAuZm9jdXNJbml0aWFsRWxlbWVudFdoZW5SZWFkeSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBSZXN0b3JlIGZvY3VzIHRvIHRoZSBlbGVtZW50IGZvY3VzZWQgYmVmb3JlIHRoZSBwb3BvdmVyIG9wZW5lZC4gQWxzbyBkZXN0cm95IHRyYXAuICovXG4gIHByaXZhdGUgX3Jlc3RvcmVGb2N1c0FuZERlc3Ryb3lUcmFwKCk6IHZvaWQge1xuICAgIGNvbnN0IHRvRm9jdXMgPSB0aGlzLl9wcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQ7XG5cbiAgICAvLyBNdXN0IGNoZWNrIGFjdGl2ZSBlbGVtZW50IGlzIGZvY3VzYWJsZSBmb3IgSUUgc2FrZVxuICAgIGlmICh0b0ZvY3VzICYmICdmb2N1cycgaW4gdG9Gb2N1cyAmJiB0aGlzLnJlc3RvcmVGb2N1cykge1xuICAgICAgdGhpcy5fcHJldmlvdXNseUZvY3VzZWRFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID0gbnVsbDtcblxuICAgIGlmICh0aGlzLl9mb2N1c1RyYXApIHtcbiAgICAgIHRoaXMuX2ZvY3VzVHJhcC5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9mb2N1c1RyYXAgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqIFNhdmUgYSByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgZm9jdXNlZCBiZWZvcmUgdGhlIHBvcG92ZXIgd2FzIG9wZW5lZC4gKi9cbiAgcHJpdmF0ZSBfc2F2ZVByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fZG9jdW1lbnQpIHtcbiAgICAgIHRoaXMuX3ByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCA9IHRoaXMuX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQgYXMgSFRNTEVsZW1lbnQ7XG4gICAgfVxuICB9XG5cbiAgLyoqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgYWxpZ25tZW50IGlzIG5vdCBhIHZhbGlkIGhvcml6b250YWxBbGlnbi4gKi9cbiAgcHJpdmF0ZSBfdmFsaWRhdGVIb3Jpem9udGFsQWxpZ24ocG9zOiBTYXRQb3BvdmVySG9yaXpvbnRhbEFsaWduKTogdm9pZCB7XG4gICAgaWYgKFZBTElEX0hPUklaX0FMSUdOLmluZGV4T2YocG9zKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IGdldEludmFsaWRIb3Jpem9udGFsQWxpZ25FcnJvcihwb3MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGFsaWdubWVudCBpcyBub3QgYSB2YWxpZCB2ZXJ0aWNhbEFsaWduLiAqL1xuICBwcml2YXRlIF92YWxpZGF0ZVZlcnRpY2FsQWxpZ24ocG9zOiBTYXRQb3BvdmVyVmVydGljYWxBbGlnbik6IHZvaWQge1xuICAgIGlmIChWQUxJRF9WRVJUX0FMSUdOLmluZGV4T2YocG9zKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IGdldEludmFsaWRWZXJ0aWNhbEFsaWduRXJyb3IocG9zKTtcbiAgICB9XG4gIH1cblxuICAvKiogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBzY3JvbGwgc3RyYXRlZ3kgaXMgbm90IGEgdmFsaWQgc3RyYXRlZ3kuICovXG4gIHByaXZhdGUgX3ZhbGlkYXRlU2Nyb2xsU3RyYXRlZ3koc3RyYXRlZ3k6IFNhdFBvcG92ZXJTY3JvbGxTdHJhdGVneSk6IHZvaWQge1xuICAgIGlmIChWQUxJRF9TQ1JPTEwuaW5kZXhPZihzdHJhdGVneSkgPT09IC0xKSB7XG4gICAgICB0aHJvdyBnZXRJbnZhbGlkU2Nyb2xsU3RyYXRlZ3lFcnJvcihzdHJhdGVneSk7XG4gICAgfVxuICB9XG59XG4iXX0=