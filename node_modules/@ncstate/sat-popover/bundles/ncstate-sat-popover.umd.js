(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/cdk/overlay'), require('@angular/cdk/a11y'), require('@angular/cdk/bidi'), require('@angular/cdk/coercion'), require('@angular/animations'), require('@angular/cdk/keycodes'), require('@angular/cdk/portal'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('@ncstate/sat-popover', ['exports', '@angular/core', '@angular/common', '@angular/cdk/overlay', '@angular/cdk/a11y', '@angular/cdk/bidi', '@angular/cdk/coercion', '@angular/animations', '@angular/cdk/keycodes', '@angular/cdk/portal', 'rxjs', 'rxjs/operators'], factory) :
    (global = global || self, factory((global.ncstate = global.ncstate || {}, global.ncstate['sat-popover'] = {}), global.ng.core, global.ng.common, global.ng.cdk.overlay, global.ng.cdk.a11y, global.ng.cdk.bidi, global.ng.cdk.coercion, global.ng.animations, global.ng.cdk.keycodes, global.ng.cdk.portal, global.rxjs, global.rxjs.operators));
}(this, function (exports, core, common, overlay, a11y, bidi, coercion, animations, keycodes, portal, rxjs, operators) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var transformPopover = animations.trigger('transformPopover', [
        animations.transition(':enter', [
            animations.style({ opacity: 0, transform: 'scale(0.3)' }),
            animations.animate('{{openTransition}}', animations.style({ opacity: 1, transform: 'scale(1)' }))
        ]),
        animations.transition(':leave', [
            animations.animate('{{closeTransition}}', animations.style({ opacity: 0, transform: 'scale(0.5)' }))
        ])
    ]);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var VALID_SCROLL = [
        'noop',
        'block',
        'reposition',
        'close'
    ];
    /** @type {?} */
    var VALID_HORIZ_ALIGN = [
        'before',
        'start',
        'center',
        'end',
        'after'
    ];
    /** @type {?} */
    var VALID_VERT_ALIGN = [
        'above',
        'start',
        'center',
        'end',
        'below'
    ];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @return {?}
     */
    function getUnanchoredPopoverError() {
        return Error('SatPopover does not have an anchor.');
    }
    /**
     * @return {?}
     */
    function getInvalidPopoverAnchorError() {
        return Error('SatPopover#anchor must be an instance of SatPopoverAnchor, ElementRef, or HTMLElement.');
    }
    /**
     * @return {?}
     */
    function getInvalidPopoverError() {
        return Error('SatPopoverAnchor#satPopoverAnchor must be an instance of SatPopover.');
    }
    /**
     * @return {?}
     */
    function getInvalidSatPopoverAnchorError() {
        return Error("SatPopoverAnchor must be associated with a " +
            "SatPopover component. " +
            "Examples: <sat-popover [anchor]=\"satPopoverAnchorTemplateRef\"> or " +
            "<button satPopoverAnchor [satPopoverAnchor]=\"satPopoverTemplateRef\">");
    }
    /**
     * @param {?} alignment
     * @return {?}
     */
    function getInvalidHorizontalAlignError(alignment) {
        return Error(generateGenericError('horizontalAlign/xAlign', alignment, VALID_HORIZ_ALIGN));
    }
    /**
     * @param {?} alignment
     * @return {?}
     */
    function getInvalidVerticalAlignError(alignment) {
        return Error(generateGenericError('verticalAlign/yAlign', alignment, VALID_VERT_ALIGN));
    }
    /**
     * @param {?} strategy
     * @return {?}
     */
    function getInvalidScrollStrategyError(strategy) {
        return Error(generateGenericError('scrollStrategy', strategy, VALID_SCROLL));
    }
    /**
     * @param {?} apiName
     * @param {?} invalid
     * @param {?} valid
     * @return {?}
     */
    function generateGenericError(apiName, invalid, valid) {
        return "Invalid " + apiName + ": '" + invalid + "'. Valid options are " + valid.map((/**
         * @param {?} v
         * @return {?}
         */
        function (v) { return "'" + v + "'"; })).join(', ') + ".";
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SatPopoverAnchoringService = /** @class */ (function () {
        function SatPopoverAnchoringService(_overlay, _ngZone, _dir) {
            this._overlay = _overlay;
            this._ngZone = _ngZone;
            this._dir = _dir;
            /**
             * Emits when the popover is opened.
             */
            this.popoverOpened = new rxjs.Subject();
            /**
             * Emits when the popover is closed.
             */
            this.popoverClosed = new rxjs.Subject();
            /**
             * Whether the popover is presently open.
             */
            this._popoverOpen = false;
            /**
             * Emits when the service is destroyed.
             */
            this._onDestroy = new rxjs.Subject();
        }
        /**
         * @return {?}
         */
        SatPopoverAnchoringService.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            // Destroy popover before terminating subscriptions so that any resulting
            // detachments update 'closed state'
            this._destroyPopover();
            // Terminate subscriptions
            if (this._notificationsSubscription) {
                this._notificationsSubscription.unsubscribe();
            }
            if (this._positionChangeSubscription) {
                this._positionChangeSubscription.unsubscribe();
            }
            this._onDestroy.next();
            this._onDestroy.complete();
            this.popoverOpened.complete();
            this.popoverClosed.complete();
        };
        /** Anchor a popover instance to a view and connection element. */
        /**
         * Anchor a popover instance to a view and connection element.
         * @param {?} popover
         * @param {?} viewContainerRef
         * @param {?} anchor
         * @return {?}
         */
        SatPopoverAnchoringService.prototype.anchor = /**
         * Anchor a popover instance to a view and connection element.
         * @param {?} popover
         * @param {?} viewContainerRef
         * @param {?} anchor
         * @return {?}
         */
        function (popover, viewContainerRef, anchor) {
            // If we're just changing the anchor element and the overlayRef already exists,
            // simply update the existing _overlayRef's anchor.
            if (this._popover === popover &&
                this._viewContainerRef === viewContainerRef &&
                this._overlayRef) {
                this._anchor = anchor instanceof core.ElementRef
                    ? anchor.nativeElement
                    : anchor;
                /** @type {?} */
                var config = this._overlayRef.getConfig();
                /** @type {?} */
                var strategy = (/** @type {?} */ (config.positionStrategy));
                strategy.setOrigin(this._anchor);
                this._overlayRef.updatePosition();
                return;
            }
            // Destroy any previous popovers
            this._destroyPopover();
            // Assign local refs
            this._popover = popover;
            this._viewContainerRef = viewContainerRef;
            this._anchor = anchor instanceof core.ElementRef
                ? anchor.nativeElement
                : anchor;
        };
        /** Gets whether the popover is presently open. */
        /**
         * Gets whether the popover is presently open.
         * @return {?}
         */
        SatPopoverAnchoringService.prototype.isPopoverOpen = /**
         * Gets whether the popover is presently open.
         * @return {?}
         */
        function () {
            return this._popoverOpen;
        };
        /** Toggles the popover between the open and closed states. */
        /**
         * Toggles the popover between the open and closed states.
         * @return {?}
         */
        SatPopoverAnchoringService.prototype.togglePopover = /**
         * Toggles the popover between the open and closed states.
         * @return {?}
         */
        function () {
            return this._popoverOpen ? this.closePopover() : this.openPopover();
        };
        /** Opens the popover. */
        /**
         * Opens the popover.
         * @param {?=} options
         * @return {?}
         */
        SatPopoverAnchoringService.prototype.openPopover = /**
         * Opens the popover.
         * @param {?=} options
         * @return {?}
         */
        function (options) {
            if (options === void 0) { options = {}; }
            if (!this._popoverOpen) {
                this._applyOpenOptions(options);
                this._createOverlay();
                this._subscribeToBackdrop();
                this._subscribeToEscape();
                this._subscribeToDetachments();
                this._saveOpenedState();
            }
        };
        /** Closes the popover. */
        /**
         * Closes the popover.
         * @param {?=} value
         * @return {?}
         */
        SatPopoverAnchoringService.prototype.closePopover = /**
         * Closes the popover.
         * @param {?=} value
         * @return {?}
         */
        function (value) {
            if (this._overlayRef) {
                this._saveClosedState(value);
                this._overlayRef.detach();
            }
        };
        /** TODO: implement when the overlay's position can be dynamically changed */
        /**
         * TODO: implement when the overlay's position can be dynamically changed
         * @return {?}
         */
        SatPopoverAnchoringService.prototype.repositionPopover = /**
         * TODO: implement when the overlay's position can be dynamically changed
         * @return {?}
         */
        function () {
            this.updatePopoverConfig();
        };
        /** TODO: when the overlay's position can be dynamically changed, do not destroy */
        /**
         * TODO: when the overlay's position can be dynamically changed, do not destroy
         * @return {?}
         */
        SatPopoverAnchoringService.prototype.updatePopoverConfig = /**
         * TODO: when the overlay's position can be dynamically changed, do not destroy
         * @return {?}
         */
        function () {
            this._destroyPopoverOnceClosed();
        };
        /** Realign the popover to the anchor. */
        /**
         * Realign the popover to the anchor.
         * @return {?}
         */
        SatPopoverAnchoringService.prototype.realignPopoverToAnchor = /**
         * Realign the popover to the anchor.
         * @return {?}
         */
        function () {
            if (this._overlayRef) {
                /** @type {?} */
                var config = this._overlayRef.getConfig();
                /** @type {?} */
                var strategy = (/** @type {?} */ (config.positionStrategy));
                strategy.reapplyLastPosition();
            }
        };
        /** Get a reference to the anchor element. */
        /**
         * Get a reference to the anchor element.
         * @return {?}
         */
        SatPopoverAnchoringService.prototype.getAnchorElement = /**
         * Get a reference to the anchor element.
         * @return {?}
         */
        function () {
            return this._anchor;
        };
        /** Apply behavior properties on the popover based on the open options. */
        /**
         * Apply behavior properties on the popover based on the open options.
         * @private
         * @param {?} options
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._applyOpenOptions = /**
         * Apply behavior properties on the popover based on the open options.
         * @private
         * @param {?} options
         * @return {?}
         */
        function (options) {
            // Only override restoreFocus as `false` if the option is explicitly `false`
            /** @type {?} */
            var restoreFocus = options.restoreFocus !== false;
            this._popover._restoreFocusOverride = restoreFocus;
            // Only override autoFocus as `false` if the option is explicitly `false`
            /** @type {?} */
            var autoFocus = options.autoFocus !== false;
            this._popover._autoFocusOverride = autoFocus;
        };
        /** Create an overlay to be attached to the portal. */
        /**
         * Create an overlay to be attached to the portal.
         * @private
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._createOverlay = /**
         * Create an overlay to be attached to the portal.
         * @private
         * @return {?}
         */
        function () {
            // Create overlay if it doesn't yet exist
            if (!this._overlayRef) {
                this._portal = new portal.TemplatePortal(this._popover._templateRef, this._viewContainerRef);
                /** @type {?} */
                var popoverConfig = {
                    horizontalAlign: this._popover.horizontalAlign,
                    verticalAlign: this._popover.verticalAlign,
                    hasBackdrop: this._popover.hasBackdrop,
                    backdropClass: this._popover.backdropClass,
                    scrollStrategy: this._popover.scrollStrategy,
                    forceAlignment: this._popover.forceAlignment,
                    lockAlignment: this._popover.lockAlignment,
                };
                /** @type {?} */
                var overlayConfig = this._getOverlayConfig(popoverConfig, this._anchor);
                this._subscribeToPositionChanges((/** @type {?} */ (overlayConfig.positionStrategy)));
                this._overlayRef = this._overlay.create(overlayConfig);
            }
            // Actually open the popover
            this._overlayRef.attach(this._portal);
            return this._overlayRef;
        };
        /** Removes the popover from the DOM. Does NOT update open state. */
        /**
         * Removes the popover from the DOM. Does NOT update open state.
         * @private
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._destroyPopover = /**
         * Removes the popover from the DOM. Does NOT update open state.
         * @private
         * @return {?}
         */
        function () {
            if (this._overlayRef) {
                this._overlayRef.dispose();
                this._overlayRef = null;
            }
        };
        /**
         * Destroys the popover immediately if it is closed, or waits until it
         * has been closed to destroy it.
         */
        /**
         * Destroys the popover immediately if it is closed, or waits until it
         * has been closed to destroy it.
         * @private
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._destroyPopoverOnceClosed = /**
         * Destroys the popover immediately if it is closed, or waits until it
         * has been closed to destroy it.
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.isPopoverOpen() && this._overlayRef) {
                this._overlayRef.detachments().pipe(operators.take(1), operators.takeUntil(this._onDestroy)).subscribe((/**
                 * @return {?}
                 */
                function () { return _this._destroyPopover(); }));
            }
            else {
                this._destroyPopover();
            }
        };
        /** Close popover when backdrop is clicked. */
        /**
         * Close popover when backdrop is clicked.
         * @private
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._subscribeToBackdrop = /**
         * Close popover when backdrop is clicked.
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this._overlayRef
                .backdropClick()
                .pipe(operators.tap((/**
             * @return {?}
             */
            function () { return _this._popover.backdropClicked.emit(); })), operators.filter((/**
             * @return {?}
             */
            function () { return _this._popover.interactiveClose; })), operators.takeUntil(this.popoverClosed), operators.takeUntil(this._onDestroy))
                .subscribe((/**
             * @return {?}
             */
            function () { return _this.closePopover(); }));
        };
        /** Close popover when escape keydown event occurs. */
        /**
         * Close popover when escape keydown event occurs.
         * @private
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._subscribeToEscape = /**
         * Close popover when escape keydown event occurs.
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this._overlayRef
                .keydownEvents()
                .pipe(operators.tap((/**
             * @param {?} event
             * @return {?}
             */
            function (event) { return _this._popover.overlayKeydown.emit(event); })), operators.filter((/**
             * @param {?} event
             * @return {?}
             */
            function (event) { return event.keyCode === keycodes.ESCAPE; })), operators.filter((/**
             * @return {?}
             */
            function () { return _this._popover.interactiveClose; })), operators.takeUntil(this.popoverClosed), operators.takeUntil(this._onDestroy))
                .subscribe((/**
             * @return {?}
             */
            function () { return _this.closePopover(); }));
        };
        /** Set state back to closed when detached. */
        /**
         * Set state back to closed when detached.
         * @private
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._subscribeToDetachments = /**
         * Set state back to closed when detached.
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this._overlayRef
                .detachments()
                .pipe(operators.takeUntil(this._onDestroy))
                .subscribe((/**
             * @return {?}
             */
            function () { return _this._saveClosedState(); }));
        };
        /** Save the opened state of the popover and emit. */
        /**
         * Save the opened state of the popover and emit.
         * @private
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._saveOpenedState = /**
         * Save the opened state of the popover and emit.
         * @private
         * @return {?}
         */
        function () {
            if (!this._popoverOpen) {
                this._popover._open = this._popoverOpen = true;
                this.popoverOpened.next();
                this._popover.opened.emit();
            }
        };
        /** Save the closed state of the popover and emit. */
        /**
         * Save the closed state of the popover and emit.
         * @private
         * @param {?=} value
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._saveClosedState = /**
         * Save the closed state of the popover and emit.
         * @private
         * @param {?=} value
         * @return {?}
         */
        function (value) {
            if (this._popoverOpen) {
                this._popover._open = this._popoverOpen = false;
                this.popoverClosed.next(value);
                this._popover.closed.emit(value);
            }
        };
        /** Gets the text direction of the containing app. */
        /**
         * Gets the text direction of the containing app.
         * @private
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._getDirection = /**
         * Gets the text direction of the containing app.
         * @private
         * @return {?}
         */
        function () {
            return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
        };
        /** Create and return a config for creating the overlay. */
        /**
         * Create and return a config for creating the overlay.
         * @private
         * @param {?} config
         * @param {?} anchor
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._getOverlayConfig = /**
         * Create and return a config for creating the overlay.
         * @private
         * @param {?} config
         * @param {?} anchor
         * @return {?}
         */
        function (config, anchor) {
            return new overlay.OverlayConfig({
                positionStrategy: this._getPositionStrategy(config.horizontalAlign, config.verticalAlign, config.forceAlignment, config.lockAlignment, anchor),
                hasBackdrop: config.hasBackdrop,
                backdropClass: config.backdropClass || 'cdk-overlay-transparent-backdrop',
                scrollStrategy: this._getScrollStrategyInstance(config.scrollStrategy),
                direction: this._getDirection(),
            });
        };
        /**
         * Listen to changes in the position of the overlay and set the correct alignment classes,
         * ensuring that the animation origin is correct, even with a fallback position.
         */
        /**
         * Listen to changes in the position of the overlay and set the correct alignment classes,
         * ensuring that the animation origin is correct, even with a fallback position.
         * @private
         * @param {?} position
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._subscribeToPositionChanges = /**
         * Listen to changes in the position of the overlay and set the correct alignment classes,
         * ensuring that the animation origin is correct, even with a fallback position.
         * @private
         * @param {?} position
         * @return {?}
         */
        function (position) {
            var _this = this;
            if (this._positionChangeSubscription) {
                this._positionChangeSubscription.unsubscribe();
            }
            this._positionChangeSubscription = position.positionChanges
                .pipe(operators.takeUntil(this._onDestroy))
                .subscribe((/**
             * @param {?} change
             * @return {?}
             */
            function (change) {
                // Position changes may occur outside the Angular zone
                _this._ngZone.run((/**
                 * @return {?}
                 */
                function () {
                    _this._popover._setAlignmentClasses(getHorizontalPopoverAlignment(change.connectionPair.overlayX), getVerticalPopoverAlignment(change.connectionPair.overlayY));
                }));
            }));
        };
        /** Map a scroll strategy string type to an instance of a scroll strategy. */
        /**
         * Map a scroll strategy string type to an instance of a scroll strategy.
         * @private
         * @param {?} strategy
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._getScrollStrategyInstance = /**
         * Map a scroll strategy string type to an instance of a scroll strategy.
         * @private
         * @param {?} strategy
         * @return {?}
         */
        function (strategy) {
            switch (strategy) {
                case 'block':
                    return this._overlay.scrollStrategies.block();
                case 'reposition':
                    return this._overlay.scrollStrategies.reposition();
                case 'close':
                    return this._overlay.scrollStrategies.close();
                case 'noop':
                default:
                    return this._overlay.scrollStrategies.noop();
            }
        };
        /** Create and return a position strategy based on config provided to the component instance. */
        /**
         * Create and return a position strategy based on config provided to the component instance.
         * @private
         * @param {?} horizontalTarget
         * @param {?} verticalTarget
         * @param {?} forceAlignment
         * @param {?} lockAlignment
         * @param {?} anchor
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._getPositionStrategy = /**
         * Create and return a position strategy based on config provided to the component instance.
         * @private
         * @param {?} horizontalTarget
         * @param {?} verticalTarget
         * @param {?} forceAlignment
         * @param {?} lockAlignment
         * @param {?} anchor
         * @return {?}
         */
        function (horizontalTarget, verticalTarget, forceAlignment, lockAlignment, anchor) {
            // Attach the overlay at the preferred position
            /** @type {?} */
            var targetPosition = getPosition(horizontalTarget, verticalTarget);
            /** @type {?} */
            var positions = [targetPosition];
            /** @type {?} */
            var strategy = this._overlay.position()
                .flexibleConnectedTo(anchor)
                .withFlexibleDimensions(false)
                .withPush(false)
                .withViewportMargin(0)
                .withLockedPosition(lockAlignment);
            // Unless the alignment is forced, add fallbacks based on the preferred positions
            if (!forceAlignment) {
                /** @type {?} */
                var fallbacks = this._getFallbacks(horizontalTarget, verticalTarget);
                positions.push.apply(positions, __spread(fallbacks));
            }
            return strategy.withPositions(positions);
        };
        /** Get fallback positions based around target alignments. */
        /**
         * Get fallback positions based around target alignments.
         * @private
         * @param {?} hTarget
         * @param {?} vTarget
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._getFallbacks = /**
         * Get fallback positions based around target alignments.
         * @private
         * @param {?} hTarget
         * @param {?} vTarget
         * @return {?}
         */
        function (hTarget, vTarget) {
            // Determine if the target alignments overlap the anchor
            /** @type {?} */
            var horizontalOverlapAllowed = hTarget !== 'before' && hTarget !== 'after';
            /** @type {?} */
            var verticalOverlapAllowed = vTarget !== 'above' && vTarget !== 'below';
            // If a target alignment doesn't cover the anchor, don't let any of the fallback alignments
            // cover the anchor
            /** @type {?} */
            var possibleHorizontalAlignments = horizontalOverlapAllowed ?
                ['before', 'start', 'center', 'end', 'after'] :
                ['before', 'after'];
            /** @type {?} */
            var possibleVerticalAlignments = verticalOverlapAllowed ?
                ['above', 'start', 'center', 'end', 'below'] :
                ['above', 'below'];
            // Create fallbacks for each allowed prioritized fallback alignment combo
            /** @type {?} */
            var fallbacks = [];
            prioritizeAroundTarget(hTarget, possibleHorizontalAlignments).forEach((/**
             * @param {?} h
             * @return {?}
             */
            function (h) {
                prioritizeAroundTarget(vTarget, possibleVerticalAlignments).forEach((/**
                 * @param {?} v
                 * @return {?}
                 */
                function (v) {
                    fallbacks.push(getPosition(h, v));
                }));
            }));
            // Remove the first item since it will be the target alignment and isn't considered a fallback
            return fallbacks.slice(1, fallbacks.length);
        };
        SatPopoverAnchoringService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        SatPopoverAnchoringService.ctorParameters = function () { return [
            { type: overlay.Overlay },
            { type: core.NgZone },
            { type: bidi.Directionality, decorators: [{ type: core.Optional }] }
        ]; };
        return SatPopoverAnchoringService;
    }());
    /**
     * Helper function to get a cdk position pair from SatPopover alignments.
     * @param {?} h
     * @param {?} v
     * @return {?}
     */
    function getPosition(h, v) {
        var _a = getHorizontalConnectionPosPair(h), originX = _a.originX, overlayX = _a.overlayX;
        var _b = getVerticalConnectionPosPair(v), originY = _b.originY, overlayY = _b.overlayY;
        return new overlay.ConnectionPositionPair({ originX: originX, originY: originY }, { overlayX: overlayX, overlayY: overlayY });
    }
    /**
     * Helper function to convert an overlay connection position to equivalent popover alignment.
     * @param {?} h
     * @return {?}
     */
    function getHorizontalPopoverAlignment(h) {
        if (h === 'start') {
            return 'after';
        }
        if (h === 'end') {
            return 'before';
        }
        return 'center';
    }
    /**
     * Helper function to convert an overlay connection position to equivalent popover alignment.
     * @param {?} v
     * @return {?}
     */
    function getVerticalPopoverAlignment(v) {
        if (v === 'top') {
            return 'below';
        }
        if (v === 'bottom') {
            return 'above';
        }
        return 'center';
    }
    /**
     * Helper function to convert alignment to origin/overlay position pair.
     * @param {?} h
     * @return {?}
     */
    function getHorizontalConnectionPosPair(h) {
        switch (h) {
            case 'before':
                return { originX: 'start', overlayX: 'end' };
            case 'start':
                return { originX: 'start', overlayX: 'start' };
            case 'end':
                return { originX: 'end', overlayX: 'end' };
            case 'after':
                return { originX: 'end', overlayX: 'start' };
            default:
                return { originX: 'center', overlayX: 'center' };
        }
    }
    /**
     * Helper function to convert alignment to origin/overlay position pair.
     * @param {?} v
     * @return {?}
     */
    function getVerticalConnectionPosPair(v) {
        switch (v) {
            case 'above':
                return { originY: 'top', overlayY: 'bottom' };
            case 'start':
                return { originY: 'top', overlayY: 'top' };
            case 'end':
                return { originY: 'bottom', overlayY: 'bottom' };
            case 'below':
                return { originY: 'bottom', overlayY: 'top' };
            default:
                return { originY: 'center', overlayY: 'center' };
        }
    }
    /**
     * Helper function that takes an ordered array options and returns a reorderded
     * array around the target item. e.g.:
     *
     * target: 3; options: [1, 2, 3, 4, 5, 6, 7];
     *
     * return: [3, 4, 2, 5, 1, 6, 7]
     * @template T
     * @param {?} target
     * @param {?} options
     * @return {?}
     */
    function prioritizeAroundTarget(target, options) {
        /** @type {?} */
        var targetIndex = options.indexOf(target);
        // Set the first item to be the target
        /** @type {?} */
        var reordered = [target];
        // Make left and right stacks where the highest priority item is last
        /** @type {?} */
        var left = options.slice(0, targetIndex);
        /** @type {?} */
        var right = options.slice(targetIndex + 1, options.length).reverse();
        // Alternate between stacks until one is empty
        while (left.length && right.length) {
            reordered.push(right.pop());
            reordered.push(left.pop());
        }
        // Flush out right side
        while (right.length) {
            reordered.push(right.pop());
        }
        // Flush out left side
        while (left.length) {
            reordered.push(left.pop());
        }
        return reordered;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // See http://cubic-bezier.com/#.25,.8,.25,1 for reference.
    /** @type {?} */
    var DEFAULT_TRANSITION = '200ms cubic-bezier(0.25, 0.8, 0.25, 1)';
    var SatPopoverAnchor = /** @class */ (function () {
        function SatPopoverAnchor(elementRef, viewContainerRef) {
            this.elementRef = elementRef;
            this.viewContainerRef = viewContainerRef;
        }
        Object.defineProperty(SatPopoverAnchor.prototype, "popover", {
            get: /**
             * @return {?}
             */
            function () {
                return this._popover;
            },
            set: /**
             * @param {?} val
             * @return {?}
             */
            function (val) {
                if (val instanceof SatPopover) {
                    val.anchor = this;
                }
                else {
                    // when a directive is added with no arguments,
                    // angular assigns `''` as the argument
                    if (val !== '') {
                        throw getInvalidPopoverError();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SatPopoverAnchor.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            if (!this.popover) {
                throw getInvalidSatPopoverAnchorError();
            }
        };
        SatPopoverAnchor.decorators = [
            { type: core.Directive, args: [{
                        selector: '[satPopoverAnchor]',
                        exportAs: 'satPopoverAnchor'
                    },] }
        ];
        /** @nocollapse */
        SatPopoverAnchor.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.ViewContainerRef }
        ]; };
        SatPopoverAnchor.propDecorators = {
            popover: [{ type: core.Input, args: ['satPopoverAnchor',] }]
        };
        return SatPopoverAnchor;
    }());
    var SatPopover = /** @class */ (function () {
        function SatPopover(_focusTrapFactory, _anchoringService, _viewContainerRef, _document) {
            this._focusTrapFactory = _focusTrapFactory;
            this._viewContainerRef = _viewContainerRef;
            this._document = _document;
            this._horizontalAlign = 'center';
            this._verticalAlign = 'center';
            this._forceAlignment = false;
            this._lockAlignment = false;
            this._autoFocus = true;
            this._autoFocusOverride = true;
            this._restoreFocus = true;
            this._restoreFocusOverride = true;
            this._scrollStrategy = 'reposition';
            this._hasBackdrop = false;
            this._interactiveClose = true;
            this._openTransition = DEFAULT_TRANSITION;
            this._closeTransition = DEFAULT_TRANSITION;
            /**
             * Optional backdrop class.
             */
            this.backdropClass = '';
            /**
             * Emits when the popover is opened.
             */
            this.opened = new core.EventEmitter();
            /**
             * Emits when the popover is closed.
             */
            this.closed = new core.EventEmitter();
            /**
             * Emits when the popover has finished opening.
             */
            this.afterOpen = new core.EventEmitter();
            /**
             * Emits when the popover has finished closing.
             */
            this.afterClose = new core.EventEmitter();
            /**
             * Emits when the backdrop is clicked.
             */
            this.backdropClicked = new core.EventEmitter();
            /**
             * Emits when a keydown event is targeted to this popover's overlay.
             */
            this.overlayKeydown = new core.EventEmitter();
            /**
             * Classes to be added to the popover for setting the correct transform origin.
             */
            this._classList = {};
            /**
             * Whether the popover is presently open.
             */
            this._open = false;
            // `@internal` stripping doesn't seem to work if the property is
            // declared inside the constructor
            this._anchoringService = _anchoringService;
        }
        Object.defineProperty(SatPopover.prototype, "anchor", {
            /** Anchor element. */
            get: /**
             * Anchor element.
             * @return {?}
             */
            function () {
                return this._anchor;
            },
            set: /**
             * @param {?} val
             * @return {?}
             */
            function (val) {
                if (val instanceof SatPopoverAnchor) {
                    val._popover = this;
                    this._anchoringService.anchor(this, val.viewContainerRef, val.elementRef);
                    this._anchor = val;
                }
                else if (val instanceof core.ElementRef || val instanceof HTMLElement) {
                    this._anchoringService.anchor(this, this._viewContainerRef, val);
                    this._anchor = val;
                }
                else if (val) {
                    throw getInvalidPopoverAnchorError();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SatPopover.prototype, "horizontalAlign", {
            /** Alignment of the popover on the horizontal axis. */
            get: /**
             * Alignment of the popover on the horizontal axis.
             * @return {?}
             */
            function () {
                return this._horizontalAlign;
            },
            set: /**
             * @param {?} val
             * @return {?}
             */
            function (val) {
                this._validateHorizontalAlign(val);
                if (this._horizontalAlign !== val) {
                    this._horizontalAlign = val;
                    this._anchoringService.repositionPopover();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SatPopover.prototype, "xAlign", {
            /** Alignment of the popover on the x axis. Alias for `horizontalAlign`. */
            get: /**
             * Alignment of the popover on the x axis. Alias for `horizontalAlign`.
             * @return {?}
             */
            function () {
                return this.horizontalAlign;
            },
            set: /**
             * @param {?} val
             * @return {?}
             */
            function (val) {
                this.horizontalAlign = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SatPopover.prototype, "verticalAlign", {
            /** Alignment of the popover on the vertical axis. */
            get: /**
             * Alignment of the popover on the vertical axis.
             * @return {?}
             */
            function () {
                return this._verticalAlign;
            },
            set: /**
             * @param {?} val
             * @return {?}
             */
            function (val) {
                this._validateVerticalAlign(val);
                if (this._verticalAlign !== val) {
                    this._verticalAlign = val;
                    this._anchoringService.repositionPopover();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SatPopover.prototype, "yAlign", {
            /** Alignment of the popover on the y axis. Alias for `verticalAlign`. */
            get: /**
             * Alignment of the popover on the y axis. Alias for `verticalAlign`.
             * @return {?}
             */
            function () {
                return this.verticalAlign;
            },
            set: /**
             * @param {?} val
             * @return {?}
             */
            function (val) {
                this.verticalAlign = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SatPopover.prototype, "forceAlignment", {
            /** Whether the popover always opens with the specified alignment. */
            get: /**
             * Whether the popover always opens with the specified alignment.
             * @return {?}
             */
            function () {
                return this._forceAlignment;
            },
            set: /**
             * @param {?} val
             * @return {?}
             */
            function (val) {
                /** @type {?} */
                var coercedVal = coercion.coerceBooleanProperty(val);
                if (this._forceAlignment !== coercedVal) {
                    this._forceAlignment = coercedVal;
                    this._anchoringService.repositionPopover();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SatPopover.prototype, "lockAlignment", {
            /**
             * Whether the popover's alignment is locked after opening. This prevents the popover
             * from changing its alignement when scrolling or changing the size of the viewport.
             */
            get: /**
             * Whether the popover's alignment is locked after opening. This prevents the popover
             * from changing its alignement when scrolling or changing the size of the viewport.
             * @return {?}
             */
            function () {
                return this._lockAlignment;
            },
            set: /**
             * @param {?} val
             * @return {?}
             */
            function (val) {
                /** @type {?} */
                var coercedVal = coercion.coerceBooleanProperty(val);
                if (this._lockAlignment !== coercedVal) {
                    this._lockAlignment = coercion.coerceBooleanProperty(val);
                    this._anchoringService.repositionPopover();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SatPopover.prototype, "autoFocus", {
            /** Whether the first focusable element should be focused on open. */
            get: /**
             * Whether the first focusable element should be focused on open.
             * @return {?}
             */
            function () {
                return this._autoFocus && this._autoFocusOverride;
            },
            set: /**
             * @param {?} val
             * @return {?}
             */
            function (val) {
                this._autoFocus = coercion.coerceBooleanProperty(val);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SatPopover.prototype, "restoreFocus", {
            /** Whether the popover should return focus to the previously focused element after closing. */
            get: /**
             * Whether the popover should return focus to the previously focused element after closing.
             * @return {?}
             */
            function () {
                return this._restoreFocus && this._restoreFocusOverride;
            },
            set: /**
             * @param {?} val
             * @return {?}
             */
            function (val) {
                this._restoreFocus = coercion.coerceBooleanProperty(val);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SatPopover.prototype, "scrollStrategy", {
            /** How the popover should handle scrolling. */
            get: /**
             * How the popover should handle scrolling.
             * @return {?}
             */
            function () {
                return this._scrollStrategy;
            },
            set: /**
             * @param {?} val
             * @return {?}
             */
            function (val) {
                this._validateScrollStrategy(val);
                if (this._scrollStrategy !== val) {
                    this._scrollStrategy = val;
                    this._anchoringService.updatePopoverConfig();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SatPopover.prototype, "hasBackdrop", {
            /** Whether the popover should have a backdrop (includes closing on click). */
            get: /**
             * Whether the popover should have a backdrop (includes closing on click).
             * @return {?}
             */
            function () {
                return this._hasBackdrop;
            },
            set: /**
             * @param {?} val
             * @return {?}
             */
            function (val) {
                this._hasBackdrop = coercion.coerceBooleanProperty(val);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SatPopover.prototype, "interactiveClose", {
            /** Whether the popover should close when the user clicks the backdrop or presses ESC. */
            get: /**
             * Whether the popover should close when the user clicks the backdrop or presses ESC.
             * @return {?}
             */
            function () {
                return this._interactiveClose;
            },
            set: /**
             * @param {?} val
             * @return {?}
             */
            function (val) {
                this._interactiveClose = coercion.coerceBooleanProperty(val);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SatPopover.prototype, "openTransition", {
            /** Custom transition to use while opening. */
            get: /**
             * Custom transition to use while opening.
             * @return {?}
             */
            function () {
                return this._openTransition;
            },
            set: /**
             * @param {?} val
             * @return {?}
             */
            function (val) {
                if (val) {
                    this._openTransition = val;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SatPopover.prototype, "closeTransition", {
            /** Custom transition to use while closing. */
            get: /**
             * Custom transition to use while closing.
             * @return {?}
             */
            function () {
                return this._closeTransition;
            },
            set: /**
             * @param {?} val
             * @return {?}
             */
            function (val) {
                if (val) {
                    this._closeTransition = val;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SatPopover.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this._setAlignmentClasses();
        };
        /** Open this popover. */
        /**
         * Open this popover.
         * @param {?=} options
         * @return {?}
         */
        SatPopover.prototype.open = /**
         * Open this popover.
         * @param {?=} options
         * @return {?}
         */
        function (options) {
            if (options === void 0) { options = {}; }
            if (this._anchor) {
                this._anchoringService.openPopover(options);
                return;
            }
            throw getUnanchoredPopoverError();
        };
        /** Close this popover. */
        /**
         * Close this popover.
         * @param {?=} value
         * @return {?}
         */
        SatPopover.prototype.close = /**
         * Close this popover.
         * @param {?=} value
         * @return {?}
         */
        function (value) {
            this._anchoringService.closePopover(value);
        };
        /** Toggle this popover open or closed. */
        /**
         * Toggle this popover open or closed.
         * @return {?}
         */
        SatPopover.prototype.toggle = /**
         * Toggle this popover open or closed.
         * @return {?}
         */
        function () {
            this._anchoringService.togglePopover();
        };
        /** Realign the popover to the anchor. */
        /**
         * Realign the popover to the anchor.
         * @return {?}
         */
        SatPopover.prototype.realign = /**
         * Realign the popover to the anchor.
         * @return {?}
         */
        function () {
            this._anchoringService.realignPopoverToAnchor();
        };
        /** Gets whether the popover is presently open. */
        /**
         * Gets whether the popover is presently open.
         * @return {?}
         */
        SatPopover.prototype.isOpen = /**
         * Gets whether the popover is presently open.
         * @return {?}
         */
        function () {
            return this._open;
        };
        /** Allows programmatically setting a custom anchor. */
        /**
         * Allows programmatically setting a custom anchor.
         * @param {?} viewContainer
         * @param {?} el
         * @return {?}
         */
        SatPopover.prototype.setCustomAnchor = /**
         * Allows programmatically setting a custom anchor.
         * @param {?} viewContainer
         * @param {?} el
         * @return {?}
         */
        function (viewContainer, el) {
            this._anchor = el;
            this._anchoringService.anchor(this, viewContainer, el);
        };
        /** Gets an animation config with customized (or default) transition values. */
        /**
         * Gets an animation config with customized (or default) transition values.
         * @return {?}
         */
        SatPopover.prototype._getAnimation = /**
         * Gets an animation config with customized (or default) transition values.
         * @return {?}
         */
        function () {
            return {
                value: 'visible',
                params: { openTransition: this.openTransition, closeTransition: this.closeTransition }
            };
        };
        /** Callback for when the popover is finished animating in or out. */
        /**
         * Callback for when the popover is finished animating in or out.
         * @param {?} event
         * @return {?}
         */
        SatPopover.prototype._onAnimationDone = /**
         * Callback for when the popover is finished animating in or out.
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (event.toState === 'visible') {
                this._trapFocus();
                this.afterOpen.emit();
            }
            else if (event.toState === 'void') {
                this._restoreFocusAndDestroyTrap();
                this.afterClose.emit();
            }
        };
        /** Apply alignment classes based on alignment inputs. */
        /**
         * Apply alignment classes based on alignment inputs.
         * @param {?=} horizAlign
         * @param {?=} vertAlign
         * @return {?}
         */
        SatPopover.prototype._setAlignmentClasses = /**
         * Apply alignment classes based on alignment inputs.
         * @param {?=} horizAlign
         * @param {?=} vertAlign
         * @return {?}
         */
        function (horizAlign, vertAlign) {
            if (horizAlign === void 0) { horizAlign = this.horizontalAlign; }
            if (vertAlign === void 0) { vertAlign = this.verticalAlign; }
            this._classList['sat-popover-before'] = horizAlign === 'before' || horizAlign === 'end';
            this._classList['sat-popover-after'] = horizAlign === 'after' || horizAlign === 'start';
            this._classList['sat-popover-above'] = vertAlign === 'above' || vertAlign === 'end';
            this._classList['sat-popover-below'] = vertAlign === 'below' || vertAlign === 'start';
            this._classList['sat-popover-center'] = horizAlign === 'center' || vertAlign === 'center';
        };
        /** Move the focus inside the focus trap and remember where to return later. */
        /**
         * Move the focus inside the focus trap and remember where to return later.
         * @private
         * @return {?}
         */
        SatPopover.prototype._trapFocus = /**
         * Move the focus inside the focus trap and remember where to return later.
         * @private
         * @return {?}
         */
        function () {
            this._savePreviouslyFocusedElement();
            // There won't be a focus trap element if the close animation starts before open finishes
            if (!this._focusTrapElement) {
                return;
            }
            if (!this._focusTrap && this._focusTrapElement) {
                this._focusTrap = this._focusTrapFactory.create(this._focusTrapElement.nativeElement);
            }
            if (this.autoFocus) {
                this._focusTrap.focusInitialElementWhenReady();
            }
        };
        /** Restore focus to the element focused before the popover opened. Also destroy trap. */
        /**
         * Restore focus to the element focused before the popover opened. Also destroy trap.
         * @private
         * @return {?}
         */
        SatPopover.prototype._restoreFocusAndDestroyTrap = /**
         * Restore focus to the element focused before the popover opened. Also destroy trap.
         * @private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var toFocus = this._previouslyFocusedElement;
            // Must check active element is focusable for IE sake
            if (toFocus && 'focus' in toFocus && this.restoreFocus) {
                this._previouslyFocusedElement.focus();
            }
            this._previouslyFocusedElement = null;
            if (this._focusTrap) {
                this._focusTrap.destroy();
                this._focusTrap = undefined;
            }
        };
        /** Save a reference to the element focused before the popover was opened. */
        /**
         * Save a reference to the element focused before the popover was opened.
         * @private
         * @return {?}
         */
        SatPopover.prototype._savePreviouslyFocusedElement = /**
         * Save a reference to the element focused before the popover was opened.
         * @private
         * @return {?}
         */
        function () {
            if (this._document) {
                this._previouslyFocusedElement = (/** @type {?} */ (this._document.activeElement));
            }
        };
        /** Throws an error if the alignment is not a valid horizontalAlign. */
        /**
         * Throws an error if the alignment is not a valid horizontalAlign.
         * @private
         * @param {?} pos
         * @return {?}
         */
        SatPopover.prototype._validateHorizontalAlign = /**
         * Throws an error if the alignment is not a valid horizontalAlign.
         * @private
         * @param {?} pos
         * @return {?}
         */
        function (pos) {
            if (VALID_HORIZ_ALIGN.indexOf(pos) === -1) {
                throw getInvalidHorizontalAlignError(pos);
            }
        };
        /** Throws an error if the alignment is not a valid verticalAlign. */
        /**
         * Throws an error if the alignment is not a valid verticalAlign.
         * @private
         * @param {?} pos
         * @return {?}
         */
        SatPopover.prototype._validateVerticalAlign = /**
         * Throws an error if the alignment is not a valid verticalAlign.
         * @private
         * @param {?} pos
         * @return {?}
         */
        function (pos) {
            if (VALID_VERT_ALIGN.indexOf(pos) === -1) {
                throw getInvalidVerticalAlignError(pos);
            }
        };
        /** Throws an error if the scroll strategy is not a valid strategy. */
        /**
         * Throws an error if the scroll strategy is not a valid strategy.
         * @private
         * @param {?} strategy
         * @return {?}
         */
        SatPopover.prototype._validateScrollStrategy = /**
         * Throws an error if the scroll strategy is not a valid strategy.
         * @private
         * @param {?} strategy
         * @return {?}
         */
        function (strategy) {
            if (VALID_SCROLL.indexOf(strategy) === -1) {
                throw getInvalidScrollStrategyError(strategy);
            }
        };
        SatPopover.decorators = [
            { type: core.Component, args: [{
                        selector: 'sat-popover',
                        encapsulation: core.ViewEncapsulation.None,
                        animations: [transformPopover],
                        template: "<ng-template>\n  <div class=\"sat-popover-container\"\n      #focusTrapElement\n      [ngClass]=\"_classList\"\n      [@transformPopover]=\"_getAnimation()\"\n      (@transformPopover.done)=\"_onAnimationDone($event)\">\n    <ng-content></ng-content>\n  </div>\n</ng-template>\n",
                        providers: [SatPopoverAnchoringService],
                        styles: [".cdk-global-overlay-wrapper,.cdk-overlay-container{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}@media screen and (-ms-high-contrast:active){.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop,.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}.sat-popover-container.sat-popover-before.sat-popover-above{-webkit-transform-origin:right bottom;transform-origin:right bottom}[dir=rtl] .sat-popover-container.sat-popover-before.sat-popover-above{-webkit-transform-origin:left bottom;transform-origin:left bottom}.sat-popover-container.sat-popover-before.sat-popover-center{-webkit-transform-origin:right center;transform-origin:right center}[dir=rtl] .sat-popover-container.sat-popover-before.sat-popover-center{-webkit-transform-origin:left center;transform-origin:left center}.sat-popover-container.sat-popover-before.sat-popover-below{-webkit-transform-origin:right top;transform-origin:right top}[dir=rtl] .sat-popover-container.sat-popover-before.sat-popover-below{-webkit-transform-origin:left top;transform-origin:left top}.sat-popover-container.sat-popover-center.sat-popover-above{-webkit-transform-origin:center bottom;transform-origin:center bottom}.sat-popover-container.sat-popover-center.sat-popover-below{-webkit-transform-origin:center top;transform-origin:center top}.sat-popover-container.sat-popover-after.sat-popover-above{-webkit-transform-origin:left bottom;transform-origin:left bottom}[dir=rtl] .sat-popover-container.sat-popover-after.sat-popover-above{-webkit-transform-origin:right bottom;transform-origin:right bottom}.sat-popover-container.sat-popover-after.sat-popover-center{-webkit-transform-origin:left center;transform-origin:left center}[dir=rtl] .sat-popover-container.sat-popover-after.sat-popover-center{-webkit-transform-origin:right center;transform-origin:right center}.sat-popover-container.sat-popover-after.sat-popover-below{-webkit-transform-origin:left top;transform-origin:left top}[dir=rtl] .sat-popover-container.sat-popover-after.sat-popover-below{-webkit-transform-origin:right top;transform-origin:right top}"]
                    }] }
        ];
        /** @nocollapse */
        SatPopover.ctorParameters = function () { return [
            { type: a11y.FocusTrapFactory },
            { type: SatPopoverAnchoringService },
            { type: core.ViewContainerRef },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [common.DOCUMENT,] }] }
        ]; };
        SatPopover.propDecorators = {
            anchor: [{ type: core.Input }],
            horizontalAlign: [{ type: core.Input }],
            xAlign: [{ type: core.Input }],
            verticalAlign: [{ type: core.Input }],
            yAlign: [{ type: core.Input }],
            forceAlignment: [{ type: core.Input }],
            lockAlignment: [{ type: core.Input }],
            autoFocus: [{ type: core.Input }],
            restoreFocus: [{ type: core.Input }],
            scrollStrategy: [{ type: core.Input }],
            hasBackdrop: [{ type: core.Input }],
            interactiveClose: [{ type: core.Input }],
            openTransition: [{ type: core.Input }],
            closeTransition: [{ type: core.Input }],
            backdropClass: [{ type: core.Input }],
            opened: [{ type: core.Output }],
            closed: [{ type: core.Output }],
            afterOpen: [{ type: core.Output }],
            afterClose: [{ type: core.Output }],
            backdropClicked: [{ type: core.Output }],
            overlayKeydown: [{ type: core.Output }],
            _templateRef: [{ type: core.ViewChild, args: [core.TemplateRef, { static: true },] }],
            _focusTrapElement: [{ type: core.ViewChild, args: ['focusTrapElement', { static: false },] }]
        };
        return SatPopover;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SatPopoverHoverDirective = /** @class */ (function () {
        function SatPopoverHoverDirective(anchor) {
            this.anchor = anchor;
            this._satPopoverHover = 0;
            /**
             * Emits when the directive is destroyed.
             */
            this._onDestroy = new rxjs.Subject();
            /**
             * Emits when the user's mouse enters the element.
             */
            this._onMouseEnter = new rxjs.Subject();
            /**
             * Emits when the user's mouse leaves the element.
             */
            this._onMouseLeave = new rxjs.Subject();
        }
        Object.defineProperty(SatPopoverHoverDirective.prototype, "satPopoverHover", {
            /**
             * Amount of time to delay (ms) after hovering starts before
             * the popover opens. Defaults to 0ms.
             */
            get: /**
             * Amount of time to delay (ms) after hovering starts before
             * the popover opens. Defaults to 0ms.
             * @return {?}
             */
            function () { return this._satPopoverHover; },
            set: /**
             * @param {?} val
             * @return {?}
             */
            function (val) {
                this._satPopoverHover = coercion.coerceNumberProperty(val);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SatPopoverHoverDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            // Whenever the user hovers this host element, delay the configured
            // amount of time and open the popover. Terminate if the mouse leaves
            // the host element before the delay is complete.
            this._onMouseEnter
                .pipe(operators.switchMap((/**
             * @return {?}
             */
            function () {
                return rxjs.of(null).pipe(operators.delay(_this._satPopoverHover || 0), operators.takeUntil(_this._onMouseLeave));
            })), operators.takeUntil(this._onDestroy))
                .subscribe((/**
             * @return {?}
             */
            function () { return _this.anchor.popover.open(); }));
        };
        /**
         * @return {?}
         */
        SatPopoverHoverDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        /**
         * @return {?}
         */
        SatPopoverHoverDirective.prototype.showPopover = /**
         * @return {?}
         */
        function () {
            this._onMouseEnter.next();
        };
        /**
         * @return {?}
         */
        SatPopoverHoverDirective.prototype.closePopover = /**
         * @return {?}
         */
        function () {
            this._onMouseLeave.next();
            this.anchor.popover.close();
        };
        SatPopoverHoverDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[satPopoverHover]'
                    },] }
        ];
        /** @nocollapse */
        SatPopoverHoverDirective.ctorParameters = function () { return [
            { type: SatPopoverAnchor }
        ]; };
        SatPopoverHoverDirective.propDecorators = {
            satPopoverHover: [{ type: core.Input }],
            showPopover: [{ type: core.HostListener, args: ['mouseenter',] }],
            closePopover: [{ type: core.HostListener, args: ['mouseleave',] }]
        };
        return SatPopoverHoverDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SatPopoverModule = /** @class */ (function () {
        function SatPopoverModule() {
        }
        SatPopoverModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            overlay.OverlayModule,
                            a11y.A11yModule,
                            bidi.BidiModule,
                        ],
                        declarations: [
                            SatPopover,
                            SatPopoverAnchor,
                            SatPopoverHoverDirective,
                        ],
                        exports: [
                            SatPopover,
                            SatPopoverAnchor,
                            SatPopoverHoverDirective,
                            bidi.BidiModule,
                        ]
                    },] }
        ];
        return SatPopoverModule;
    }());

    exports.SatPopover = SatPopover;
    exports.SatPopoverAnchor = SatPopoverAnchor;
    exports.SatPopoverAnchoringService = SatPopoverAnchoringService;
    exports.SatPopoverHoverDirective = SatPopoverHoverDirective;
    exports.SatPopoverModule = SatPopoverModule;
    exports.ɵa = transformPopover;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=ncstate-sat-popover.umd.js.map
